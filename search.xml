<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES新特性与TypeScript、JS性能优化</title>
    <url>/2021/04/23/ES%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8ETypeScript%E3%80%81JS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><blockquote>
<p>ECMAScript（简称ES）通常被认为是JavaScript的标准化规范，JavaScript是ECMAScript的扩展语言。ECMAScript从2015年开始之后，开始使用年份来命名，ECMAScript2015也成ES6，后续的ES2016，ES2017，ES2018。</p>
</blockquote>
<h2 id="ES新特性"><a href="#ES新特性" class="headerlink" title="ES新特性"></a>ES新特性</h2><h3 id="let、const和var的区别"><a href="#let、const和var的区别" class="headerlink" title="let、const和var的区别"></a>let、const和var的区别</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let const 形成一个块级作用域,不会有变量声明的提升</span></span><br><span class="line"><span class="comment">// let用来声明变量</span></span><br><span class="line"><span class="comment">// for (var i = 0; i &lt; 3; i++) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(i);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// console.log(i);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(i);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const声明常量,一旦声明之后不能在更改</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数组的解构"><a href="#数组的解构" class="headerlink" title="数组的解构"></a>数组的解构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的解构</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> [, str1,str] = arr</span><br><span class="line"><span class="built_in">console</span>.log(str1, str); <span class="comment">// two three</span></span><br></pre></td></tr></table></figure>

<h3 id="对象的解构"><a href="#对象的解构" class="headerlink" title="对象的解构"></a>对象的解构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象的解构</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// :后设置别名，防止命名冲突</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: namea &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(namea);</span><br></pre></td></tr></table></figure>

<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="comment">// const str = `123`</span></span><br><span class="line"><span class="comment">// 带标签的模板字符串，可以用来处理字符串中的插值数据</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> gender = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> tag = <span class="function">(<span class="params">s, name, gender</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s, name, gender);</span><br><span class="line">  <span class="keyword">const</span> sex = gender ? <span class="string">&#x27;man&#x27;</span> : <span class="string">&#x27;women&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> s[<span class="number">0</span>] + name + s[<span class="number">1</span>] + sex</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> str1 = tag<span class="string">`hi, my name is <span class="subst">$&#123;name&#125;</span>, I am a <span class="subst">$&#123;gender&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">// hi, my name is tom, I am a man</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b </span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> result = arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> v % <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 不会改变this指向</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;my name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayHi1: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;my name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.sayHi() <span class="comment">// my name is zs</span></span><br><span class="line"><span class="comment">// this作用于当前作用域，上下文</span></span><br><span class="line">obj.sayHi1() <span class="comment">// my name is undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象字面量</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;zd&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="string">&#x27;18&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  <span class="comment">// fn: function () &#123;&#125;</span></span><br><span class="line">  fn () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123; name: &#x27;zd&#x27;, age: &#x27;18&#x27;, fn: [Function: fn] &#125;</span></span><br><span class="line">obj1.fn() <span class="comment">// &#123; name: &#x27;zd&#x27;, age: &#x27;18&#x27;, fn: [Function: fn] &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// proxy</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxyObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  get (target, property) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target, property);</span><br><span class="line">    <span class="comment">// return 100</span></span><br><span class="line">    <span class="keyword">return</span> property <span class="keyword">in</span> target ? target[property] : <span class="string">&#x27;none&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, property, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    target[property] = value</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteProperty (target, property) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target, property);</span><br><span class="line">    <span class="keyword">delete</span> target[property]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// proxyObj.age = &#x27;19&#x27; // Error</span></span><br><span class="line">proxyObj.age = <span class="number">19</span> <span class="comment">// &#123; name: &#x27;zs&#x27;, age: 19 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyObj.name); <span class="comment">// zs</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyObj.name1); <span class="comment">// none</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy和defineProperty对比</span></span><br><span class="line"><span class="keyword">delete</span> proxyObj.name</span><br><span class="line"><span class="built_in">console</span>.log(proxyObj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(p1, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;age访问了&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> p1._age</span><br><span class="line">  &#125;,</span><br><span class="line">  set (val) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;age设置了&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(p1, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;name访问了&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> p1._name</span><br><span class="line">  &#125;,</span><br><span class="line">  set (val) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;name设置了&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p1.age = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.age);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Proxy数据劫持的方式比Object.defineProperty更加方便，新增了很多Object.defineProperty不具备的方法。</p>
</blockquote>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reflect </span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxyObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  get (target, property) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target, property);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(proxyObj.name);</span><br><span class="line"><span class="comment">// 统一操作对象的api</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="built_in">Reflect</span>.has(obj, <span class="string">&#x27;name&#x27;</span>),</span><br><span class="line">  <span class="built_in">Reflect</span>.ownKeys(obj),</span><br><span class="line">  <span class="built_in">Reflect</span>.deleteProperty(obj, <span class="string">&#x27;age&#x27;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class</span></span><br><span class="line"><span class="comment">// function Person (name) &#123;</span></span><br><span class="line"><span class="comment">//   this.name = name</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// Person.prototype.say = function () &#123;</span></span><br><span class="line"><span class="comment">//   console.log(`$&#123;this.name&#125;`);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">p.say()</span><br></pre></td></tr></table></figure>

<h4 id="static静态修饰词"><a href="#static静态修饰词" class="headerlink" title="static静态修饰词"></a>static静态修饰词</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态方法修饰词static</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> create (val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.create(<span class="string">&#x27;zs&#x27;</span>).say()</span><br></pre></td></tr></table></figure>

<h4 id="继承extends"><a href="#继承extends" class="headerlink" title="继承extends"></a>继承extends</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// extends继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>, i am <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, age, num</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用父级的属性</span></span><br><span class="line">    <span class="built_in">super</span>(name, age)</span><br><span class="line">    <span class="built_in">this</span>.num = num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hello () &#123;</span><br><span class="line">    <span class="comment">// 调用父级的方法</span></span><br><span class="line">    <span class="built_in">super</span>.say()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my num is <span class="subst">$&#123;<span class="built_in">this</span>.num&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;jack&#x27;</span>, <span class="number">12</span>, <span class="number">123</span>)</span><br><span class="line">s.hello()</span><br><span class="line"><span class="comment">// my name is jack, i am 12 years old</span></span><br><span class="line"><span class="comment">// my num is 123</span></span><br></pre></td></tr></table></figure>

<h3 id="set数据结构"><a href="#set数据结构" class="headerlink" title="set数据结构"></a>set数据结构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set数据结构</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="comment">// add:往set中添加元素</span></span><br><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// Set &#123; 1, 2, 3 &#125;</span></span><br><span class="line"><span class="comment">// for of遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// size：长度</span></span><br><span class="line"><span class="built_in">console</span>.log(s.size);</span><br><span class="line"><span class="comment">// has:判断是否有某个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(s.has(<span class="number">100</span>));</span><br><span class="line"><span class="comment">// delete:删除某个元素,删除成功返回true，反之返回false</span></span><br><span class="line"><span class="built_in">console</span>.log(s.delete(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// clear:清空set</span></span><br><span class="line">s.clear()</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// Set &#123;&#125;</span></span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// Set &#123; 1, 2, 3, 5 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log([...arr]); <span class="comment">// [ 1, 2, 3, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(arr));<span class="comment">// [ 1, 2, 3, 5 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="map数据结构"><a href="#map数据结构" class="headerlink" title="map数据结构"></a>map数据结构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map数据结构</span></span><br><span class="line"><span class="comment">// 可以使用任意类型的值作为健</span></span><br><span class="line"><span class="comment">// 普通对象结构</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj[<span class="number">123</span>] = <span class="number">123</span></span><br><span class="line">obj[<span class="literal">true</span>] = <span class="number">345</span></span><br><span class="line">obj[&#123;<span class="attr">a</span>: <span class="number">123</span>&#125;] = <span class="number">456</span></span><br><span class="line"><span class="comment">// 会自动将值toString之后作为健</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; &#x27;123&#x27;: 123, true: 345, &#x27;[object Object]&#x27;: 456 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[&#123;&#125;]); <span class="comment">// 456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map </span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>&#125;</span><br><span class="line">m.set(a, <span class="number">10</span>)</span><br><span class="line">m.set(<span class="literal">true</span>, <span class="number">101</span>)</span><br><span class="line">m.set(<span class="number">123</span>, <span class="number">16</span>)</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">m.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value, key);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 10 &#123; name: &#x27;tom&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 101 true</span></span><br><span class="line"><span class="comment">// 16 123</span></span><br><span class="line"><span class="built_in">console</span>.log(m); <span class="comment">// Map &#123; &#123; name: &#x27;tom&#x27; &#125; =&gt; 10 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(m.get(a)); <span class="comment">// 10</span></span><br><span class="line">m.delete(a)</span><br><span class="line"><span class="built_in">console</span>.log(m); <span class="comment">// Map &#123; true =&gt; 101, 123 =&gt; 16 &#125;</span></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">m.clear()</span><br><span class="line"><span class="built_in">console</span>.log(m); <span class="comment">// Map &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-数据类型"><a href="#Symbol-数据类型" class="headerlink" title="Symbol 数据类型"></a>Symbol 数据类型</h3><blockquote>
<p>Symbol 数据类型</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 独一无二的存在</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 可以给Symbol设置一个别称用于区分</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">  <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">  <span class="built_in">Symbol</span>(<span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">);</span><br><span class="line"><span class="comment">// Symbol(a) Symbol(b) Symbol(c)</span></span><br><span class="line"><span class="comment">// 为对象设置一个独一无二的属性</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [name]: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;<span class="built_in">this</span>[name]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol.for方法,参数会调用toString方法转成字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>) === <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj)); <span class="comment">// [ Symbol() ]</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&#x27;xObj&#x27;</span> <span class="comment">// [object xObj]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.toString()); <span class="comment">// [object Object]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="for…of遍历"><a href="#for…of遍历" class="headerlink" title="for…of遍历"></a>for…of遍历</h3><blockquote>
<p>for of 遍历所有数据结构的一种方式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的遍历,可以随时使用break停止遍历</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (item &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// set遍历</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map遍历</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;zs&#x27;</span>)</span><br><span class="line">m.set(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> m) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通对象不可遍历,obj is not iterable报错</span></span><br><span class="line"><span class="comment">// const obj = &#123; a: 1, b: 2&#125;</span></span><br><span class="line"><span class="comment">// for (const v of obj) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(v);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Iterable可迭代接口"><a href="#Iterable可迭代接口" class="headerlink" title="Iterable可迭代接口"></a>Iterable可迭代接口</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Iterable 可迭代接口</span></span><br><span class="line"><span class="comment">// 实现Iterable接口是for...of...的前提</span></span><br><span class="line"><span class="comment">// iterator迭代器</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: &#x27;one&#x27;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: &#x27;two&#x27;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Iterable 可迭代接口</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  store: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">  <span class="comment">// 返回一个迭代器方法</span></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 返回一个实现迭代器对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 提供一个next方法</span></span><br><span class="line">      next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 返回迭代结果</span></span><br><span class="line">        <span class="keyword">const</span> result = &#123;</span><br><span class="line">          value: self.store[index], <span class="comment">// 存储结果</span></span><br><span class="line">          done: index &gt;= self.store.length <span class="comment">// 表示迭代状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        index++</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"><span class="keyword">const</span> res = arr.find(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 设置断言的两种方式</span></span><br><span class="line"><span class="keyword">const</span> num  = res <span class="keyword">as</span> number</span><br><span class="line"><span class="keyword">const</span> num1 = &lt;number&gt;res</span><br><span class="line"><span class="comment">// const num1 = res * res</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认从0开始累加</span></span><br><span class="line">enum Status &#123;</span><br><span class="line">  Empty, </span><br><span class="line">  One,</span><br><span class="line">  Two</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置初始值之后后面的值累加</span></span><br><span class="line"><span class="comment">// enum Status &#123;</span></span><br><span class="line"><span class="comment">//   Empty = 6, </span></span><br><span class="line"><span class="comment">//   One,</span></span><br><span class="line"><span class="comment">//   Two</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 设置字符串之后，后面的值都要设置为字符串</span></span><br><span class="line"><span class="comment">// enum Status &#123;</span></span><br><span class="line"><span class="comment">//   Empty = &#x27;abc&#x27;, </span></span><br><span class="line"><span class="comment">//   One = &#x27;bcd&#x27;,</span></span><br><span class="line"><span class="comment">//   Two = &#x27;edg&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: Status.Empty <span class="comment">// 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 明确元素数量，以及每一个元素类型的一个数组</span></span><br><span class="line"><span class="keyword">const</span> tuple: [number, string] = [<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> [age, name] = tuple</span><br><span class="line"><span class="built_in">Object</span>.entries(&#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用的两种方式</span></span><br><span class="line"><span class="keyword">const</span> arr1: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> arr2: number[] = [<span class="number">222</span>, <span class="number">333</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span> (<span class="params">...args: number[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">a, c</span>) =&gt;</span> a + c, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">getSum(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo: object = [] <span class="comment">// &#123;&#125; function</span></span><br><span class="line"><span class="keyword">const</span> obj1: &#123; <span class="attr">foo</span>: number &#125; = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="interface接口"><a href="#interface接口" class="headerlink" title="interface接口"></a>interface接口</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line">interface Post &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">  title?: string <span class="comment">// 可有可无</span></span><br><span class="line">  readonly nickname?: string <span class="comment">// 只读属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span> (<span class="params">obj: Post</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.name);</span><br><span class="line">  <span class="built_in">console</span>.log(obj.age);</span><br><span class="line">&#125;</span><br><span class="line">say(&#123;</span><br><span class="line">  name: <span class="string">&#x27;sz&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">interface cash &#123;</span><br><span class="line">  <span class="comment">// key可以是任意字符串，是用来约束健值的，声明其类型</span></span><br><span class="line">  [key: string]: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cash: cash = &#123;&#125;</span><br><span class="line">cash.a = <span class="string">&#x27;12&#x27;</span></span><br><span class="line">cash.b = <span class="string">&#x27;12&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="class类-1"><a href="#class类-1" class="headerlink" title="class类"></a>class类</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  public name: string <span class="comment">// 公众属性</span></span><br><span class="line">  private age: number <span class="comment">// 私有属性</span></span><br><span class="line">  protected readonly gender: boolean <span class="comment">// 只读</span></span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name: string, age: number</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.gender = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi (msg: string) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am a <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>, <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name: string, age: number</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name);</span><br><span class="line"><span class="comment">// console.log(p1.age); // 报错</span></span><br><span class="line"><span class="comment">// console.log(p1.gender); // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line">interface Eat &#123;</span><br><span class="line">  eat (food: string): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line">interface Run &#123;</span><br><span class="line">  run (food: string): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">Eat</span>, <span class="title">Run</span> </span>&#123;</span><br><span class="line">  eat (food: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(food);</span><br><span class="line">  &#125;</span><br><span class="line">  run (distance: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(distance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">Eat</span>, <span class="title">Run</span> </span>&#123;</span><br><span class="line">  eat (food: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(food);</span><br><span class="line">  &#125;</span><br><span class="line">  run (distance: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(distance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  eat (food: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(food);</span><br><span class="line">  &#125;</span><br><span class="line">  abstract run (distance: string): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog1</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  run(distance: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(distance);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明的函数民航后面&lt;T&gt;,不确定类型：T</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ceateArr</span>&lt;<span class="title">T</span>&gt; (<span class="params">length: number, value: T</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="built_in">Array</span>&lt;T&gt;(length).fill(value)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ceateArr(<span class="number">3</span>, <span class="number">100</span>)</span><br><span class="line">ceateArr(<span class="number">3</span>, <span class="string">&#x27;100&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cetAA = &lt;T&gt;(length: number, <span class="attr">value</span>: T): T[] =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="built_in">Array</span>&lt;T&gt;(length).fill(value)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">cetAA(<span class="number">12</span>, <span class="number">12</span>)</span><br><span class="line">cetAA(<span class="number">12</span>, <span class="string">&#x27;12&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="js性能优化"><a href="#js性能优化" class="headerlink" title="js性能优化"></a>js性能优化</h2><h3 id="V8引擎常用的GC回收算法"><a href="#V8引擎常用的GC回收算法" class="headerlink" title="V8引擎常用的GC回收算法"></a>V8引擎常用的GC回收算法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 性能优化</span></span><br><span class="line"><span class="comment">// gc回收机制</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.引用计数方法</span></span><br><span class="line"><span class="comment"> * 核心思想：设置引用数，判断当前引用计数是否为0</span></span><br><span class="line"><span class="comment"> * 引用计数器，引用关系改变时修改引用数值，引用计数为0时，回收</span></span><br><span class="line"><span class="comment"> * 优点：发现垃圾时立即回收，最大程度减少程序暂停</span></span><br><span class="line"><span class="comment"> * 缺点：无法回收循环引用的对象，时间开销大</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2.标记清除算法</span></span><br><span class="line"><span class="comment"> * 核心思想：分标记和清除两个阶段完成</span></span><br><span class="line"><span class="comment"> * 遍历所有对象找标记活动对象</span></span><br><span class="line"><span class="comment"> * 遍历所有对象清除没有标记对象</span></span><br><span class="line"><span class="comment"> * 回收相应空间</span></span><br><span class="line"><span class="comment"> * 优点：解决了无法回收循环引用的对象的问题</span></span><br><span class="line"><span class="comment"> * 缺点：造成了空间碎片化，不会立即回收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2.标记整理算法</span></span><br><span class="line"><span class="comment"> * 核心思想：分标记和清除两个阶段完成</span></span><br><span class="line"><span class="comment"> * 遍历所有对象找标记活动对象</span></span><br><span class="line"><span class="comment"> * 遍历所有对象清除没有标记对象</span></span><br><span class="line"><span class="comment"> * 回收之前先进行整理，调整位置</span></span><br><span class="line"><span class="comment"> * 回收相应空间</span></span><br><span class="line"><span class="comment"> * 优点：解决了无法回收循环引用的对象的问题</span></span><br><span class="line"><span class="comment"> * 缺点：减少了空间碎片化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * V8垃圾回收策略：</span></span><br><span class="line"><span class="comment"> * 1. 采用分代回收思想</span></span><br><span class="line"><span class="comment"> * 2. 内存分为新生代和老生代</span></span><br><span class="line"><span class="comment"> * 3. 针对不同对象采用不同算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常用的回收算法：</span></span><br><span class="line"><span class="comment"> * 1. 分代回收</span></span><br><span class="line"><span class="comment"> * 2. 空间复制</span></span><br><span class="line"><span class="comment"> * 3. 标记清除</span></span><br><span class="line"><span class="comment"> * 4. 标记整理</span></span><br><span class="line"><span class="comment"> * 5. 标记增量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * V8内存分配：</span></span><br><span class="line"><span class="comment"> * 1. 内存一分为二</span></span><br><span class="line"><span class="comment"> * 2. 小空间用来存储新生代对象，即存活时间较短的对象（64位系统32M ｜ 32位系统16M）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 新生代对象回收机制：</span></span><br><span class="line"><span class="comment"> * 1. 采用复制算法+标记整理</span></span><br><span class="line"><span class="comment"> * 2. 新生代内存分为两个同等大小空间</span></span><br><span class="line"><span class="comment"> * 3. 使用空间From，用于存储活动对象，空闲空间To</span></span><br><span class="line"><span class="comment"> * 4. 标记整理之后，将活动对象拷贝至空闲空间To</span></span><br><span class="line"><span class="comment"> * 5. From与To交换空间达到内存释放</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 细节说明：</span></span><br><span class="line"><span class="comment"> * 1. 拷贝过程可能出现晋升（将新生代对象移动到老生代）</span></span><br><span class="line"><span class="comment"> * 2. 一轮过后依然存活的新生代对象</span></span><br><span class="line"><span class="comment"> * 3. To空间使用达到25%，触发晋升</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老生代回收：</span></span><br><span class="line"><span class="comment"> * 64位系统1.4G，32位系统700M</span></span><br><span class="line"><span class="comment"> * 老生代对象就是存活时间较长的对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 回收机制：</span></span><br><span class="line"><span class="comment"> * 1. 标记清除，标记整理，增量标记，这些算法实现</span></span><br><span class="line"><span class="comment"> * 2. 先试用标记清除，回收垃圾释放空间</span></span><br><span class="line"><span class="comment"> * 3. 使用标记整理优化内存空间</span></span><br><span class="line"><span class="comment"> * 4. 使用增量标记进行效率优化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ES新特性与TypeScript、JS性能优化</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue数据管理Vuex</title>
    <url>/2021/04/25/Vue%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86Vuex/</url>
    <content><![CDATA[<h2 id="组件内的状态管理流程"><a href="#组件内的状态管理流程" class="headerlink" title="组件内的状态管理流程"></a><strong>组件内的状态管理流程</strong></h2><p>**Vue 最核心的两个功能:数据驱动和组件化。 **</p>
<p><strong>组件化开发给我们带来了:</strong></p>
<ul>
<li>更快的开发效率</li>
<li>更好的可维护性</li>
</ul>
<p><strong>每个组件都有自己的状态、视图和行为等组成部分</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// state</span></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">&#125; &#125;,</span><br><span class="line"><span class="comment">// view</span></span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="comment">// actions</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment () &#123;</span><br><span class="line">      <span class="built_in">this</span>.count++</span><br><span class="line">&#125; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>状态管理包含以下几部分:</strong></p>
<ul>
<li><strong>state</strong>，驱动应用的数据源;</li>
<li><strong>view</strong>，以声明方式将 <strong>state</strong> 映射到视图;</li>
<li><strong>actions</strong>，响应在 <strong>view</strong> 上的用户输入导致的状态变化。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210424115319304.35zi4au5i480.png"
                      alt="image-20210424115319304"
                ></p>
<h2 id="组件间通信方式回顾"><a href="#组件间通信方式回顾" class="headerlink" title="组件间通信方式回顾"></a>组件间通信方式回顾</h2><p><strong>大多数场景下的组件都并不是独立存在的，而是相互协作共同构成了一个复杂的业务功能。在 Vue 中为不同的组件关系提供了不同的通信规则。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/Snipaste_2021-04-24_11-58-08.6gle7qmmg600.png"
                     
                ></p>
<p><strong><a class="link"   href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE" >父传子:Props Down<i class="fas fa-external-link-alt"></i></a></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;blog-post title&#x3D;&quot;My journey with Vue&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line">Vue.component(&#39;blog-post&#39;, &#123;</span><br><span class="line">  props: [&#39;title&#39;],</span><br><span class="line">  template: &#39;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;h3&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><a href="https://cn.vuejs.org/v2/guide/components.html#%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6"><strong>子传父:Event Up</strong></a></p>
<p>在子组件中使用<code>$emit</code>发布一个自定义事件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button v-on:click=<span class="string">&quot;$emit(&#x27;enlargeText&#x27;, 0.1)&quot;</span>&gt;</span><br><span class="line">  Enlarge text</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p><strong>在使用这个组件的时候，使用 v-on 监听这个自定义事件</strong> </p>
<p><strong>使用事件抛出一个值</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-on:enlargeText</span>=<span class="string">&quot;hFontSize += $event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://cn.vuejs.org/v2/guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2"><strong>非父子组件:Event Bus</strong></a></p>
<p>我们可以使用一个非常简单的 Event Bus 来解决这个问题:</p>
<p><strong>eventbus.js :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Vue()</span><br></pre></td></tr></table></figure>

<p>然后在需要通信的两端: </p>
<p>使用 <code>$on</code> 订阅:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 没有参数 </span><br><span class="line">bus.$on(&#39;自定义事件名称&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">	&#x2F;&#x2F; 执行操作 </span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 有参数</span><br><span class="line">bus.$on(&#39;自定义事件名称&#39;, data &#x3D;&gt; &#123;</span><br><span class="line">	&#x2F;&#x2F; 执行操作 </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用<code>$emit</code>发布:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 没有自定义传参 </span><br><span class="line">bus.$emit(&#39;自定义事件名称&#39;);</span><br><span class="line">&#x2F;&#x2F; 有自定义传参 </span><br><span class="line">bus.$emit(&#39;自定义事件名称&#39;, 数据);</span><br></pre></td></tr></table></figure>

<p><strong>父直接访问子组件:通过</strong> <strong>ref</strong> <strong>获取子组件</strong></p>
<p><strong>ref</strong> 有两个作用:</p>
<ul>
<li>如果你把它作用到普通 HTML 标签上，则获取到的是 DOM </li>
<li>如果你把它作用到组件标签上，则获取到的是组件实例</li>
</ul>
<p><strong>创建 base-input 组件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input ref&#x3D;&quot;input&quot;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">&#x2F;&#x2F; 用来从父级组件聚焦输入框 focus: function () &#123;</span><br><span class="line">        this.$refs.input.focus()</span><br><span class="line">      &#125;</span><br><span class="line">&#125; &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>在使用子组件的时候，添加 ref 属性:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;base-input ref&#x3D;&quot;usernameInput&quot;&gt;&lt;&#x2F;base-input&gt;</span><br></pre></td></tr></table></figure>

<p>然后在父组件等渲染完毕后使用 <code>$refs </code>访问:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">  this.$refs.usernameInput.focus()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组 件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs 。</p>
</blockquote>
<h2 id="简易的状态管理方案"><a href="#简易的状态管理方案" class="headerlink" title="简易的状态管理方案"></a><a href="https://cn.vuejs.org/v2/guide/state-management.html"><strong>简易的状态管理方案</strong></a></h2><p><strong>如果多个组件之间要共享状态(数据)，使用上面的方式虽然可以实现，但是比较麻烦，而且多个组件之 间互相传值很难跟踪数据的变化，如果出现问题很难定位问题。</strong></p>
<p><strong>当遇到多个组件需要共享状态的时候，典型的场景:购物车。我们如果使用上述的方案都不合适，我们会遇到以下的问题</strong></p>
<ul>
<li>多个视图依赖于同一状态。</li>
<li>来自不同视图的行为需要变更同一状态。</li>
</ul>
<p><strong>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。</strong><br><strong>对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</strong></p>
<p><strong>因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢?在这种模式下，我们的 组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为!</strong></p>
<p><strong>我们可以把多个组件的状态，或者整个程序的状态放到一个集中的位置存储，并且可以检测到数据的更 改。你可能已经想到了 Vuex。</strong></p>
<p><strong>这里我们先以一种简单的方式来实现</strong> </p>
<ul>
<li><strong>首先创建一个共享的仓库 store 对象</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  debug: <span class="literal">true</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">    name: <span class="string">&#x27;xiaomao&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    sex: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125;,</span><br><span class="line">  setUserNameAction (name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.debug) &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&#x27;setUserNameAction triggered:&#x27;</span>, name) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.state.user.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>把共享的仓库 store 对象，存储到需要共享状态的组件的 data 中</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">  	<span class="comment">// 点击按钮的时候通过 action 修改状态 </span></span><br><span class="line">    change () &#123;</span><br><span class="line">      store.setUserNameAction(<span class="string">&#x27;componentB&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      privateState: &#123;&#125;,</span><br><span class="line">      sharedState: store.state</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接着我们继续延伸约定，组件不允许直接变更属于 store 对象的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，这样最终的样子跟 Vuex 的结构就类似了。这样约定的好处是，我 们能够记录所有 store 中发生的 state 变更，同时实现能做到记录变更、保存状态快照、历史回滚/时光 旅行的先进的调试工具。</strong></p>
<h2 id="什么是-Vuex"><a href="#什么是-Vuex" class="headerlink" title="什么是 Vuex"></a><strong>什么是</strong> <strong>Vuex</strong></h2><blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件 的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调 试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调 试功能。</p>
</blockquote>
<ul>
<li>Vuex 是专门为 Vue.js 设计的状态管理库 </li>
<li>它采用集中式的方式存储需要共享的数据 </li>
<li>从使用角度，它就是一个 JavaScript 库 </li>
<li>它的作用是进行状态管理，解决复杂组件通信，数据共享</li>
</ul>
<h2 id="什么情况下使用-Vuex"><a href="#什么情况下使用-Vuex" class="headerlink" title="什么情况下使用 Vuex"></a><strong>什么情况下使用</strong> <strong>Vuex</strong></h2><blockquote>
<p>官方文档:</p>
<p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p>
<p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用 够简单，您最好不要使用 Vuex。一个简单的 store 模式就足够您所需了。但是，如果您需要构建 一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然 的选择。引用 Redux 的作者 Dan Abramov 的话说就是:Flux 架构就像眼镜:您自会知道什么时 候需要它。</p>
</blockquote>
<p>当你的应用中具有以下需求场景的时候:</p>
<ul>
<li>多个视图依赖于同一状态</li>
<li>来自不同视图的行为需要变更同一状态</li>
</ul>
<p>建议符合这种场景的业务使用 Vuex 来进行数据管理，例如非常典型的场景:购物车。 </p>
<p><strong>注意:Vuex不要滥用，不符合以上需求的业务不要使用，反而会让你的应用变得更麻烦。</strong></p>
<h2 id="核心概念回顾"><a href="#核心概念回顾" class="headerlink" title="核心概念回顾"></a><strong>核心概念回顾</strong></h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/111.2gobfdq678nw.png"
                     
                ></p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a><strong>基本结构</strong></h3><ul>
<li>导入 Vuex</li>
<li>注册 Vuex</li>
<li>注入 $store 到 Vue 实例</li>
</ul>
<h4 id="State"><a href="#State" class="headerlink" title="State"></a><strong>State</strong></h4><p>Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。 </p>
<p>使用 mapState 简化 State 在视图中的使用，mapState 返回计算属性 </p>
<p>mapState 有两种使用的方式:</p>
<ul>
<li>接收数组参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 该方法是 vuex 提供的，所以使用前要先导入 </span><br><span class="line">import &#123; mapState &#125; from &#39;vuex&#39;</span><br><span class="line">&#x2F;&#x2F; mapState 返回名称为 count 和 msg 的计算属性 </span><br><span class="line">&#x2F;&#x2F; 在模板中直接使用 count 和 msg</span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState([&#39;count&#39;, &#39;msg&#39;]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接收对象参数</li>
</ul>
<p> 如果当前视图中已经有了 count 和 msg，如果使用上述方式的话会有命名冲突，解决的方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 该方法是 vuex 提供的，所以使用前要先导入 </span><br><span class="line">import &#123; mapState &#125; from &#39;vuex&#39;</span><br><span class="line">&#x2F;&#x2F; 通过传入对象，可以重命名返回的计算属性</span><br><span class="line">&#x2F;&#x2F; 在模板中直接使用 num 和 message </span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    num: state &#x3D;&gt; state.count,</span><br><span class="line">    message: state &#x3D;&gt; state.msg</span><br><span class="line">	&#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a><strong>Getter</strong></h4><p>Getter 就是 store 中的计算属性，使用 mapGetter 简化视图中的使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetter &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">computed: &#123; </span><br><span class="line">  ...mapGetter([<span class="string">&#x27;reverseMsg&#x27;</span>]), </span><br><span class="line">  <span class="comment">// 改名，在模板中使用 reverse </span></span><br><span class="line">  ..mapGetter(&#123;</span><br><span class="line">    reverse: <span class="string">&#x27;reverseMsg&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a><strong>Mutation</strong></h4><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件:每 个 mutation 都有一个字符串的 <strong>事件类型</strong> <strong>(type)</strong> 和 一个 <strong>回调函数</strong> **(handler)**。这个回调函数就是我们 实际进行状态更改的地方，并且它会接受 state 作为第一个参数。</p>
<p>使用 Mutation 改变状态的好处是，集中的一个位置对状态修改，不管在什么地方修改，都可以追踪到 状态的修改。可以实现高级的 time-travel 调试功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">methods: &#123; </span><br><span class="line">  ...mapMutations([<span class="string">&#x27;increate&#x27;</span>]), </span><br><span class="line">  <span class="comment">// 传对象解决重名的问题 </span></span><br><span class="line">  ...mapMutations(&#123;</span><br><span class="line">    increateMut: <span class="string">&#x27;increate&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a><strong>Action</strong></h4><p>Action 类似于 mutation，不同在于:</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">methods: &#123; </span><br><span class="line">  ...mapActions([<span class="string">&#x27;increate&#x27;</span>]), </span><br><span class="line">  <span class="comment">// 传对象解决重名的问题 </span></span><br><span class="line">  ...mapActions(&#123;</span><br><span class="line">    increateAction: <span class="string">&#x27;increate&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a><strong>Module</strong></h4><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对 象就有可能变得相当臃肿。</p>
<p>为了解决以上问题，Vuex 允许我们将 store 分割成**模块(<strong><strong>module</strong></strong>)**。每个模块拥有自己的 state、 mutation、action、getter、甚至是嵌套子模块。</p>
<p>在案例中体会 Module 的使用。</p>
<h2 id="模拟实现Vuex"><a href="#模拟实现Vuex" class="headerlink" title="模拟实现Vuex"></a>模拟实现Vuex</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a><strong>实现思路</strong></h3><ul>
<li>实现 install 方法<ul>
<li>Vuex 是 Vue 的一个插件，所以和模拟 VueRouter 类似，先实现 Vue 插件约定的 install 方法</li>
</ul>
</li>
<li>实现 Store 类<ul>
<li>实现构造函数，接收 options</li>
<li>state 的响应化处理</li>
<li>getter 的实现 </li>
<li>commit、dispatch 方法</li>
</ul>
</li>
</ul>
<h4 id="install-方法"><a href="#install-方法" class="headerlink" title="install 方法"></a><strong>install</strong> <strong>方法</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  _Vue = Vue</span><br><span class="line">  _Vue.mixin(&#123;</span><br><span class="line">    beforeCreate () &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.$options.store) &#123;</span><br><span class="line">        Vue.prototype.$store = <span class="built_in">this</span>.$options.store</span><br><span class="line">      &#125;</span><br><span class="line">		&#125; </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Store-类"><a href="#Store-类" class="headerlink" title="Store 类"></a><strong>Store</strong> <strong>类</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      state = &#123;&#125;,</span><br><span class="line">      getters = &#123;&#125;,</span><br><span class="line">      mutations = &#123;&#125;,</span><br><span class="line">      actions = &#123;&#125;</span><br><span class="line">    &#125; = options</span><br><span class="line">    <span class="built_in">this</span>.state = _Vue.observable(state)</span><br><span class="line">    <span class="comment">// 此处不直接 this.getters = getters，是因为下面的代码中要方法 getters 中的 key</span></span><br><span class="line">    <span class="comment">// 如果这么写的话，会导致 this.getters 和 getters 指向同一个对象</span></span><br><span class="line">    <span class="comment">// 当访问 getters 的 key 的时候，实际上就是访问 this.getters 的 key 会触发 key 属性 的 getter</span></span><br><span class="line">    <span class="comment">// 会产生死递归</span></span><br><span class="line">    <span class="built_in">this</span>.getters = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">Object</span>.keys(getters).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>.getters, key, &#123;</span><br><span class="line">        get: <span class="function">() =&gt;</span> getters[key](<span class="built_in">this</span>.state)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.mutations = mutations</span><br><span class="line">    <span class="built_in">this</span>.actions = actions</span><br><span class="line">  &#125;</span><br><span class="line">  commit (type, payload) &#123;</span><br><span class="line">    <span class="built_in">this</span>.mutations[type](<span class="built_in">this</span>.state, payload)</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch (type, payload) &#123;</span><br><span class="line">    <span class="built_in">this</span>.actions[type](<span class="built_in">this</span>, payload)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出模块 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vuex</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码剖析(三) — Vue模板编译</title>
    <url>/2021/04/23/Vue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a><strong>模板编译</strong></h2><ul>
<li>模板编译的主要目的是将模板 (template) 转换为渲染函数 (render)</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> @<span class="attr">click</span>=<span class="string">&quot;handler&quot;</span>&gt;</span>title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>some content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>渲染函数 render</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render (h) &#123;</span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">    h(<span class="string">&#x27;h1&#x27;</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: <span class="built_in">this</span>.handler&#125; &#125;, <span class="string">&#x27;title&#x27;</span>),</span><br><span class="line">    h(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;some content&#x27;</span>)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>模板编译的作用<ul>
<li>Vue 2.x 使用 VNode 描述视图以及各种交互，用户自己编写 VNode 比较复杂 </li>
<li>用户只需要编写类似 HTML 的代码 - Vue 模板，通过编译器将模板转换为返回 VNode 的 render 函数</li>
<li>vue 文件会被 webpack 在构建的过程中转换成 render 函数</li>
</ul>
</li>
</ul>
<h2 id="体验模板编译的结果"><a href="#体验模板编译的结果" class="headerlink" title="体验模板编译的结果"></a><strong>体验模板编译的结果</strong></h2><ul>
<li>带编译器版本的 Vue.js 中，使用 template 或 el 的方式设置模板</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Vue<span class="tag">&lt;<span class="name">span</span>&gt;</span>模板编译过程<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> @<span class="attr">myclick</span>=<span class="string">&quot;handler&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;comp&#x27;</span>, &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &#x27;<span class="tag">&lt;<span class="name">div</span>&gt;</span>I am a comp<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#x27;</span></span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&#x27;Hello compiler&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handler () &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;test&#x27;</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line"> 		&#125; </span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(vm.$options.render)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>编译后 render 输出的结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _c(</span><br><span class="line">      <span class="string">&quot;div&quot;</span>,</span><br><span class="line">      &#123; <span class="attr">attrs</span>: &#123; <span class="attr">id</span>: <span class="string">&quot;app&quot;</span> &#125; &#125;,</span><br><span class="line">      [</span><br><span class="line">        _m(<span class="number">0</span>),</span><br><span class="line">        _v(<span class="string">&quot; &quot;</span>),</span><br><span class="line">        _c(<span class="string">&quot;p&quot;</span>, [_v(_s(msg))]),</span><br><span class="line">        _v(<span class="string">&quot; &quot;</span>),</span><br><span class="line">        _c(<span class="string">&quot;comp&quot;</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">myclick</span>: handler &#125; &#125;),</span><br><span class="line">			],</span><br><span class="line">			<span class="number">1</span></span><br><span class="line">		); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>_c 是 createElement() 方法，定义的位置 instance/render.js 中</li>
<li>相关的渲染函数(_开头的方法定义)，在 instance/render-helps/index.js 中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// instance/render-helps/index.js</span></span><br><span class="line">target._v = createTextVNode</span><br><span class="line">target._m = renderStatic</span><br><span class="line"><span class="comment">// core/vdom/vnode.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createTextVNode</span> (<span class="params">val: string | number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VNode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="built_in">String</span>(val))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 instance/render-helps/render-static.js </span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderStatic</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  index: number,</span></span></span><br><span class="line"><span class="function"><span class="params">  isInFor: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cached = <span class="built_in">this</span>._staticTrees || (<span class="built_in">this</span>._staticTrees = [])</span><br><span class="line">  <span class="keyword">let</span> tree = cached[index]</span><br><span class="line">  <span class="comment">// if has already-rendered static tree and not inside v-for,</span></span><br><span class="line">  <span class="comment">// we can reuse the same tree.</span></span><br><span class="line">  <span class="keyword">if</span> (tree &amp;&amp; !isInFor) &#123;</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// otherwise, render a fresh tree.</span></span><br><span class="line">  tree = cached[index] = <span class="built_in">this</span>.$options.staticRenderFns[index].call(</span><br><span class="line">    <span class="built_in">this</span>._renderProxy,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="built_in">this</span> <span class="comment">// for render fns generated for functional component templates</span></span><br><span class="line">  )</span><br><span class="line">  markStatic(tree, <span class="string">`__static__<span class="subst">$&#123;index&#125;</span>`</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>把 template 转换成 render 的入口 src\platforms\web\entry-runtime-with-compiler.js</li>
</ul>
<h2 id="Vue-Template-Explorer"><a href="#Vue-Template-Explorer" class="headerlink" title="Vue Template Explorer"></a><strong>Vue Template Explorer</strong></h2><ul>
<li><a class="link"   href="https://template-explorer.vuejs.org/#%3Cdiv%20id%3D%22app%22%3E%0A%20%20%3Cselect%3E%0A%20%20%20%20%3Coption%3E%0A%20%20%20%20%20%20%7B%7B%20msg%20%20%7D%7D%0A%20%20%20%20%3C%2Foption%3E%0A%20%20%3C%2Fselect%3E%0A%20%20%3Cdiv%3E%0A%20%20%20%20hello%0A%20%20%3C%2Fdiv%3E%0A%3C%2Fdiv%3E" >vue-template-explorer<i class="fas fa-external-link-alt"></i></a><ul>
<li>Vue 2.6 把模板编译成 render 函数的工具 </li>
</ul>
</li>
<li><a class="link"   href="https://vue-next-template-explorer.netlify.app/#%7B%22src%22%3A%22%3Cdiv%20id%3D%5C%22app%5C%22%3E%5Cn%20%20%3Cselect%3E%5Cn%20%20%20%20%3Coption%3E%5Cn%20%20%20%20%20%20%7B%7B%20msg%20%20%7D%7D%5Cn%20%20%20%20%3C%2Foption%3E%5Cn%20%20%3C%2Fselect%3E%5Cn%20%20%3Cdiv%3E%5Cn%20%20%20%20hello%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%22%2C%22options%22%3A%7B%22mode%22%3A%22module%22%2C%22prefixIdentifiers%22%3Afalse%2C%22optimizeBindings%22%3Afalse%2C%22hoistStatic%22%3Afalse%2C%22cacheHandlers%22%3Afalse%2C%22scopeId%22%3Anull%7D%7D" >vue-next-template-explorer<i class="fas fa-external-link-alt"></i></a><ul>
<li>Vue 3.0 beta 把模板编译成 render 函数的工具</li>
</ul>
</li>
</ul>
<h2 id="模板编译过程"><a href="#模板编译过程" class="headerlink" title="模板编译过程"></a><strong>模板编译过程</strong></h2><ul>
<li>解析、优化、生成</li>
</ul>
<h2 id="编译的入口"><a href="#编译的入口" class="headerlink" title="编译的入口"></a><strong>编译的入口</strong></h2><ul>
<li>src\platforms\web\entry-runtime-with-compiler.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  ......</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// 把 template 转换成 render 函数</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    outputSourceRange: process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    shouldDecodeNewlines,</span></span></span><br><span class="line"><span class="function"><span class="params">    shouldDecodeNewlinesForHref,</span></span></span><br><span class="line"><span class="function"><span class="params">    delimiters: options.delimiters,</span></span></span><br><span class="line"><span class="function"><span class="params">    comments: options.comments</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, <span class="built_in">this</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  options.render = render</span></span></span><br><span class="line"><span class="function"><span class="params">  options.staticRenderFns = staticRenderFns</span></span></span><br><span class="line"><span class="function"><span class="params">  ......</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调试 compileToFunctions() 执行过程，生成渲染函数的过程<ul>
<li>compileToFunctions: src\compiler\to-function.js </li>
<li>complie(template, options):src\compiler\create-compiler.js </li>
<li>baseCompile(template.trim(), finalOptions):src\compiler\index.js</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423154646912.hia83vr83zs.png"
                      alt="image-20210423154646912"
                ></p>
<h2 id="解析-parse"><a href="#解析-parse" class="headerlink" title="解析 - parse"></a><strong>解析</strong> - parse</h2><ul>
<li>解析器将模板解析为抽象语树 AST，只有将模板解析成 AST 后，才能基于它做优化或者生成代码字符串。<ul>
<li>src\compiler\index.js</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ast = parse(template.trim(), options)</span><br><span class="line"><span class="comment">//src\compiler\parser\index.js</span></span><br><span class="line">parse()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查看得到的 AST tree </p>
<ul>
<li>astexplorer </li>
</ul>
</li>
<li><p>结构化指令的处理</p>
<ul>
<li>v-if 最终生成单元表达式</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src\compiler\parser\index.js // structural directives</span></span><br><span class="line"><span class="comment">// 结构化的指令</span></span><br><span class="line"><span class="comment">// v-for</span></span><br><span class="line">processFor(element)</span><br><span class="line">processIf(element)</span><br><span class="line">processOnce(element)</span><br><span class="line"><span class="comment">// src\compiler\codegen\index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">genIf</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  state: CodegenState,</span></span></span><br><span class="line"><span class="function"><span class="params">  altGen?: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  altEmpty?: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  el.ifProcessed = <span class="literal">true</span> <span class="comment">// avoid recursion</span></span><br><span class="line">  <span class="keyword">return</span> genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终调用 genIfConditions 生成三元表达式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>v-if 最终编译的结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ƒ <span class="function"><span class="title">anonymous</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">with</span>(<span class="params"><span class="built_in">this</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _c(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;app&quot;</span>&#125;&#125;,[</span><br><span class="line">      _m(<span class="number">0</span>),</span><br><span class="line">      _v(<span class="string">&quot; &quot;</span>),</span><br><span class="line">      (msg)?_c(<span class="string">&#x27;p&#x27;</span>,[_v(_s(msg))]):_e(),_v(<span class="string">&quot; &quot;</span>),</span><br><span class="line">      _c(<span class="string">&#x27;comp&#x27;</span>,&#123;<span class="attr">on</span>:&#123;<span class="string">&quot;myclick&quot;</span>:onMyClick&#125;&#125;)</span><br><span class="line">],<span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>v-if/v-for 结构化指令只能在编译阶段处理，如果我们要在 render 函数处理条件或循环只能使用 js 中的 if 和 for</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;comp&#x27;</span>, &#123;</span><br><span class="line">  data: () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">&#x27;my comp&#x27;</span></span><br><span class="line">&#125; &#125;,</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.msg) &#123;</span><br><span class="line">      <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">this</span>.msg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="优化-optimize"><a href="#优化-optimize" class="headerlink" title="优化 - optimize"></a><strong>优化</strong> <strong>- optimize</strong></h2><ul>
<li><p>优化抽象语法树，检测子节点中是否是纯静态节点</p>
</li>
<li><p>一旦检测到纯静态节点，例如:</p>
</li>
</ul>
<p><strong>hello整体是静态节点</strong></p>
<ul>
<li>永远不会更改的节点<ul>
<li>提升为常量，重新渲染的时候不在重新创建节点 </li>
<li>在 patch 的时候直接跳过静态子树</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src\compiler\index.js</span></span><br><span class="line"><span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">  optimize(ast, options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src\compiler\optimizer.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Goal of the optimizer: walk the generated template AST tree</span></span><br><span class="line"><span class="comment"> * and detect sub-trees that are purely static, i.e. parts of</span></span><br><span class="line"><span class="comment"> * the DOM that never needs to change.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Once we detect these sub-trees, we can:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. Hoist them into constants, so that we no longer need to</span></span><br><span class="line"><span class="comment"> *    create fresh nodes for them on each re-render;</span></span><br><span class="line"><span class="comment"> * 2. Completely skip them in the patching process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">optimize</span> (<span class="params">root: ?ASTElement, options: CompilerOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">  isStaticKey = genStaticKeysCached(options.staticKeys || <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  isPlatformReservedTag = options.isReservedTag || no</span><br><span class="line">  <span class="comment">// first pass: mark all non-static nodes. // 标记非静态节点</span></span><br><span class="line">  markStatic(root)</span><br><span class="line">  <span class="comment">// second pass: mark static roots.</span></span><br><span class="line">  <span class="comment">// 标记静态根节点</span></span><br><span class="line">  markStaticRoots(root, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="生成-generate"><a href="#生成-generate" class="headerlink" title="生成 - generate"></a><strong>生成</strong> <strong>- generate</strong></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src\compiler\index.js</span></span><br><span class="line"><span class="keyword">const</span> code = generate(ast, options)</span><br><span class="line"><span class="comment">// src\compiler\codegen\index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">generate</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  ast: ASTElement | <span class="keyword">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CodegenResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="keyword">new</span> CodegenState(options)</span><br><span class="line">  <span class="keyword">const</span> code = ast ? genElement(ast, state) : <span class="string">&#x27;_c(&quot;div&quot;)&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render: <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>,</span><br><span class="line">    staticRenderFns: state.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把字符串转换成函数</span></span><br><span class="line"><span class="comment">// src\compiler\to-function.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunction</span> (<span class="params">code, errors</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(code)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    errors.push(&#123; err, code &#125;)</span><br><span class="line">    <span class="keyword">return</span> noop</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组件化机制"><a href="#组件化机制" class="headerlink" title="组件化机制"></a><strong>组件化机制</strong></h2><ul>
<li><p>组件化可以让我们方便的把页面拆分成多个可重用的组件 </p>
</li>
<li><p>组件是独立的，系统内可重用，组件之间可以嵌套</p>
</li>
<li><p>有了组件可以像搭积木一样开发网页 </p>
</li>
<li><p>下面我们将从源码的角度来分析 Vue 组件内部如何工作</p>
<ul>
<li><p>组件实例的创建过程是从上而下</p>
</li>
<li><p>组件实例的挂载过程是从下而上</p>
</li>
</ul>
</li>
</ul>
<h2 id="组件声明"><a href="#组件声明" class="headerlink" title="组件声明"></a><strong>组件声明</strong></h2><ul>
<li>复习全局组件的定义方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;comp&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;h1&gt;hello&lt;/h1&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>Vue.component() 入口<ul>
<li> 创建组件的构造函数，挂载到 Vue 实例的 vm.options.component.componentName = Ctor</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src\core\global-api\index.js</span></span><br><span class="line"><span class="comment">// 注册 Vue.directive()、 Vue.component()、Vue.filter() </span></span><br><span class="line">initAssetRegisters(Vue)</span><br><span class="line"><span class="comment">// src\core\global-api\assets.js</span></span><br><span class="line"><span class="keyword">if</span> (type === <span class="string">&#x27;component&#x27;</span> &amp;&amp; isPlainObject(definition)) &#123;</span><br><span class="line">  definition.name = definition.name || id</span><br><span class="line">  definition = <span class="built_in">this</span>.options._base.extend(definition)</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 全局注册，存储资源并赋值</span></span><br><span class="line"><span class="comment">// this.options[&#x27;components&#x27;][&#x27;comp&#x27;] = Ctor </span></span><br><span class="line"><span class="built_in">this</span>.options[type + <span class="string">&#x27;s&#x27;</span>][id] = definition</span><br><span class="line"><span class="comment">// src\core\global-api\index.js</span></span><br><span class="line"><span class="comment">// this is used to identify the &quot;base&quot; constructor to extend all plain-object</span></span><br><span class="line"><span class="comment">// components with in Weex&#x27;s multi-instance scenarios.</span></span><br><span class="line">Vue.options._base = Vue</span><br><span class="line"><span class="comment">// src\core\global-api\extend.js</span></span><br><span class="line">Vue.extend()</span><br></pre></td></tr></table></figure>

<ul>
<li>组件构造函数的创建</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</span><br><span class="line">Sub.prototype.constructor = Sub</span><br><span class="line">Sub.cid = cid++</span><br><span class="line">Sub.options = mergeOptions(</span><br><span class="line">  Super.options,</span><br><span class="line">  extendOptions</span><br><span class="line">)</span><br><span class="line">Sub[<span class="string">&#x27;super&#x27;</span>] = Super</span><br><span class="line"><span class="comment">// For props and computed properties, we define the proxy getters on</span></span><br><span class="line"><span class="comment">// the Vue instances at extension time, on the extended prototype. This</span></span><br><span class="line"><span class="comment">// avoids Object.defineProperty calls for each instance created.</span></span><br><span class="line"><span class="keyword">if</span> (Sub.options.props) &#123;</span><br><span class="line">	initProps(Sub)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Sub.options.computed) &#123;</span><br><span class="line">  initComputed(Sub)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// allow further extension/mixin/plugin usage</span></span><br><span class="line">Sub.extend = Super.extend</span><br><span class="line">Sub.mixin = Super.mixin</span><br><span class="line">Sub.use = Super.use</span><br><span class="line"><span class="comment">// create asset registers, so extended classes</span></span><br><span class="line"><span class="comment">// can have their private assets too.</span></span><br><span class="line">ASSET_TYPES.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  Sub[type] = Super[type]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// enable recursive self-lookup</span></span><br><span class="line"><span class="keyword">if</span> (name) &#123;</span><br><span class="line">  Sub.options.components[name] = Sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue源码剖析</category>
      </categories>
      <tags>
        <tag>Vue Render</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router的实现原理</title>
    <url>/2021/04/23/vue-router%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="路由规则中的props属性，可以设置动态路由的入参"><a href="#路由规则中的props属性，可以设置动态路由的入参" class="headerlink" title="路由规则中的props属性，可以设置动态路由的入参"></a>路由规则中的props属性，可以设置动态路由的入参</h3><p><strong>路由规则中设置如下：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  ...</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/c/:id&#x27;</span>,</span><br><span class="line">    <span class="comment">// 动态路由通过设置props属性，可以在子组件中通过props属性获取</span></span><br><span class="line">    props: <span class="literal">true</span>,</span><br><span class="line">    name: <span class="string">&#x27;IndexC&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../pages/c.vue&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<p><strong>子组件中获取动态路由的id：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;wrapper&quot;&gt;c&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  &#x2F;&#x2F; 获取动态路由的id</span><br><span class="line">  props: [&#39;id&#39;],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  watch: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>推荐使用此方法传递动态路由的id，可以避免去依赖$route。</p>
</blockquote>
<h3 id="嵌套路由的使用"><a href="#嵌套路由的使用" class="headerlink" title="嵌套路由的使用"></a>嵌套路由的使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">&#x27;../pages/a.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Index&#x27;</span>,</span><br><span class="line">    component: Index,</span><br><span class="line">    <span class="comment">// children属性设置嵌套路由</span></span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;IndexB&#x27;</span>,</span><br><span class="line">        component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../pages/b.vue&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&#x27;c/:id&#x27;</span>,</span><br><span class="line">        <span class="comment">// 动态路由通过设置props属性，可以在子组件中通过props属性获取</span></span><br><span class="line">        props: <span class="literal">true</span>,</span><br><span class="line">        name: <span class="string">&#x27;IndexC&#x27;</span>,</span><br><span class="line">        component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../pages/c.vue&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"><span class="built_in">this</span>.$router.replace(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"><span class="built_in">this</span>.$router.go(-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">this</span>.$router.back()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="hash模式和history模式的区别"><a href="#hash模式和history模式的区别" class="headerlink" title="hash模式和history模式的区别"></a>hash模式和history模式的区别</h3><ul>
<li>hash模式是基于锚点，以及onhashchange事件 </li>
<li>history模式是基于HTML5中的History API<ul>
<li>history.pushState() IE 10 以后的才支持</li>
<li>history.replaceState()</li>
</ul>
</li>
<li>history模式的使用：<ul>
<li>需要服务端配置，否则刷新时出现404</li>
</ul>
</li>
</ul>
<h2 id="Vue-Router-模拟实现"><a href="#Vue-Router-模拟实现" class="headerlink" title="Vue Router 模拟实现"></a><strong>Vue Router</strong> <strong>模拟实现</strong></h2><p><strong>实现思路</strong></p>
<ul>
<li><p>创建 VueRouter 插件，静态方法 install</p>
<ul>
<li>判断插件是否已经被加载</li>
<li>当 Vue 加载的时候把传入的 router 对象挂载到 Vue 实例上（注意：只执行一次）</li>
</ul>
</li>
<li><p>创建 VueRouter 类</p>
<ul>
<li>初始化，options、routeMap、app(简化操作，创建 Vue 实例作为响应式数据记录当前路径)</li>
<li>initRouteMap() 遍历所有路由信息，把组件和路由的映射记录到 routeMap 对象中</li>
<li>注册 popstate 事件，当路由地址发生变化，重新记录当前的路径</li>
<li>创建 router-link 和 router-view 组件</li>
<li>当路径改变的时候通过当前路径在 routerMap 对象中找到对应的组件，渲染 router-view</li>
</ul>
</li>
</ul>
<h3 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue = <span class="literal">null</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">install</span>(<span class="params">Vue</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//1 判断当前插件是否被安装</span></span><br><span class="line">    <span class="keyword">if</span> (VueRouter.install.installed) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    VueRouter.install.installed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//2 把Vue的构造函数记录在全局</span></span><br><span class="line">    _Vue = Vue;</span><br><span class="line">    <span class="comment">//3 把创建Vue的实例传入的router对象注入到Vue实例</span></span><br><span class="line">    <span class="comment">// _Vue.prototype.$router = this.$options.router</span></span><br><span class="line">    _Vue.mixin(&#123;</span><br><span class="line">      <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$options.router) &#123;</span><br><span class="line">          _Vue.prototype.$router = <span class="built_in">this</span>.$options.router;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.options = options;</span><br><span class="line">    <span class="built_in">this</span>.routeMap = &#123;&#125;;</span><br><span class="line">    <span class="comment">// observable</span></span><br><span class="line">    <span class="built_in">this</span>.data = _Vue.observable(&#123;</span><br><span class="line">      current: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.createRouteMap();</span><br><span class="line">    <span class="built_in">this</span>.initComponent(_Vue);</span><br><span class="line">    <span class="built_in">this</span>.initEvent();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">createRouteMap</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//遍历所有的路由规则 吧路由规则解析成键值对的形式存储到routeMap中</span></span><br><span class="line">    <span class="built_in">this</span>.options.routes.forEach(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.routeMap[route.path] = route.component;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">initComponent</span>(<span class="params">Vue</span>)</span> &#123;</span><br><span class="line">    Vue.component(<span class="string">&quot;router-link&quot;</span>, &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        to: <span class="built_in">String</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">render</span>(<span class="params">h</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h(</span><br><span class="line">          <span class="string">&quot;a&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            attrs: &#123;</span><br><span class="line">              href: <span class="built_in">this</span>.to,</span><br><span class="line">            &#125;,</span><br><span class="line">            on: &#123;</span><br><span class="line">              click: <span class="built_in">this</span>.clickhander,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          [<span class="built_in">this</span>.$slots.default]</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">clickhander</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">          history.pushState(&#123;&#125;, <span class="string">&quot;&quot;</span>, <span class="built_in">this</span>.to);</span><br><span class="line">          <span class="built_in">this</span>.$router.data.current = <span class="built_in">this</span>.to;</span><br><span class="line">          e.preventDefault();</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// template:&quot;&lt;a :href=&#x27;to&#x27;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;&gt;&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    Vue.component(<span class="string">&quot;router-view&quot;</span>, &#123;</span><br><span class="line">      <span class="function"><span class="title">render</span>(<span class="params">h</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// self.data.current</span></span><br><span class="line">        <span class="keyword">const</span> cm = self.routeMap[self.data.current];</span><br><span class="line">        <span class="keyword">return</span> h(cm);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">initEvent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&quot;popstate&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.data.current = <span class="built_in">window</span>.location.pathname;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.dir(Vue)</span><br><span class="line"><span class="keyword">let</span> _Vue = <span class="literal">null</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实现 vue 的插件机制</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">install</span>(<span class="params">Vue</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//1 判断当前插件是否被安装</span></span><br><span class="line">    <span class="keyword">if</span> (VueRouter.install.installed) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    VueRouter.install.installed = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//2 把Vue的构造函数记录在全局</span></span><br><span class="line">    _Vue = Vue</span><br><span class="line">    <span class="comment">//3 把创建Vue的实例传入的router对象注入到Vue实例</span></span><br><span class="line">    <span class="comment">// _Vue.prototype.$router = this.$options.router</span></span><br><span class="line">    <span class="comment">// 混入</span></span><br><span class="line">    _Vue.mixin(&#123;</span><br><span class="line">      <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$options.router) &#123;</span><br><span class="line">          _Vue.prototype.$router = <span class="built_in">this</span>.$options.router</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化属性</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.options = options <span class="comment">// options 记录构造函数传入的对象</span></span><br><span class="line">    <span class="built_in">this</span>.routeMap = &#123;&#125; <span class="comment">// routeMap 路由地址和组件的对应关系</span></span><br><span class="line">    <span class="comment">// observable     data 是一个响应式对象</span></span><br><span class="line">    <span class="built_in">this</span>.data = _Vue.observable(&#123;</span><br><span class="line">      current: <span class="string">&quot;/&quot;</span> <span class="comment">// 当前路由地址</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.init()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 createRouteMap, initComponent, initEvent 三个方法</span></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.createRouteMap()</span><br><span class="line">    <span class="built_in">this</span>.initComponent(_Vue)</span><br><span class="line">    <span class="built_in">this</span>.initEvent()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来初始化 routeMap 属性，路由规则转换为键值对</span></span><br><span class="line">  <span class="function"><span class="title">createRouteMap</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//遍历所有的路由规则 把路由规则解析成键值对的形式存储到routeMap中</span></span><br><span class="line">    <span class="built_in">this</span>.options.routes.forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.routeMap[route.path] = route.component</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来创建 router-link 和 router-view 组件</span></span><br><span class="line">  <span class="function"><span class="title">initComponent</span>(<span class="params">Vue</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// router-link 组件</span></span><br><span class="line">    Vue.component(<span class="string">&#x27;router-link&#x27;</span>, &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        to: <span class="built_in">String</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// render --- 可在 vue 运行时版直接使用</span></span><br><span class="line">      <span class="function"><span class="title">render</span>(<span class="params">h</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// h(选择器（标签的名字）， 属性，生成的某个标签的内容)</span></span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">          attrs: &#123;</span><br><span class="line">            href: <span class="string">&#x27;#&#x27;</span> + <span class="built_in">this</span>.to,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 注册事件</span></span><br><span class="line">        <span class="comment">//   on: &#123;</span></span><br><span class="line">        <span class="comment">//     click: this.clickHandler // 点击事件</span></span><br><span class="line">        <span class="comment">//   &#125;,</span></span><br><span class="line">        &#125;, [<span class="built_in">this</span>.$slots.default]) <span class="comment">// this.$slot.default 默认插槽</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// router-view 组件</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>; <span class="comment">//这里的 this 指向 vueRouter 实例</span></span><br><span class="line">    Vue.component(<span class="string">&#x27;router-view&#x27;</span>, &#123;</span><br><span class="line">      <span class="function"><span class="title">render</span>(<span class="params">h</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 routerMap 中的对应关系，拿到当前路由地址所对应的组件</span></span><br><span class="line">        <span class="keyword">const</span> component = self.routeMap[self.data.current]</span><br><span class="line">        <span class="keyword">return</span> h(component)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来注册 hashchange 事件</span></span><br><span class="line">  initEvent () &#123;</span><br><span class="line">     <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.data.current = <span class="built_in">this</span>.getHash();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">window</span>.location.hash) &#123;</span><br><span class="line">        <span class="built_in">window</span>.location.hash = <span class="string">&#x27;#/&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getHash</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue源码剖析</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手教你搭建一个属于自己的Blog</title>
    <url>/2021/04/23/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Blog/</url>
    <content><![CDATA[<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p><a href="http://www.iwkxk.com/">wkxk的blog</a>，欢迎大家留言互动~</p>
<p>本文介绍采用Hexo+keep+Github Actions这一套技术实现blog搭建及自动化部署。</p>
<h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><ol>
<li><p>安装node，下载地址：<a href="nodejs.cn">nodejs</a></p>
</li>
<li><p>安装hexo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></li>
<li><p>初始化博客目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init wkxk.github.io (这里的wkxk换成你自己的英文名)</span><br></pre></td></tr></table></figure></li>
<li><p>初始化完成后，我们就进入我们的目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd wkxk.github.io</span><br></pre></td></tr></table></figure></li>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
<li><p>clean一下，然后生成静态页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<blockquote>
<p>g 就是<code>generate</code> ,生成的意思</p>
</blockquote>
</li>
<li><p>把你的网站运行起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<blockquote>
<p>s 就是<code>server</code> ,在服务器运行的意思</p>
</blockquote>
</li>
<li><p>打开你的浏览器，输入 <code>localhost:4000</code> 。 自此，你的个人网站就这么速度的搭建起来了！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423170735002.5jzsvwi0lqs0.png"
                      alt="image-20210423170735002"
                ></p>
</li>
</ol>
<h2 id="装饰下你的个人网站"><a href="#装饰下你的个人网站" class="headerlink" title="装饰下你的个人网站"></a>装饰下你的个人网站</h2><h3 id="修改你的网站中的个人信息"><a href="#修改你的网站中的个人信息" class="headerlink" title="修改你的网站中的个人信息"></a>修改你的网站中的个人信息</h3><p>进入你的网站目录，打开 <code>_config.yml</code> 文件，这个文件是用来配置你的网站信息的。</p>
<p>这里列出我的简单配置，具体可以看这个<a class="link"   href="https://hexo.io/docs/configuration.html" >文档<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">wkxk&#x27;s</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">wkxk的个人博客</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">wkxk的个人博客，主要涉及到编程(JavaScript,Vue2,Vue3,Webpack,node),助于个人学习提升，分享学习过程</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">JavaScript,Vue2,Vue3,Vite,Webpack,node</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">wkxk</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h3 id="选一个主题"><a href="#选一个主题" class="headerlink" title="选一个主题"></a>选一个主题</h3><p>刚搭建完的网站，是不是觉得有点丑，不符合你的漂亮的脸庞？ 反正我是这么觉得的，那么就选一个主题来装饰一下吧，在这里可以选择你要的主题：<a class="link"   href="https://hexo.io/themes/" >hexo主题<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p>选择好了你的主题之后，就可以下载主题资源了，比如我这里选择一个<code>keep </code>主题来演示一下：</p>
<p><code>keep </code>主题github地址：<a class="link"   href="https://github.com/XPoet/hexo-theme-keep" >https://github.com/XPoet/hexo-theme-keep<i class="fas fa-external-link-alt"></i></a></p>
<p><code>keep </code>主题官方文档：<a class="link"   href="https://keep-docs.xpoet.cn/" >https://keep-docs.xpoet.cn/<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里使用npm方式安装方便后期进行代码托管维护</span></span><br><span class="line">npm install hexo-theme-keep</span><br></pre></td></tr></table></figure>

<h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><ul>
<li>主题下载完之后，在你根目录下的 _config.yml 文件中，修改 theme 为你的主题名字：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: keep</span><br></pre></td></tr></table></figure>

<ul>
<li>如果想要自定义<code>hexo-theme-keep</code>主题，可以参考<a class="link"   href="https://keep-docs.xpoet.cn/usage-tutorial/advanced.html#%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7" >keep主题平滑升级<i class="fas fa-external-link-alt"></i></a>。<ul>
<li>在博客根目录下的 <code>source</code>目录中新建文件夹<code>_data</code></li>
<li>将<code>node_modules</code>下的<code>hexo-theme-keep</code>目录中复制出<code>_config.yml</code>文件到<code>source/_data/</code>中，并重命名为<code>keep.yml</code>。</li>
<li>在<code>keep.yml</code>可根据文档配置对应的属性。</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210427190504118.6g2ajj29bm00.png"
                      alt="image-20210427190504118"
                ></p>
<h3 id="重新生成和运行"><a href="#重新生成和运行" class="headerlink" title="重新生成和运行"></a>重新生成和运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>我们可能经常会运行这三个命令，我们可以在<code>package.json</code>中设置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>我们可以直接使用如下命令一次性的运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn dev</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h3 id="keep主题"><a href="#keep主题" class="headerlink" title="keep主题"></a>keep主题</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210425120015256.1al5ipo8yq4g.png"
                      alt="image-20210425102523668"
                ></p>
<h3 id="博客文章"><a href="#博客文章" class="headerlink" title="博客文章"></a>博客文章</h3><p><strong>两种方式来新建你的博文</strong></p>
<h4 id="命令形式"><a href="#命令形式" class="headerlink" title="命令形式"></a>命令形式</h4><p>在你的blog目录下使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new hello （这里的article写上你的文章的名称）</span><br></pre></td></tr></table></figure>

<p>你的source/_posts下就会生成一个 <code>hello.md</code>文件，在这个文件下就可以写上你的博客内容了。用 Markdown 的语法去写。</p>
<h4 id="直接新建方式"><a href="#直接新建方式" class="headerlink" title="直接新建方式"></a>直接新建方式</h4><p>直接点的方式就是直接在<code>source/_posts</code>新建一个 Markdown 文件。</p>
<h3 id="打上标签"><a href="#打上标签" class="headerlink" title="打上标签"></a>打上标签</h3><p>打标签能让你的文章方便检索。</p>
<p>打开标签功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>这时候你的source/下生成 tags/index.md 文件，我们将其打开，然后把它改成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">comments: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>这时候你要为你的文章打上标签就可以在文章的头部写上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Vue源码剖析(二) — Vue虚拟DOM</span><br><span class="line">date: 2021-04-23 15:36:27</span><br><span class="line">tags: Vue Virtual DOM</span><br><span class="line">tags: &lt;&lt;其他你想打的标签&gt;&gt;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="添加分类"><a href="#添加分类" class="headerlink" title="添加分类"></a>添加分类</h3><p>分类，归档，是你博客的特性之一。</p>
<p>打开分类功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>这说你的source目录下生成 categories/index.md 文件，我们将其打开，把它改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>

<p>这时候你就可以给你的文章归类存档了，使用方式就是在你的文章的头部加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Vue源码剖析(二) — Vue虚拟DOM</span><br><span class="line">date: 2021-04-23 15:36:27</span><br><span class="line">tags: Vue Virtual DOM</span><br><span class="line">categories: Vue源码剖析</span><br><span class="line">categories: &lt;&lt;其他你想分的类&gt;&gt;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：标签和分类要确定你的配置文件 _config.yml 是否有打开了 tag_dir: tags 和 category_dir: categories。另外，Markdown 的语法是写作最优雅最简洁最简单的，如果之前没用过的建议去学一下<a class="link"   href="https://www.appinn.com/markdown/" >Markdown 语法说明<i class="fas fa-external-link-alt"></i></a>，一般一个钟左右就能掌握。因为它和HTML那样简单。</p>
</blockquote>
<h3 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h3><p>keep主题提供评论系统，详情见<a class="link"   href="https://keep-docs.xpoet.cn/usage-tutorial/configuration-guide.html#comment" >https://keep-docs.xpoet.cn/usage-tutorial/configuration-guide.html#comment<i class="fas fa-external-link-alt"></i></a></p>
<p>根据自己的喜好选择一个评论系统，作者使用的gitalk，效果图如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210425103835850.5g185keg3ws0.png"
                      alt="image-20210425103835850"
                ></p>
<h3 id="部署到线上"><a href="#部署到线上" class="headerlink" title="部署到线上"></a>部署到线上</h3><p>可以通过<code>GitHub Pages</code>来创建免费的线上访问地址。</p>
<h4 id="创建Github-pages-仓库"><a href="#创建Github-pages-仓库" class="headerlink" title="创建Github pages 仓库"></a>创建Github pages 仓库</h4><p>创建一个<code>xxx.github.io</code>的 public 仓库，这里的xxx写你的名字，比如我写的是 <a class="link"   href="https://github.com/wkxk/wkxk.github.io" >wkxk.github.io<i class="fas fa-external-link-alt"></i></a>,那么到时我就可以通过 <code>wkxk.github.io</code> 来访问我的网站了。 创建完成之后，那么你就有自己的 Git 地址了。</p>
<h4 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 hexo-deployer-git</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> wkxk.github.io</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h4 id="配置你的Git"><a href="#配置你的Git" class="headerlink" title="配置你的Git"></a>配置你的Git</h4><p>打开你的配置文件<code>_config.yml</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.github.io.git &#x2F;&#x2F; 输入你的git地址</span><br></pre></td></tr></table></figure>

<h4 id="推送你的网站到Github上"><a href="#推送你的网站到Github上" class="headerlink" title="推送你的网站到Github上"></a>推送你的网站到Github上</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<blockquote>
<p>d 就是 deploy ， 部署上去的意思。</p>
</blockquote>
<h4 id="访问你的网站"><a href="#访问你的网站" class="headerlink" title="访问你的网站"></a>访问你的网站</h4><p>直接在浏览器输入你的 <code>xxx.github.io</code> 就可以访问了。</p>
<h3 id="绑定自己的域名"><a href="#绑定自己的域名" class="headerlink" title="绑定自己的域名"></a>绑定自己的域名</h3><h4 id="添加-CNAME-文件"><a href="#添加-CNAME-文件" class="headerlink" title="添加 CNAME 文件"></a>添加 CNAME 文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入sources</span></span><br><span class="line"><span class="built_in">cd</span> sources</span><br><span class="line"><span class="comment"># 创建CNAME文件，写入自己的域名，如：www.iwkxk.com</span></span><br><span class="line">touch CNAME</span><br></pre></td></tr></table></figure>

<h4 id="在你的域名商后台进行-DNS-解析添加两条记录："><a href="#在你的域名商后台进行-DNS-解析添加两条记录：" class="headerlink" title="在你的域名商后台进行 DNS 解析添加两条记录："></a>在你的域名商后台进行 DNS 解析添加两条记录：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 主机记录： @</span><br><span class="line">    记录类型：A</span><br><span class="line">    记录值：192.30.252.154 或者 192.30.252.153</span><br><span class="line"></span><br><span class="line">2. 主机记录： www</span><br><span class="line">    记录类型： CNAME</span><br><span class="line">    记录值： xxx.github.io  (这里就是你的github仓库名称)</span><br></pre></td></tr></table></figure>

<h4 id="GitHub-设置域名"><a href="#GitHub-设置域名" class="headerlink" title="GitHub 设置域名"></a>GitHub 设置域名</h4><p>在你的 GitHub 设置域名，在你的 GitHub 博客项目中点击 Settings，在 GitHub Pages 下的 Custom domain 写上你的域名，然后 save。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210425112628662.1ktpciahsocg.png"
                      alt="image-20210425112628662"
                ></p>
<h3 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h3><p>根据之前的步骤我们使用 Hexo + <a class="link"   href="https://github.com/XPoet/hexo-theme-keep" >Keep<i class="fas fa-external-link-alt"></i></a> 主题搭建了一个在线博客，下面教你如何使用 GitHub Actions 将博客自动部署到 GitHub Pages。</p>
<h4 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h4><p>我这里买的<a class="link"   href="https://bandwagonhost.com/index.php" >搬瓦工<i class="fas fa-external-link-alt"></i></a>服务器，大家可以根据自己的需求选择阿里云，百度云的都是可以的。</p>
<h4 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h4><h5 id="创建-GitHub-仓库"><a href="#创建-GitHub-仓库" class="headerlink" title="创建 GitHub 仓库"></a>创建 GitHub 仓库</h5><ul>
<li><p>创建一个<strong>私有仓库</strong>用来存储 Hexo 项目源代码。（保证你的重要信息不泄露）</p>
<blockquote>
<p>text仓库的master分支用来存放源代码</p>
</blockquote>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210425113102571.3lnwd3cpilu0.png"
                      alt="image-20210425113102571"
                ></p>
<ul>
<li><p><strong>公共仓库</strong>用来存储编译之后的静态页面。（这里就不用在创建仓库了，之前我们部署过github pages到xxx.github.io）</p>
<blockquote>
<p>xxx.github.io这个仓库的master分支用来存储静态文件</p>
</blockquote>
</li>
</ul>
<p>当私有仓库的 <code>master</code> 有内容 <code>push</code> 进来时（例如：主题文件，文章 md 文件、图片等）， 会触发 GitHub Actions 自动编译并部署到公共仓库的 <code>master</code>分支。</p>
<h5 id="创建-GitHub-Token"><a href="#创建-GitHub-Token" class="headerlink" title="创建 GitHub Token"></a>创建 GitHub Token</h5><ul>
<li>创建一个有 <strong>repo</strong> 和 <strong>workflow</strong> 权限的 <a class="link"   href="https://github.com/settings/tokens/new" >GitHub Token<i class="fas fa-external-link-alt"></i></a> 。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210425113739235.2kj5gkcd2ve0.png"
                      alt="image-20210425113739235"
                ></p>
<ul>
<li>新生成的 Token 只会显示一次，如有遗失，重新生成即可。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210425113910416.2roc86ouptm0.png"
                      alt="image-20210425113910416"
                ></p>
<h5 id="创建-repository-secret"><a href="#创建-repository-secret" class="headerlink" title="创建 repository secret"></a>创建 repository secret</h5><ul>
<li><p>将上面生成的 Token 添加到私有仓库的 <code>Secrets</code> 里，并将这个新增的 <code>secret</code> 命名为 <code>HEXO_DEPLOY</code> （名字无所谓，看你喜欢）。</p>
</li>
<li><p>步骤：私有仓库 -&gt; <code>settings</code> -&gt; <code>Secrets</code> -&gt; <code>New repository secret</code>。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210425114136730.6uteocvt0s00.png"
                      alt="image-20210425114136730"
                ></p>
<blockquote>
<p>新创建的 secret <code>HEXO_DEPLOY</code> 在 Actions 配置文件要用到，需跟配置文件保持一致！</p>
</blockquote>
<h5 id="添加-Actions-配置文件"><a href="#添加-Actions-配置文件" class="headerlink" title="添加 Actions 配置文件"></a>添加 Actions 配置文件</h5><ol>
<li>在你的 Hexo 项目根目录下创建 <code>.github</code> 文件夹。</li>
<li>在 <code>.github</code> 文件夹下创建 <code>workflows</code> 文件夹。</li>
<li>在 <code>workflows</code> 文件夹下创建 <code>hexo-deploy.yml</code> 文件。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210425114312617.67zx7jzvucw0.png"
                      alt="image-20210425114312617"
                ></p>
<p><code>hexo-deploy.yml</code> 文件配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">deploying</span> <span class="string">Hexo</span> <span class="string">project</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">pages</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span> <span class="comment"># master 分支有 push 行为时就触发这个 action</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@master</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">theme-keep/hexo-deploy-github-pages-action@master</span> <span class="comment"># 使用专门部署 Hexo 到 GitHub pages 的 action</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">PERSONAL_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_DEPLOY</span> <span class="string">&#125;&#125;</span> <span class="comment"># secret 名</span></span><br><span class="line">          <span class="attr">PUBLISH_REPOSITORY:</span> <span class="string">wkxk/wkxk.github.io</span> <span class="comment"># 公共仓库，格式：GitHub 用户名/仓库名</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">master</span> <span class="comment"># 分支，我这里是推送到wkxk/wkxk.github.io仓库里的master分支(根据自己的仓库进行填写)</span></span><br><span class="line">          <span class="attr">PUBLISH_DIR:</span> <span class="string">./public</span> <span class="comment"># 部署 public 目录下的文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面的配置文件中，使用了 <a class="link"   href="https://github.com/theme-keep" >theme-keep<i class="fas fa-external-link-alt"></i></a> 组织封装的 <strong><a class="link"   href="https://github.com/theme-keep/hexo-deploy-github-pages-action" >hexo-deploy-github-pages-action<i class="fas fa-external-link-alt"></i></a></strong> ，是一款专门部署 Hexo 博客到 GitHub pages 的 action，欢迎大家 <a class="link"   href="https://github.com/theme-keep/hexo-deploy-github-pages-action" >Star<i class="fas fa-external-link-alt"></i></a> 和 <a class="link"   href="https://github.com/theme-keep/hexo-deploy-github-pages-action" >Fork<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h5 id="自动部署触发流程"><a href="#自动部署触发流程" class="headerlink" title="自动部署触发流程"></a>自动部署触发流程</h5><ul>
<li><p>修改你的 Hexo 博客源代码（例如：增加文章、修改文章、更改主题、修改主题配置文件等等）。</p>
</li>
<li><p>把你修改过的 Hexo 项目内容（只提交修改过的那部分内容） <code>push</code> 到 GitHub 公共仓库（本例：test）的 <code>master</code> 分支。</p>
</li>
<li><p>GitHub Actions 检测到 <code>master</code> 分支有内容 <code>push</code> 进来，会自动执行 action 配置文件的命令，将 Hexo 项目编译成静态页面，然后部署到私有仓库的 <code>master</code> 分支。</p>
</li>
<li><p>在私有仓库的 Actions 可以查看到你配置的 action。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210425114717303.1tq3tbx8ms8w.png"
                      alt="image-20210425114717303"
                ></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p><strong>至此一个从0到1使用<code>hexo</code>+<code>keep主题</code>，集成<code>Github Actions</code>自动部署功能的<code>blog</code>就诞生了。</strong></p>
</li>
<li><p><strong>另外,<code>keep</code>主题提供很多的功能，大家可以根据<a class="link"   href="https://keep-docs.xpoet.cn/usage-tutorial/quick-start.html#%E5%AE%89%E8%A3%85" >keep文档<i class="fas fa-external-link-alt"></i></a>去做相应的配置。</strong></p>
</li>
</ul>
<p><strong><a href="http://www.iwkxk.com/">作者blog预览</a></strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210425120015256.1al5ipo8yq4g.png"
                      alt="image-20210425120015256"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210425120049711.pfc56cr7740.png"
                      alt="image-20210425120049711"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210425120153920.2y53worktea0.png"
                      alt="image-20210425120153920"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210425120226108.5v2kxrpxkgk0.png"
                      alt="image-20210425120226108"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210425120302108.4efqng6b5cm0.png"
                      alt="image-20210425120302108"
                ></p>
<p><strong>如果这篇文章对你有所帮助，可以点赞留言支持下作者，你们的支持是我坚持的动力哈~</strong></p>
<h3 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h3><ul>
<li><h5 id="如何使用-GitHub-Actions-自动部署-Hexo-博客"><a href="#如何使用-GitHub-Actions-自动部署-Hexo-博客" class="headerlink" title="如何使用 GitHub Actions 自动部署 Hexo 博客"></a><a class="link"   href="https://juejin.cn/post/6943895271751286821" >如何使用 GitHub Actions 自动部署 Hexo 博客<i class="fas fa-external-link-alt"></i></a></h5></li>
<li><h5 id="hexo搭建个人网站博客完全教程"><a href="#hexo搭建个人网站博客完全教程" class="headerlink" title="hexo搭建个人网站博客完全教程"></a><a class="link"   href="https://juejin.cn/post/6844903679858851853" >hexo搭建个人网站博客完全教程<i class="fas fa-external-link-alt"></i></a></h5></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>服务端渲染ssr</title>
    <url>/2021/04/25/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93ssr/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p><strong>随着前端技术栈和工具链的迭代成熟，前端工程化、模块化也已成为了当下的主流技术方案，在这波前 端技术浪潮中，涌现了诸如 React、Vue、Angular 等基于客户端渲染的前端框架，这类框架所构建的 单页应用(SPA)具有用户体验好、渲染性能好、可维护性高等优点。但也也有一些很大的缺陷，其中 主要涉及到以下两点:</strong></p>
<ul>
<li><p>首屏加载时间过长</p>
</li>
<li><p>与传统服务端渲染直接获取服务端渲染好的 HTML 不同，单页应用使用 JavaScript 在客户端生成 HTML 来呈现内容，用户需要等待客户端 JS 解析执行完成才能看到页面，这就使得首屏加载时间变长，从而 影响用户体验。</p>
</li>
<li><p>不利于 SEO</p>
<ul>
<li> 当搜索引擎爬取网站 HTML 文件时，单页应用的 HTML 没有内容，因为他它需要通过客户端 JavaScript解析执行才能生成网页内容，而目前的主流的搜索引擎对于这一部分内容的抓取还不是很好。</li>
</ul>
</li>
</ul>
<p><strong>为了解决这两个缺陷，业界借鉴了传统的服务端直出 HTML 方案，提出在服务器端执行前端框架 (React/Vue/Angular)代码生成网页内容，然后将渲染好的网页内容返回给客户端，客户端只需要负责展示就可以了;</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/123.5wf4h6f22cs0.png"
                     
                ></p>
<p>当然不仅仅如此，为了获得更好的用户体验，同时会在客户端将来自服务端渲染的内容激活为一个 SPA 应用，也就是说之后的页面内容交互都是通过客户端渲染处理。</p>
<h2 id="Nuxt-js"><a href="#Nuxt-js" class="headerlink" title="Nuxt.js"></a>Nuxt.js</h2><p><strong>官网：<a class="link"   href="https://zh.nuxtjs.org/" >https://zh.nuxtjs.org/<i class="fas fa-external-link-alt"></i></a></strong></p>
<p><strong>GitHub 仓库：<a class="link"   href="https://github.com/nuxt/nuxt.js" >https://github.com/nuxt/nuxt.js<i class="fas fa-external-link-alt"></i></a></strong></p>
<blockquote>
<p>Nuxt.js 是一个基于 Vue.js 生态开发的一个第三方服务端渲染框架，通过它我们可以轻松构建现代化的服务端渲染应用。</p>
<p>isomorphic web apps（同构应用）：isomorphic/universal，基于 react、vue 框架，客户端渲染和服务器端渲染的结合，在服务器端执行一次，用于实现服务器端渲染（首屏直出），在客户端再执行一次，用于接管页面交互，核心解决 SEO 和首屏渲染慢的问题。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/123.k06jg1rp8j4.png"
                     
                ></p>
<ol>
<li><p>客户端发起请求</p>
</li>
<li><p>服务端渲染首屏内容 + 生成客户端 SPA 相关资源</p>
</li>
<li><p>服务端将生成的首屏资源发送给客户端</p>
</li>
<li><p>客户端直接展示服务端渲染好的首屏内容</p>
</li>
<li><p>首屏中的 SPA 相关资源执行之后会激活客户端 Vue</p>
</li>
<li><p>之后客户端所有的交互都由客户端 SPA 处理</p>
</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><p>优点：首屏渲染速度快、有利于 SEO</p>
</li>
<li><p>缺点：</p>
<ul>
<li>开发成本高。</li>
<li>涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的</li>
<li>server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境(high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略</li>
</ul>
</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h3><ul>
<li><p>基于 Vue.js</p>
</li>
<li><p>Vue、Vue Router、Vuex、Vue SSR</p>
</li>
<li><p>自动代码分层</p>
</li>
<li><p>服务端渲染</p>
</li>
<li><p>强大的路由功能，支持异步数据</p>
</li>
<li><p>静态文件服务</p>
</li>
<li><p>ES2015+ 语法支持</p>
</li>
<li><p>打包和压缩 JS 和 CSS</p>
</li>
<li><p>HTML 头部标签管理</p>
</li>
<li><p>本地开发支持热加载</p>
</li>
<li><p>集成 ESLint</p>
</li>
<li><p>支持各种样式预处理器： SASS、LESS、 Stylus 等等</p>
</li>
<li><p>支持 HTTP/2 推送</p>
</li>
</ul>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a><strong>创建项目</strong></h3><ul>
<li>使用 create-nuxt-app 脚手架工具</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 脚手架创建项目</span></span><br><span class="line">yarn create nuxt-app &lt;project-name&gt;</span><br><span class="line"><span class="comment"># 进入到项目目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line"><span class="comment"># 启动项目</span></span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure>

<ul>
<li>手动创建</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建示例项目 </span></span><br><span class="line">mkdir nuxt-app-demo </span><br><span class="line"><span class="comment"># 进入示例项目目录中 </span></span><br><span class="line"><span class="built_in">cd</span> nuxt-app-demo</span><br><span class="line"><span class="comment"># 初始化 package.json 文件 </span></span><br><span class="line">yarn init -y </span><br><span class="line"><span class="comment"># 安装 nuxt </span></span><br><span class="line">yarn add nuxt</span><br></pre></td></tr></table></figure>

<p>在 <code>package.json</code> 文件的<code>scripts</code>中新增：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123; </span><br><span class="line">  &quot;dev&quot;: &quot;nuxt&quot; </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行项目 </span></span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure>

<h3 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h3><p>创建 <code>pages</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir pages</span><br></pre></td></tr></table></figure>

<p>创建我们的第一个页面 <code>pages/index.vue</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">	&lt;h1&gt;Hello world!&lt;&#x2F;h1&gt; </span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>然后启动项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn dev</span><br></pre></td></tr></table></figure>

<p>现在我们的应用运行在 <a class="link"   href="http://localhost:3000/" >http://localhost:3000<i class="fas fa-external-link-alt"></i></a> 上运行。</p>
<blockquote>
<p>注意：Nuxt.js 会监听 pages 目录中的文件更改，因此在添加新页面时无需重新启动应用程序。</p>
</blockquote>
<h3 id="Nuxt-中的基础路由"><a href="#Nuxt-中的基础路由" class="headerlink" title="Nuxt 中的基础路由"></a>Nuxt 中的基础路由</h3><p>Nuxt.js 会依据 pages 目录中的所有 *.vue 文件生成应用的路由配置。</p>
<p>假设 pages 的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pages&#x2F; </span><br><span class="line">--| user&#x2F; </span><br><span class="line">-----| index.vue </span><br><span class="line">-----| one.vue </span><br><span class="line">--| index.vue</span><br></pre></td></tr></table></figure>

<p>那么，Nuxt.js 自动生成的路由配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router: &#123; </span><br><span class="line">  routes: [ </span><br><span class="line">    &#123; </span><br><span class="line">      name: <span class="string">&#x27;index&#x27;</span>, </span><br><span class="line">      path: <span class="string">&#x27;/&#x27;</span>, </span><br><span class="line">      component: <span class="string">&#x27;pages/index.vue&#x27;</span> </span><br><span class="line">    &#125;,&#123; </span><br><span class="line">      name: <span class="string">&#x27;user&#x27;</span>, </span><br><span class="line">      path: <span class="string">&#x27;/user&#x27;</span>, </span><br><span class="line">      component: <span class="string">&#x27;pages/user/index.vue&#x27;</span> </span><br><span class="line">    &#125;,&#123; </span><br><span class="line">      name: <span class="string">&#x27;user-one&#x27;</span>, </span><br><span class="line">      path: <span class="string">&#x27;/user/one&#x27;</span>, </span><br><span class="line">      component: <span class="string">&#x27;pages/user/one.vue&#x27;</span> </span><br><span class="line">    &#125; </span><br><span class="line">  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a><strong>路由导航</strong></h3><ul>
<li><p>a 标签</p>
</li>
<li><p><code>&lt;nuxt-link&gt;</code> 组件</p>
</li>
<li><p>编程式导航</p>
</li>
</ul>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a><strong>动态路由</strong></h3><p>在 Nuxt.js 里面定义带参数的动态路由，需要创建对应的<strong>以下划线作为前缀</strong>的 Vue 文件 或 目录。</p>
<p>以下目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pages&#x2F;</span><br><span class="line">--| _slug&#x2F; </span><br><span class="line">-----| comments.vue </span><br><span class="line">-----| index.vue </span><br><span class="line">--| users&#x2F; </span><br><span class="line">-----| _id.vue </span><br><span class="line">--| index.vue</span><br></pre></td></tr></table></figure>

<p>Nuxt.js 生成对应的路由配置表为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router: &#123; </span><br><span class="line">  routes: [ </span><br><span class="line">    &#123; </span><br><span class="line">      name: <span class="string">&#x27;index&#x27;</span>, </span><br><span class="line">      path: <span class="string">&#x27;/&#x27;</span>, </span><br><span class="line">      component: <span class="string">&#x27;pages/index.vue&#x27;</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">      name: <span class="string">&#x27;users-id&#x27;</span>, </span><br><span class="line">      path: <span class="string">&#x27;/users/:id?&#x27;</span>, </span><br><span class="line">      component: <span class="string">&#x27;pages/users/_id.vue&#x27;</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">      name: <span class="string">&#x27;slug&#x27;</span>, </span><br><span class="line">      path: <span class="string">&#x27;/:slug&#x27;</span>, </span><br><span class="line">      component: <span class="string">&#x27;pages/_slug/index.vue&#x27;</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">      name: <span class="string">&#x27;slug-comments&#x27;</span>, </span><br><span class="line">      path: <span class="string">&#x27;/:slug/comments&#x27;</span>, </span><br><span class="line">      component: <span class="string">&#x27;pages/_slug/comments.vue&#x27;</span> </span><br><span class="line">    &#125; </span><br><span class="line">  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会发现名称为 <code>users-id</code> 的路由路径带有<code>:id?</code>参数，表示该路由是可选的。如果你想将它设置为必选的路由，需要在 <code>users/_id </code>目录内创建一个 <code>index.vue</code> 文件。</p>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a><strong>嵌套路由</strong></h3><ul>
<li><p>你可以通过 vue-router 的子路由创建 Nuxt.js 应用的嵌套路由。</p>
</li>
<li><p>创建内嵌子路由，你需要添加一个 Vue 文件，同时添加一个<strong>与该文件同名</strong>的目录用来存放子视图组件。</p>
</li>
</ul>
<blockquote>
<p><strong>Warning:</strong> 别忘了在父组件( .vue 文件) 内增加 <nuxt-child/> 用于显示子视图内容。</p>
</blockquote>
<p>假设文件结构如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pages&#x2F; </span><br><span class="line">--| users&#x2F; </span><br><span class="line">-----| _id.vue </span><br><span class="line">-----| index.vue </span><br><span class="line">--| users.vue</span><br></pre></td></tr></table></figure>

<p>Nuxt.js 自动生成的路由配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router: &#123; </span><br><span class="line">  routes: [ </span><br><span class="line">    &#123; </span><br><span class="line">      path: <span class="string">&#x27;/users&#x27;</span>, </span><br><span class="line">      component: <span class="string">&#x27;pages/users.vue&#x27;</span>, </span><br><span class="line">      children: [ </span><br><span class="line">        &#123; </span><br><span class="line">          path: <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">          component: <span class="string">&#x27;pages/users/index.vue&#x27;</span>,</span><br><span class="line">          name: <span class="string">&#x27;users&#x27;</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; </span><br><span class="line">          path: <span class="string">&#x27;:id&#x27;</span>, </span><br><span class="line">          component: <span class="string">&#x27;pages/users/_id.vue&#x27;</span>, </span><br><span class="line">          name: <span class="string">&#x27;users-id&#x27;</span> </span><br><span class="line">        &#125; </span><br><span class="line">      ] </span><br><span class="line">    &#125; </span><br><span class="line">  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a><strong>路由配置</strong></h3><ul>
<li><a class="link"   href="https://zh.nuxtjs.org/api/configuration-router" >https://zh.nuxtjs.org/api/configuration-router<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a><strong>视图</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/1232.1bsdn7tukd4w.png"
                     
                ></p>
<h3 id="异步数据"><a href="#异步数据" class="headerlink" title="异步数据"></a><strong>异步数据</strong></h3><ul>
<li><strong>asyncData</strong> <strong>方法</strong><ul>
<li>Nuxt.js 扩展了 Vue.js，增加了一个叫<code>asyncData</code>的方法，使得我们可以在设置组件的数据之前能异步获取或处理数据。</li>
</ul>
</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/222.4wj9yiise8w0.png"
                     
                ></p>
<h3 id="Nuxt-常见问题"><a href="#Nuxt-常见问题" class="headerlink" title="Nuxt 常见问题"></a><strong>Nuxt</strong> <strong>常见问题</strong></h3><ul>
<li><a class="link"   href="https://zh.nuxtjs.org/faq/" >https://zh.nuxtjs.org/faq/<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h3 id="Nuxt-官方示例"><a href="#Nuxt-官方示例" class="headerlink" title="Nuxt 官方示例"></a><strong>Nuxt</strong> <strong>官方示例</strong></h3><ul>
<li><a class="link"   href="https://zh.nuxtjs.org/examples" >https://zh.nuxtjs.org/examples<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>Nuxt</category>
      </categories>
      <tags>
        <tag>Nuxt</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue响应式原理模拟</title>
    <url>/2021/04/23/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h2><ul>
<li><p>数据驱动</p>
</li>
<li><p>响应式的核心原理</p>
</li>
<li><p>发布订阅模式和观察者模式</p>
</li>
</ul>
<h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a><strong>数据驱动</strong></h2><ul>
<li><p>数据响应式、双向绑定、数据驱动</p>
</li>
<li><p>数据响应式</p>
<ul>
<li>数据模型仅仅是普通的 JavaScript 对象，而当我们修改数据时，视图会进行更新，避免了繁琐的 DOM 操作，提高开发效率</li>
</ul>
</li>
<li><p>双向绑定</p>
<ul>
<li>数据改变，视图改变；视图改变，数据也随之改变</li>
<li>我们可以使用 v-model 在表单元素上创建双向数据绑定</li>
</ul>
</li>
<li><p>数据驱动是 Vue 最独特的特性之一</p>
<ul>
<li>开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图</li>
</ul>
</li>
</ul>
<h2 id="数据响应式的核心原理"><a href="#数据响应式的核心原理" class="headerlink" title="数据响应式的核心原理"></a><strong>数据响应式的核心原理</strong></h2><h3 id="Vue-2-x"><a href="#Vue-2-x" class="headerlink" title="Vue 2.x"></a><strong>Vue 2.x</strong></h3><ul>
<li><p>Vue 2.x深入响应式原理</p>
</li>
<li><p>MDN - Object.defifineProperty</p>
</li>
<li><p>浏览器兼容 IE8 以上（不兼容 IE8） </p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟 Vue 中的 data 选项 </span></span><br><span class="line"><span class="keyword">let</span> data = &#123; <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span> &#125;</span><br><span class="line"><span class="comment">// 模拟 Vue 的实例 </span></span><br><span class="line"><span class="keyword">let</span> vm = &#123;&#125; </span><br><span class="line"><span class="comment">// 数据劫持：当访问或者设置 vm 中的成员的时候，做一些干预操作</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(vm, <span class="string">&#x27;msg&#x27;</span>, &#123; </span><br><span class="line">  <span class="comment">// 可枚举（可遍历） </span></span><br><span class="line">  enumerable: <span class="literal">true</span>, </span><br><span class="line">  <span class="comment">// 可配置（可以使用 delete 删除，可以通过 defineProperty 重新定义） </span></span><br><span class="line">  configurable: <span class="literal">true</span>, </span><br><span class="line">  <span class="comment">// 当获取值的时候执行 </span></span><br><span class="line">  get () &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;get: &#x27;</span>, data.msg) </span><br><span class="line">    <span class="keyword">return</span> data.msg </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当设置值的时候执行 </span></span><br><span class="line">  set (newValue) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;set: &#x27;</span>, newValue)</span><br><span class="line">    <span class="keyword">if</span> (newValue === data.msg) &#123; </span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    data.msg = newValue </span><br><span class="line">    <span class="comment">// 数据更改，更新 DOM 的值 </span></span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>).textContent = data.msg </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">vm.msg = <span class="string">&#x27;Hello World&#x27;</span> </span><br><span class="line"><span class="built_in">console</span>.log(vm.msg)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果有一个对象中多个属性需要转换 getter/setter 如何处理？</li>
</ul>
<h3 id="Vue-3-x"><a href="#Vue-3-x" class="headerlink" title="Vue 3.x"></a><strong>Vue 3.x</strong></h3><ul>
<li><p>MDN - Proxy</p>
</li>
<li><p>直接监听对象，而非属性。</p>
</li>
<li><p>ES 6中新增，IE 不支持，性能由浏览器优化</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟 Vue 中的 data 选项 </span></span><br><span class="line"><span class="keyword">let</span> data = &#123; <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// 模拟 Vue 实例 </span></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123; </span><br><span class="line">  <span class="comment">// 当访问 vm 的成员会执行 </span></span><br><span class="line">  get (target, key) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;get, key: &#x27;</span>, key, target[key]) </span><br><span class="line">    <span class="keyword">return</span> target[key] </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当设置 vm 的成员会执行 </span></span><br><span class="line">  set (target, key, newValue) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;set, key: &#x27;</span>, key, newValue) </span><br><span class="line">    <span class="keyword">if</span> (target[key] === newValue) &#123; </span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    target[key] = newValue </span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>).textContent = target[key] </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 测试 </span></span><br><span class="line">vm.msg = <span class="string">&#x27;Hello World&#x27;</span> </span><br><span class="line"><span class="built_in">console</span>.log(vm.msg)</span><br></pre></td></tr></table></figure>

<h2 id="发布订阅模式和观察者模式"><a href="#发布订阅模式和观察者模式" class="headerlink" title="发布订阅模式和观察者模式"></a><strong>发布订阅模式和观察者模式</strong></h2><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a><strong>发布/订阅模式</strong></h3><ul>
<li>发布/订阅模式<ul>
<li>订阅者</li>
<li>发布者</li>
<li>信号中心</li>
</ul>
</li>
</ul>
<blockquote>
<p>我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。<strong>这就叫做发布/订阅模式（publish-subscribe pattern）</strong></p>
</blockquote>
<ul>
<li>Vue 的自定义事件<ul>
<li><a class="link"   href="https://cn.vuejs.org/v2/guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2" >https://cn.vuejs.org/v2/guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue() </span><br><span class="line">vm.$on(<span class="string">&#x27;dataChange&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;dataChange&#x27;</span>) </span><br><span class="line">&#125;)</span><br><span class="line">vm.$on(<span class="string">&#x27;dataChange&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;dataChange1&#x27;</span>) </span><br><span class="line">&#125;)</span><br><span class="line">vm.$emit(<span class="string">&#x27;dataChange&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>兄弟组件通信过程</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eventBus.js </span></span><br><span class="line"><span class="comment">// 事件中心 </span></span><br><span class="line"><span class="keyword">let</span> eventHub = <span class="keyword">new</span> Vue() </span><br><span class="line"><span class="comment">// ComponentA.vue </span></span><br><span class="line"><span class="comment">// 发布者 addTodo: </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="comment">// 发布消息(事件) </span></span><br><span class="line">  eventHub.$emit(<span class="string">&#x27;add-todo&#x27;</span>, &#123; </span><br><span class="line">    text: <span class="built_in">this</span>.newTodoText </span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="built_in">this</span>.newTodoText = <span class="string">&#x27;&#x27;</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ComponentB.vue </span></span><br><span class="line"><span class="comment">// 订阅者 created: </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="comment">// 订阅消息(事件) </span></span><br><span class="line">  eventHub.$on(<span class="string">&#x27;add-todo&#x27;</span>, <span class="built_in">this</span>.addTodo) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>模拟 Vue 自定义事件的实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123; </span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="comment">// &#123; eventType: [ handler1, handler2 ] &#125; </span></span><br><span class="line">    <span class="built_in">this</span>.subs = &#123;&#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 订阅通知 </span></span><br><span class="line">  $on (eventType, handler) &#123; </span><br><span class="line">    <span class="built_in">this</span>.subs[eventType] = <span class="built_in">this</span>.subs[eventType] || [] </span><br><span class="line">    <span class="built_in">this</span>.subs[eventType].push(handler) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发布通知 </span></span><br><span class="line">  $emit (eventType) &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.subs[eventType]) &#123; </span><br><span class="line">      <span class="built_in">this</span>.subs[eventType].forEach(<span class="function"><span class="params">handler</span> =&gt;</span> &#123; </span><br><span class="line">        handler() </span><br><span class="line">      &#125;) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试 </span></span><br><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> EventEmitter() </span><br><span class="line"><span class="comment">// 注册事件 </span></span><br><span class="line">bus.$on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>) </span><br><span class="line">&#125;)</span><br><span class="line">bus.$on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click1&#x27;</span>) </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 触发事件 </span></span><br><span class="line">bus.$emit(<span class="string">&#x27;click&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><strong>观察者模式</strong></h3><ul>
<li><p>观察者(订阅者) – Watcher</p>
<ul>
<li>update()：当事件发生时，具体要做的事情</li>
</ul>
</li>
<li><p>目标(发布者) – Dep</p>
<ul>
<li>subs 数组：存储所有的观察者</li>
<li>addSub()：添加观察者</li>
<li>notify()：当事件发生，调用所有观察者的 update() 方法</li>
</ul>
</li>
<li><p>没有事件中心</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标(发布者) </span></span><br><span class="line"><span class="comment">// Dependency </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123; </span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="comment">// 存储所有的观察者 </span></span><br><span class="line">    <span class="built_in">this</span>.subs = [] </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加观察者 </span></span><br><span class="line">  addSub (sub) &#123; </span><br><span class="line">    <span class="keyword">if</span> (sub &amp;&amp; sub.update) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.push(sub) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知所有观察者 </span></span><br><span class="line">  notify () &#123; </span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123; </span><br><span class="line">      sub.update() </span><br><span class="line">    &#125;) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者(订阅者) </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123; </span><br><span class="line">  update () &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;update&#x27;</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试 </span></span><br><span class="line"><span class="keyword">let</span> dep = <span class="keyword">new</span> Dep() </span><br><span class="line"><span class="keyword">let</span> watcher = <span class="keyword">new</span> Watcher() </span><br><span class="line">dep.addSub(watcher) </span><br><span class="line">dep.notify()</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><p><strong>观察者模式</strong>是由具体目标调度，比如当事件触发，Dep 就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的。</p>
</li>
<li><p><strong>发布/订阅模式</strong>由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423114525801.5zq60vp6pao0.png"
                      alt="image-20210423114525801"
                ></p>
<h2 id="Vue-响应式原理模拟"><a href="#Vue-响应式原理模拟" class="headerlink" title="Vue 响应式原理模拟"></a><strong>Vue</strong> <strong>响应式原理模拟</strong></h2><h3 id="整体分析"><a href="#整体分析" class="headerlink" title="整体分析"></a><strong>整体分析</strong></h3><ul>
<li><p>Vue 基本结构</p>
</li>
<li><p>打印 Vue 实例观察</p>
</li>
<li><p>整体结构</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423114620375.24ixunec4ulc.png"
                      alt="image-20210423114620375"
                ></p>
<ul>
<li><p>Vue</p>
<ul>
<li>把 data 中的成员注入到 Vue 实例，并且把 data 中的成员转成 getter/setter</li>
</ul>
</li>
<li><p>Observer</p>
<ul>
<li>能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知 Dep</li>
</ul>
</li>
<li><p>Compiler</p>
<ul>
<li>解析每个元素中的指令/插值表达式，并替换成相应的数据</li>
</ul>
</li>
<li><p>Dep</p>
<ul>
<li>添加观察者(watcher)，当数据变化通知所有观察者</li>
</ul>
</li>
<li><p>Watcher</p>
<ul>
<li>数据变化更新视图</li>
</ul>
</li>
</ul>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a><strong>Vue</strong></h3><ul>
<li><p>功能</p>
<ul>
<li>负责接收初始化的参数(选项)</li>
<li>负责把 data 中的属性注入到 Vue 实例，转换成 getter/setter</li>
<li>负责调用 observer 监听 data 中所有属性的变化</li>
<li>负责调用 compiler 解析指令/插值表达式</li>
</ul>
</li>
<li><p>结构</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423114725936.1dxh5c3ekji8.png"
                      alt="image-20210423114725936"
                ></p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123; </span><br><span class="line">  <span class="title">constructor</span> (<span class="params">options</span>) &#123; </span><br><span class="line">    <span class="comment">// 1. 保存选项的数据 </span></span><br><span class="line">    <span class="built_in">this</span>.$options = options || &#123;&#125; </span><br><span class="line">    <span class="built_in">this</span>.$data = options.data || &#123;&#125; </span><br><span class="line">    <span class="keyword">const</span> el = options.el </span><br><span class="line">    <span class="built_in">this</span>.$el = <span class="keyword">typeof</span> options.el === <span class="string">&#x27;string&#x27;</span> ? <span class="built_in">document</span>.querySelector(el) : el</span><br><span class="line">    <span class="comment">// 2. 负责把 data 注入到 Vue 实例 </span></span><br><span class="line">    <span class="built_in">this</span>._proxyData(<span class="built_in">this</span>.$data) </span><br><span class="line">    <span class="comment">// 3. 负责调用 Observer 实现数据劫持</span></span><br><span class="line">    <span class="keyword">new</span> Observer(<span class="built_in">this</span>.$data)</span><br><span class="line">    <span class="comment">// 4. 负责调用 Compiler 解析指令/插值表达式等 </span></span><br><span class="line">    <span class="keyword">new</span> Compiler(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  _proxyData (data) &#123; </span><br><span class="line">    <span class="comment">// 遍历 data 的所有属性 </span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123; </span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, key, &#123; </span><br><span class="line">        get () &#123; </span><br><span class="line">          <span class="keyword">return</span> data[key] </span><br><span class="line">        &#125;,</span><br><span class="line">        set (newValue) &#123; </span><br><span class="line">          <span class="keyword">if</span> (data[key] === newValue) &#123; </span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">          &#125;</span><br><span class="line">          data[key] = newValue </span><br><span class="line">        &#125; </span><br><span class="line">      &#125;) </span><br><span class="line">    &#125;) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><ul>
<li><p>功能</p>
<ul>
<li><p>负责把 data 选项中的属性转换成响应式数据</p>
</li>
<li><p>data 中的某个属性也是对象，把该属性转换成响应式数据</p>
</li>
<li><p>数据变化发送通知</p>
</li>
</ul>
</li>
<li><p>结构</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423114811294.4fk7iw12om40.png"
                      alt="image-20210423114811294"
                ></p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 负责数据劫持 </span></span><br><span class="line"><span class="comment">// 把 $data 中的成员转换成 getter/setter </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123; </span><br><span class="line">  <span class="title">constructor</span> (<span class="params">data</span>) &#123; </span><br><span class="line">    <span class="built_in">this</span>.walk(data) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 1. 判断数据是否是对象，如果不是对象返回 </span></span><br><span class="line">  <span class="comment">// 2. 如果是对象，遍历对象的所有属性，设置为 getter/setter </span></span><br><span class="line">  walk (data) &#123; </span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历 data 的所有成员 </span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123; </span><br><span class="line">      <span class="built_in">this</span>.defineReactive(data, key, data[key]) </span><br><span class="line">    &#125;) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义响应式成员 </span></span><br><span class="line">  defineReactive (data, key, val) &#123; </span><br><span class="line">    <span class="keyword">const</span> that = <span class="built_in">this</span> </span><br><span class="line">    <span class="comment">// 如果 val 是对象，继续设置它下面的成员为响应式数据 </span></span><br><span class="line">    <span class="built_in">this</span>.walk(val) </span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123; </span><br><span class="line">      configurable: <span class="literal">true</span>, </span><br><span class="line">      enumerable: <span class="literal">true</span>, </span><br><span class="line">      get () &#123; </span><br><span class="line">        <span class="keyword">return</span> val </span><br><span class="line">      &#125;,</span><br><span class="line">      set (newValue) &#123; </span><br><span class="line">        <span class="keyword">if</span> (newValue === val) &#123; </span><br><span class="line">          <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 newValue 是对象，设置 newValue 的成员为响应式 </span></span><br><span class="line">        that.walk(newValue) </span><br><span class="line">        val = newValue</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a><strong>Compiler</strong></h3><ul>
<li><p>功能</p>
<ul>
<li>负责编译模板，解析指令/插值表达式</li>
<li>负责页面的首次渲染</li>
<li>当数据变化后重新渲染视图</li>
</ul>
</li>
<li><p>结构</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423115011695.41bi909abc80.png"
                      alt="image-20210423115011695"
                ></p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 负责解析指令/插值表达式 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> </span>&#123; </span><br><span class="line">  <span class="title">constructor</span> (<span class="params">vm</span>) &#123; </span><br><span class="line">    <span class="built_in">this</span>.vm = vm </span><br><span class="line">    <span class="built_in">this</span>.el = vm.$el</span><br><span class="line">    <span class="comment">// 编译模板 </span></span><br><span class="line">    <span class="built_in">this</span>.compile(<span class="built_in">this</span>.el) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译模板 </span></span><br><span class="line">  <span class="comment">// 处理文本节点和元素节点 </span></span><br><span class="line">  compile (el) &#123; </span><br><span class="line">    <span class="keyword">const</span> nodes = el.childNodes </span><br><span class="line">    <span class="built_in">Array</span>.from(nodes).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123; </span><br><span class="line">      <span class="comment">// 判断是文本节点还是元素节点 </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isTextNode(node)) &#123; </span><br><span class="line">        <span class="built_in">this</span>.compileText(node) </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        <span class="built_in">this</span>.isElementNode(node)</span><br><span class="line">      ) &#123; </span><br><span class="line">        <span class="built_in">this</span>.compileElement(node) </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123; </span><br><span class="line">        <span class="comment">// 如果当前节点中还有子节点，递归编译 </span></span><br><span class="line">        <span class="built_in">this</span>.compile(node) </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是文本节点 </span></span><br><span class="line">  isTextNode (node) &#123; </span><br><span class="line">    <span class="keyword">return</span> node.nodeType === <span class="number">3</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是属性节点 </span></span><br><span class="line">  isElementNode (node) &#123; </span><br><span class="line">    <span class="keyword">return</span> node.nodeType === <span class="number">1</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是以 v- 开头的指令 </span></span><br><span class="line">  isDirective (attrName) &#123; </span><br><span class="line">    <span class="keyword">return</span> attrName.startsWith(<span class="string">&#x27;v-&#x27;</span>) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译文本节点 </span></span><br><span class="line">  compileText (node) &#123; &#125;</span><br><span class="line">  <span class="comment">// 编译属性节点 </span></span><br><span class="line">  compileElement (node) &#123; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="compileText"><a href="#compileText" class="headerlink" title="compileText()"></a><strong>compileText()</strong></h4><ul>
<li>负责编译插值表达式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译文本节点 </span></span><br><span class="line">compileText (node) &#123; </span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(.+)\&#125;\&#125;/</span> </span><br><span class="line">  <span class="comment">// 获取文本节点的内容 </span></span><br><span class="line">  <span class="keyword">const</span> value = node.textContent </span><br><span class="line">  <span class="keyword">if</span> (reg.test(value)) &#123; </span><br><span class="line">    <span class="comment">// 插值表达式中的值就是我们要的属性名称 </span></span><br><span class="line">    <span class="keyword">const</span> key = <span class="built_in">RegExp</span>.$1.trim() </span><br><span class="line">    <span class="comment">// 把插值表达式替换成具体的值 </span></span><br><span class="line">    node.textContent = value.replace(reg, <span class="built_in">this</span>.vm[key]) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="compileElement"><a href="#compileElement" class="headerlink" title="compileElement()"></a><strong>compileElement()</strong></h4><ul>
<li><p>负责编译元素的指令</p>
</li>
<li><p>处理 v-text 的首次渲染</p>
</li>
<li><p>处理 v-model 的首次渲染</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译属性节点 </span></span><br><span class="line">compileElement (node) &#123; </span><br><span class="line">  <span class="comment">// 遍历元素节点中的所有属性，找到指令 </span></span><br><span class="line">  <span class="built_in">Array</span>.from(node.attributes).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 获取元素属性的名称 </span></span><br><span class="line">    <span class="keyword">let</span> attrName = attr.name </span><br><span class="line">    <span class="comment">// 判断当前的属性名称是否是指令 </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isDirective(attrName)) &#123; </span><br><span class="line">      <span class="comment">// attrName 的形式 v-text v-model </span></span><br><span class="line">      <span class="comment">// 截取属性的名称，获取 text model </span></span><br><span class="line">      attrName = attrName.substr(<span class="number">2</span>) </span><br><span class="line">      <span class="comment">// 获取属性的名称，属性的名称就是我们数据对象的属性 v-text=&quot;name&quot;，获取的是 name </span></span><br><span class="line">      <span class="keyword">const</span> key = attr.value </span><br><span class="line">      <span class="comment">// 处理不同的指令 </span></span><br><span class="line">      <span class="built_in">this</span>.update(node, key, attrName) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 负责更新 DOM </span></span><br><span class="line"><span class="comment">// 创建 Watcher </span></span><br><span class="line">update (node, key, dir) &#123; </span><br><span class="line">  <span class="comment">// node 节点，key 数据的属性名称，dir 指令的后半部分 </span></span><br><span class="line">  <span class="keyword">const</span> updaterFn = <span class="built_in">this</span>[dir + <span class="string">&#x27;Updater&#x27;</span>] </span><br><span class="line">  <span class="comment">// 处理 v-on 指令</span></span><br><span class="line">  <span class="keyword">if</span> (attrName.startsWith(<span class="string">&#x27;on:&#x27;</span>)) &#123;</span><br><span class="line">    updateFn = <span class="built_in">this</span>[<span class="string">&#x27;on&#x27;</span> + <span class="string">&#x27;Updater&#x27;</span>]</span><br><span class="line">    <span class="keyword">const</span> eventType = attrName.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    updateFn.call(<span class="built_in">this</span>, node, <span class="built_in">this</span>.vm[key], key, eventType)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  updateFn &amp;&amp; updateFn.call(<span class="built_in">this</span>, node, <span class="built_in">this</span>.vm[key], key) <span class="comment">// 此处的 this 就是 compiler 对象 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// v-text 指令的更新方法 </span></span><br><span class="line">textUpdater (node, value) &#123; </span><br><span class="line">  node.textContent = value </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// v-model 指令的更新方法 </span></span><br><span class="line">modelUpdater (node, value) &#123; </span><br><span class="line">  node.value = value </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// v-html 指令的更新方法</span></span><br><span class="line">htmlUpdater (node, value, key) &#123;</span><br><span class="line">  node.innerHTML = value</span><br><span class="line">  <span class="keyword">new</span> Watcher(<span class="built_in">this</span>.vm, key, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    node.innerHTML = newValue</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理 v-on 指令</span></span><br><span class="line">onUpdater (node, value, key, eventType) &#123;</span><br><span class="line">  node.addEventListener(eventType, <span class="built_in">this</span>.vm.$options.methods[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dep-Dependency"><a href="#Dep-Dependency" class="headerlink" title="Dep(Dependency)"></a><strong>Dep(Dependency)</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423120227165.qhxo1ewyjww.png"
                      alt="image-20210423120227165"
                ></p>
<ul>
<li><p>功能</p>
<ul>
<li>收集依赖，添加观察者(watcher)</li>
<li>通知所有观察者</li>
</ul>
</li>
<li><p>结构</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423120405508.1q5piqjl6clc.png"
                      alt="image-20210423120405508"
                ></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123; </span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="comment">// 存储所有的观察者 </span></span><br><span class="line">    <span class="built_in">this</span>.subs = [] </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加观察者 </span></span><br><span class="line">  addSub (sub) &#123; </span><br><span class="line">    <span class="keyword">if</span> (sub &amp;&amp; sub.update) &#123; </span><br><span class="line">      <span class="built_in">this</span>.subs.push(sub) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知所有观察者 </span></span><br><span class="line">  notify () &#123; </span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123; </span><br><span class="line">      sub.update() </span><br><span class="line">    &#125;) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 compiler.js 中收集依赖，发送通知</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defineReactive 中 </span></span><br><span class="line"><span class="comment">// 创建 dep 对象收集依赖 </span></span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep() </span><br><span class="line"><span class="comment">// getter 中 </span></span><br><span class="line"><span class="comment">// get 的过程中收集依赖 </span></span><br><span class="line">Dep.target &amp;&amp; dep.addSub(Dep.target) </span><br><span class="line"><span class="comment">// setter 中 </span></span><br><span class="line"><span class="comment">// 当数据变化之后，发送通知 </span></span><br><span class="line">dep.notify()</span><br></pre></td></tr></table></figure>

<h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a><strong>Watcher</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423120906887.obnmlu04b3k.png"
                      alt="image-20210423120906887"
                ></p>
<ul>
<li><p>功能</p>
<ul>
<li>当数据变化触发依赖， dep 通知所有的 Watcher 实例更新视图</li>
<li>自身实例化的时候往 dep 对象中添加自己</li>
</ul>
</li>
<li><p>结构</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423121051348.36gxj5kmjzy0.png"
                      alt="image-20210423121051348"
                ></p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123; </span><br><span class="line">  <span class="title">constructor</span> (<span class="params">vm, key, cb</span>) &#123; </span><br><span class="line">    <span class="built_in">this</span>.vm = vm </span><br><span class="line">    <span class="comment">// data 中的属性名称 </span></span><br><span class="line">    <span class="built_in">this</span>.key = key </span><br><span class="line">    <span class="comment">// 当数据变化的时候，调用 cb 更新视图 </span></span><br><span class="line">    <span class="built_in">this</span>.cb = cb </span><br><span class="line">    <span class="comment">// 在 Dep 的静态属性上记录当前 watcher 对象，当访问数据的时候把 watcher 添加到 dep 的 subs 中 </span></span><br><span class="line">    Dep.target = <span class="built_in">this</span> </span><br><span class="line">    <span class="comment">// 触发一次 getter，让 dep 为当前 key 记录 watcher </span></span><br><span class="line">    <span class="built_in">this</span>.oldValue = vm[key] </span><br><span class="line">    <span class="comment">// 清空 target </span></span><br><span class="line">    Dep.target = <span class="literal">null</span> </span><br><span class="line">  &#125;</span><br><span class="line">  update () &#123; </span><br><span class="line">    <span class="keyword">const</span> newValue = <span class="built_in">this</span>.vm[<span class="built_in">this</span>.key] </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.oldValue === newValue) &#123; </span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb(newValue) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 compiler.js 中为每一个指令/插值表达式创建 watcher 对象，监视数据的变化</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为在 textUpdater等中要使用 </span></span><br><span class="line"><span class="built_in">this</span> updaterFn &amp;&amp; updaterFn.call(<span class="built_in">this</span>, node, <span class="built_in">this</span>.vm[key], key) </span><br><span class="line"><span class="comment">// v-text 指令的更新方法 </span></span><br><span class="line">textUpdater (node, value, key) &#123; </span><br><span class="line">  node.textContent = value </span><br><span class="line">  <span class="comment">// 每一个指令中创建一个 watcher，观察数据的变化 </span></span><br><span class="line">  <span class="keyword">new</span> Watcher(<span class="built_in">this</span>.vm, key, <span class="function"><span class="params">value</span> =&gt;</span> &#123; </span><br><span class="line">    node.textContent = value </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>视图变化更新数据</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v-model 指令的更新方法 </span></span><br><span class="line">modelUpdater (node, value, key) &#123; </span><br><span class="line">  node.value = value </span><br><span class="line">  <span class="comment">// 每一个指令中创建一个 watcher，观察数据的变化 </span></span><br><span class="line">  <span class="keyword">new</span> Watcher(<span class="built_in">this</span>.vm, key, <span class="function"><span class="params">value</span> =&gt;</span> &#123; </span><br><span class="line">    node.value = value </span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 监听视图的变化 </span></span><br><span class="line">  node.addEventListener(<span class="string">&#x27;input&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.vm[key] = node.value </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li>通过下图回顾整体流程</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423141500870.vbq2jhcfb9c.png"
                      alt="image-20210423141500870"
                ></p>
<ul>
<li><p>Vue</p>
<ul>
<li>记录传入的选项，设置 $data/$el</li>
<li>把 data 的成员注入到 Vue 实例</li>
<li>负责调用 Observer 实现数据响应式处理（数据劫持）</li>
<li>负责调用 Compiler 编译指令/插值表达式等</li>
</ul>
</li>
<li><p>Observer</p>
<ul>
<li>数据劫持<ul>
<li>负责把 data 中的成员转换成 getter/setter</li>
<li>负责把多层属性转换成 getter/setter</li>
<li>如果给属性赋值为新对象，把新对象的成员设置为 getter/setter</li>
</ul>
</li>
<li>添加 Dep 和 Watcher 的依赖关系</li>
<li>数据变化发送通知</li>
</ul>
</li>
<li><p>Compiler</p>
<ul>
<li>负责编译模板，解析指令/插值表达式</li>
<li>负责页面的首次渲染过程</li>
<li>当数据变化后重新渲染</li>
</ul>
</li>
<li><p>Dep</p>
<ul>
<li>收集依赖，添加订阅者(watcher)</li>
<li>通知所有订阅者</li>
</ul>
</li>
<li><p>Watcher</p>
<ul>
<li>自身实例化的时候往dep对象中添加自己</li>
<li>当数据变化dep通知所有的 Watcher 实例更新视图</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue源码剖析</category>
      </categories>
      <tags>
        <tag>Vue响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码剖析(二) — Vue虚拟DOM</title>
    <url>/2021/04/23/Vue%E8%99%9A%E6%8B%9FDOM/</url>
    <content><![CDATA[<h2 id="虚拟-DOM-回顾"><a href="#虚拟-DOM-回顾" class="headerlink" title="虚拟 DOM 回顾"></a><strong>虚拟</strong> <strong>DOM</strong> <strong>回顾</strong></h2><h2 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM"></a><strong>什么是虚拟</strong> <strong>DOM</strong></h2><p>虚拟 DOM(Virtual DOM) 是使用 JavaScript 对象来描述 DOM，虚拟 DOM 的本质就是 JavaScript 对 象，使用 JavaScript 对象来描述 DOM 的结构。应用的各种状态变化首先作用于虚拟 DOM，最终映射 到 DOM。Vue.js 中的虚拟 DOM 借鉴了 Snabbdom，并添加了一些 Vue.js 中的特性，例如:指令和组 件机制。</p>
<p>Vue 1.x 中细粒度监测数据的变化，每一个属性对应一个 watcher，开销太大Vue 2.x 中每个组件对应一 个 watcher，状态变化通知到组件，再引入虚拟 DOM 进行比对和渲染</p>
<h2 id="为什么要使用虚拟-DOM"><a href="#为什么要使用虚拟-DOM" class="headerlink" title="为什么要使用虚拟 DOM"></a><strong>为什么要使用虚拟</strong> <strong>DOM</strong></h2><ul>
<li>使用虚拟 DOM，可以避免用户直接操作 DOM，开发过程关注在业务代码的实现，不需要关注如 何操作 DOM，从而提高开发效率</li>
<li>作为一个中间层可以跨平台，除了 Web 平台外，还支持 SSR、Weex。 </li>
<li>关于性能方面，在首次渲染的时候肯定不如直接操作 DOM，因为要维护一层额外的虚拟 DOM， 如果后续有频繁操作 DOM 的操作，这个时候可能会有性能的提升，虚拟 DOM 在更新真实 DOM 之前会通过 Diff 算法对比新旧两个虚拟 DOM 树的差异，最终把差异更新到真实 DOM</li>
</ul>
<h2 id="Vue-js-中的虚拟-DOM"><a href="#Vue-js-中的虚拟-DOM" class="headerlink" title="Vue.js 中的虚拟 DOM"></a><strong>Vue.js</strong> <strong>中的虚拟</strong> <strong>DOM</strong></h2><ul>
<li><strong>演示</strong> <strong>render</strong> <strong>中的</strong> <strong>h</strong> <strong>函数</strong><ul>
<li> h 函数就是 createElement()</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    <span class="comment">// h(tag, data, children)</span></span><br><span class="line">    <span class="comment">// return h(&#x27;h1&#x27;, this.msg)</span></span><br><span class="line">    <span class="comment">// return h(&#x27;h1&#x27;, &#123; domProps: &#123; innerHTML: this.msg &#125; &#125;)</span></span><br><span class="line">    <span class="comment">// return h(&#x27;h1&#x27;, &#123; attrs: &#123; id: &#x27;title&#x27; &#125; &#125;, this.msg)</span></span><br><span class="line">    <span class="keyword">const</span> vnode = h(</span><br><span class="line">    <span class="string">&#x27;h1&#x27;</span>, &#123;</span><br><span class="line">            attrs: &#123; <span class="attr">id</span>: <span class="string">&#x27;title&#x27;</span> &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">    <span class="built_in">this</span>.msg )</span><br><span class="line">        <span class="built_in">console</span>.log(vnode)</span><br><span class="line">        <span class="keyword">return</span> vnode</span><br><span class="line">      &#125;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        msg: <span class="string">&#x27;Hello Vue&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="虚拟-DOM-创建过程"><a href="#虚拟-DOM-创建过程" class="headerlink" title="虚拟 DOM 创建过程"></a><strong>虚拟</strong> <strong>DOM</strong> <strong>创建过程</strong></h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423153407789.65qvx249imw0.png"
                      alt="image-20210423153407789"
                ></p>
<h2 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a><strong>createElement</strong></h2><p><strong>功能</strong></p>
<p>createElement() 函数，用来创建虚拟节点 (VNode)，我们的 render 函数中的参数 h，就是 createElement()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params">h</span>)</span> &#123;</span><br><span class="line"><span class="comment">// 此处的 h 就是 vm.$createElement </span></span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">&#x27;h1&#x27;</span>, <span class="built_in">this</span>.msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义</strong></p>
<p>在 vm._render() 中调用了，用户传递的或者编译生成的 render 函数，这个时候传递了 createElement </p>
<ul>
<li>src/core/instance/render.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// normalization is always applied for the public version, used in</span></span><br><span class="line"><span class="comment">// user-written render functions.</span></span><br><span class="line">vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>vm.*c vm.$createElement createElement vm.*c 在编译生成的 render 函数内部会调用，vm.$createElement 在用户传入的 render 函数内部调用。当用户传入 render 函数的时候，要对用户传入的参数做处理</p>
<ul>
<li>src/core/vdom/create-element.js</li>
</ul>
<p> 执行完 createElement 之后创建好了 VNode，把创建好的 VNode 传递给 vm._update() 继续处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  normalizationType: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  alwaysNormalize: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 判断第三个参数</span></span><br><span class="line"><span class="comment">// 如果 data 是数组或者原始值的话就是 children，实现类似函数重载的机制 if (Array.isArray(data) || isPrimitive(data)) &#123;</span></span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isTrue(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = ALWAYS_NORMALIZE</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _createElement(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string | Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"> data?: VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  children?: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  normalizationType?: number</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// object syntax in v-bind</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(data.is)) &#123;</span><br><span class="line">    tag = data.is</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">      <span class="comment">// in case of component :is set to falsy value</span></span><br><span class="line">      <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">      <span class="comment">// support single function children as default scoped slot</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children) &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> children[<span class="number">0</span>] === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    )&#123;</span><br><span class="line">    data = data || &#123;&#125;</span><br><span class="line">    data.scopedSlots = &#123; <span class="attr">default</span>: children[<span class="number">0</span>] &#125; children.length = <span class="number">0</span></span><br><span class="line">    &#125;<span class="comment">// 去处理 children</span></span><br><span class="line">    <span class="keyword">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">    <span class="comment">// 当手写 render 函数的时候调用</span></span><br><span class="line">    <span class="comment">// 判断 children 的类型，如果是原始值的话转换成 VNode 的数组 // 如果是数组的话，继续处理数组中的元素</span></span><br><span class="line">    <span class="comment">// 如果数组中的子元素又是数组(slot template)，递归处理</span></span><br><span class="line">    <span class="comment">// 如果连续两个节点都是字符串会合并文本节点</span></span><br><span class="line">    children = normalizeChildren(children)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">      <span class="comment">// 把二维数组转换为一维数组</span></span><br><span class="line">      <span class="comment">// 如果 children 中有函数组件的话，函数组件会返回数组形式</span></span><br><span class="line">      <span class="comment">// 这时候 children 就是一个二维数组，只需要把二维数组转换为一维数组 children = simpleNormalizeChildren(children)</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> vnode, ns</span><br><span class="line">      <span class="comment">// 判断 tag 是字符串还是组件</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> Ctor</span><br><span class="line">          ns = (context.$vnode &amp;&amp; context.$vnode.ns) ||</span><br><span class="line">      config.getTagNamespace(tag)</span><br><span class="line">      <span class="comment">// 如果是浏览器的保留标签，创建对应的 VNode </span></span><br><span class="line">      <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">        <span class="comment">// platform built-in elements</span></span><br><span class="line">        vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">          config.parsePlatformTagName(tag), data, children,</span><br><span class="line">          <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">  		<span class="comment">// 否则的话创建组件</span></span><br><span class="line">        vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   		<span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">      <span class="comment">// parent normalizes children</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">		&#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// direct component options / constructor</span></span><br><span class="line">      vnode = createComponent(tag, data, context, children)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">      <span class="keyword">return</span> vnode</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(vnode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(ns)) applyNS(vnode, ns)</span><br><span class="line">      <span class="keyword">if</span> (isDef(data)) registerDeepBindings(data)</span><br><span class="line">      <span class="keyword">return</span> vnode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="update"><a href="#update" class="headerlink" title="update"></a><strong>update</strong></h2><p><strong>功能</strong></p>
<p>内部调用 vm.<strong>patch</strong>() 把虚拟 DOM 转换成真实 DOM</p>
<p><strong>定义</strong></p>
<ul>
<li>src/core/instance/lifecycle.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">    <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">    vm._vnode = vnode</span><br><span class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">    <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">      <span class="comment">// initial render</span></span><br><span class="line">      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly</span></span><br><span class="line"><span class="comment">*/</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// updates</span></span><br><span class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    restoreActiveInstance()</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">      prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = vm</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">    vm.$parent.$el = vm.$el</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">  <span class="comment">// updated in a parent&#x27;s updated hook.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="patch-函数初始化-功能"><a href="#patch-函数初始化-功能" class="headerlink" title="patch 函数初始化 功能"></a><strong>patch</strong> <strong>函数初始化</strong> <strong>功能</strong></h2><p>对比两个 VNode 的差异，把差异更新到真实 DOM。如果是首次渲染的话，会把真实 DOM 先转换成 VNode</p>
<p><strong>Snabbdom</strong> <strong>中</strong> <strong>patch</strong> <strong>函数的初始化</strong> </p>
<ul>
<li>src/snabbdom.ts</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span> (<span class="params">modules: <span class="built_in">Array</span>&lt;Partial&lt;Module&gt;&gt;, domApi?: DOMAPI</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode: VNode | Element, vnode: VNode</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vnode</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">vnode</span> (<span class="params">sel: string | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: any | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: <span class="built_in">Array</span>&lt;VNode | string&gt; | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  text: string | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  elm: Element | Text | <span class="literal">undefined</span></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = data === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : data.key</span><br><span class="line">  <span class="keyword">return</span> &#123; sel, data, children, text, elm, key &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vue-js-中-patch-函数的初始化"><a href="#Vue-js-中-patch-函数的初始化" class="headerlink" title="Vue.js 中 patch 函数的初始化"></a><strong>Vue.js</strong> <strong>中</strong> <strong>patch</strong> <strong>函数的初始化</strong></h2><ul>
<li> src/platforms/web/runtime/index.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; patch &#125; <span class="keyword">from</span> <span class="string">&#x27;./patch&#x27;</span></span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</span><br></pre></td></tr></table></figure>

<ul>
<li>src/platforms/web/runtime/patch.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> nodeOps <span class="keyword">from</span> <span class="string">&#x27;web/runtime/node-ops&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPatchFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;core/vdom/patch&#x27;</span></span><br><span class="line"><span class="keyword">import</span> baseModules <span class="keyword">from</span> <span class="string">&#x27;core/vdom/modules/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> platformModules <span class="keyword">from</span> <span class="string">&#x27;web/runtime/modules/index&#x27;</span></span><br><span class="line"><span class="comment">// the directive module should be applied last, after all</span></span><br><span class="line"><span class="comment">// built-in modules have been applied.</span></span><br><span class="line"><span class="keyword">const</span> modules = platformModules.concat(baseModules)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> patch: <span class="built_in">Function</span> = createPatchFunction(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>src/core/vdom/patch.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPatchFunction</span> (<span class="params">backend</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, j</span><br><span class="line">  <span class="keyword">const</span> cbs = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; modules, nodeOps &#125; = backend</span><br><span class="line">  <span class="comment">// 把模块中的钩子函数全部设置到 cbs 中，将来统一触发 // cbs --&gt; &#123; &#x27;create&#x27;: [fn1, fn2], ... &#125;</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hooks.length; ++i) &#123;</span><br><span class="line">      cbs[hooks[i]] = []</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; modules.length; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(modules[j][hooks[i]])) &#123;</span><br><span class="line">          cbs[hooks[i]].push(modules[j][hooks[i]])</span><br><span class="line">  			&#125; </span><br><span class="line">      &#125;</span><br><span class="line">		&#125;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="patch-函数执行过程"><a href="#patch-函数执行过程" class="headerlink" title="patch 函数执行过程"></a><strong>patch</strong> <strong>函数执行过程</strong></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123; <span class="comment">// 如果没有 vnode 但是有 oldVnode，执行销毁的钩子函数</span></span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line">  <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">    <span class="comment">// 如果没有 oldVnode，创建 vnode 对应的真实 DOM</span></span><br><span class="line">    <span class="comment">// empty mount (likely as component), create new root element </span></span><br><span class="line">    isInitialPatch = <span class="literal">true</span></span><br><span class="line">    createElm(vnode, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前 oldVnode 是否是 DOM 元素(首次渲染)</span></span><br><span class="line">    <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">    <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">     	<span class="comment">// 如果不是真实 DOM，并且两个 VNode 是 sameVnode，这个时候开始执行 Diff </span></span><br><span class="line">      <span class="comment">// patch existing root node</span></span><br><span class="line">    	patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>,</span><br><span class="line">    	removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">        <span class="comment">// mounting to a real element</span></span><br><span class="line">        <span class="comment">// check if this is server-rendered content and if we can perform</span></span><br><span class="line">        <span class="comment">// a successful hydration.</span></span><br><span class="line">        <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">          oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">          hydrating = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">				......</span><br><span class="line">        <span class="comment">// either not server-rendered, or hydration failed.</span></span><br><span class="line">        <span class="comment">// create an empty node and replace it</span></span><br><span class="line">        oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// replacing existing element</span></span><br><span class="line">      <span class="keyword">const</span> oldElm = oldVnode.elm</span><br><span class="line">      <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line">      <span class="comment">// create new node</span></span><br><span class="line">      createElm(</span><br><span class="line">        vnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">        <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">        <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">        oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">        nodeOps.nextSibling(oldElm)</span><br><span class="line">			)</span><br><span class="line">      <span class="comment">// update parent placeholder node element, recursively</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">        <span class="keyword">let</span> ancestor = vnode.parent</span><br><span class="line">        <span class="keyword">const</span> patchable = isPatchable(vnode)</span><br><span class="line">        <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">            cbs.destroy[i](ancestor)</span><br><span class="line">          &#125;</span><br><span class="line">          ancestor.elm = vnode.elm</span><br><span class="line">          <span class="keyword">if</span> (patchable) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">              cbs.create[i](emptyNode, ancestor)</span><br><span class="line">					&#125;</span><br><span class="line">          <span class="comment">// #6513</span></span><br><span class="line">          <span class="comment">// invoke insert hooks that may have been merged by create</span></span><br><span class="line">          <span class="comment">// e.g. for directives that uses the &quot;inserted&quot; hook.</span></span><br><span class="line">          <span class="keyword">const</span> insert = ancestor.data.hook.insert</span><br><span class="line">          <span class="keyword">if</span> (insert.merged) &#123;</span><br><span class="line">            <span class="comment">// start at index 1 to avoid re-invoking component mounted</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">             	insert.fns[i]()</span><br><span class="line">						&#125;</span><br><span class="line">          &#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            registerRef(ancestor)</span><br><span class="line">          &#125;</span><br><span class="line">          ancestor = ancestor.parent</span><br><span class="line">        &#125;</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// destroy old node</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">        removeVnodes(parentElm, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">        invokeDestroyHook(oldVnode)</span><br><span class="line">			&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">  <span class="keyword">return</span> vnode.elm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="createElm"><a href="#createElm" class="headerlink" title="createElm"></a><strong>createElm</strong></h2><p>把 VNode 转换成真实 DOM，插入到 DOM 树上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"> vnode,</span></span></span><br><span class="line"><span class="function"><span class="params"> insertedVnodeQueue,</span></span></span><br><span class="line"><span class="function"><span class="params"> parentElm,</span></span></span><br><span class="line"><span class="function"><span class="params"> refElm,</span></span></span><br><span class="line"><span class="function"><span class="params"> nested,</span></span></span><br><span class="line"><span class="function"><span class="params"> ownerArray,</span></span></span><br><span class="line"><span class="function"><span class="params"> index</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">    <span class="comment">// This vnode was used in a previous render!</span></span><br><span class="line">    <span class="comment">// now it&#x27;s used as a new node, overwriting its elm would cause</span></span><br><span class="line">    <span class="comment">// potential patch errors down the road when it&#x27;s used as an insertion</span></span><br><span class="line">    <span class="comment">// reference node. Instead, we clone the node on-demand before creating</span></span><br><span class="line">    <span class="comment">// associated DOM element for it.</span></span><br><span class="line">    vnode = ownerArray[index] = cloneVNode(vnode)</span><br><span class="line">&#125;</span><br><span class="line">  vnode.isRootInsert = !nested <span class="comment">// for transition enter check</span></span><br><span class="line">  <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">  	<span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">const</span> data = vnode.data</span><br><span class="line">    <span class="keyword">const</span> children = vnode.children</span><br><span class="line">    <span class="keyword">const</span> tag = vnode.tag</span><br><span class="line">    <span class="keyword">if</span> (isDef(tag)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &amp;&amp; data.pre) &#123;</span><br><span class="line">          creatingElmInVPre++</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="keyword">if</span> (isUnknownElement(vnode, creatingElmInVPre)) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">&#x27;Unknown custom element: &lt;&#x27;</span> + tag + <span class="string">&#x27;&gt; - did you &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;register the component correctly? For recursive components, &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;make sure to provide the &quot;name&quot; option.&#x27;</span>,</span><br><span class="line">              vnode.context</span><br><span class="line">  		) </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      vnode.elm = vnode.ns</span><br><span class="line">        ? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">      : nodeOps.createElement(tag, vnode)</span><br><span class="line">      setScope(vnode)</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (__WEEX__) &#123;</span><br><span class="line">        ......</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">        <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; data &amp;&amp; data.pre) &#123;</span><br><span class="line">        creatingElmInVPre--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTrue(vnode.isComment)) &#123;</span><br><span class="line">      vnode.elm = nodeOps.createComment(vnode.text)</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode.elm = nodeOps.createTextNode(vnode.text)</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a><strong>patchVnode</strong></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  oldVnode,</span></span></span><br><span class="line"><span class="function"><span class="params">  vnode,</span></span></span><br><span class="line"><span class="function"><span class="params">  insertedVnodeQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">  ownerArray,</span></span></span><br><span class="line"><span class="function"><span class="params">	index,</span></span></span><br><span class="line"><span class="function"><span class="params">	removeOnly</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 如果新旧节点是完全相同的节点，直接返回 </span></span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">  	<span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line"> 			<span class="comment">// clone reused vnode</span></span><br><span class="line">      vnode = ownerArray[index] = cloneVNode(vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 触发 prepatch 钩子函数</span></span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">const</span> data = vnode.data</span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;</span><br><span class="line">          i(oldVnode, vnode)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 获取新旧 VNode 的子节点</span></span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">    <span class="keyword">const</span> ch = vnode.children</span><br><span class="line">    <span class="comment">// 触发 update 钩子函数</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode,vnode)</span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 vnode 没有 text 属性(说明有可能有子元素) </span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// 如果新旧节点都有子节点并且不相同，这时候对比和更新子节点 if (oldCh !== ch) </span></span><br><span class="line">        updateChildren(elm, oldCh, ch,insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">          checkDuplicateKeys(ch)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果新节点有子节点，并且旧节点有 text</span></span><br><span class="line">      <span class="comment">// 清空旧节点对应的真实 DOM 的文本内容</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      <span class="comment">// 把新节点的子节点添转换成真实 DOM，添加到 elm</span></span><br><span class="line">      addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 如果旧节点有子节点，新节点没有子节点</span></span><br><span class="line">      <span class="comment">// 移除所有旧节点对应的真实 DOM</span></span><br><span class="line">      removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">    <span class="comment">// 如果旧节点有 text，新节点没有子节点和 text </span></span><br><span class="line">      nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    <span class="comment">// 如果新节点有 text，并且和旧节点的 text 不同 // 直接把新节点的 text 更新到 DOM 上 nodeOps.setTextContent(elm, vnode.text)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发 postpatch 钩子函数 if (isDef(data)) &#123;</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode,vnode)</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a><strong>updateChildren</strong></h2><p>updateChildren 和 Snabbdom 中的 updateChildren 整体算法一致，这里就不再展开了。我们再来看 下它处理过程中 key 的作用，再 patch 函数中，调用 patchVnode 之前，会首先调用 sameVnode()判 断当前的新老 VNode 是否是相同节点，sameVnode() 中会首先判断 key 是否相同。</p>
<ul>
<li>通过下面代码来体会 key 的作用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handler&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in arr&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      arr: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handler () &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125; &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当没有设置 key 的时候</li>
</ul>
<p> 在 updateChildren 中比较子节点的时候，会做三次更新 DOM 操作和一次插入 DOM 的操作</p>
<ul>
<li>当设置 key 的时候</li>
</ul>
<p>在 updateChildren 中比较子节点的时候，因为 oldVnode 的子节点的 b,c,d 和 newVnode 的 x,b,c 的 key 相同，所以只做比较，没有更新 DOM 的操作，当遍历完毕后，会再把 x 插入到 DOM 上DOM 操 作只有一次插入操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423153542307.5o08ytgl5800.png"
                      alt="image-20210423153542307"
                ></p>
]]></content>
      <categories>
        <category>Vue源码剖析</category>
      </categories>
      <tags>
        <tag>Vue Virtual DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程与JS异步编程、手写Promise</title>
    <url>/2021/04/20/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%20JS%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E3%80%81%E6%89%8B%E5%86%99%20Promise/</url>
    <content><![CDATA[<p>概念：（Functional Programming 简称FP） 一种编程思想，对运算过程的一种抽象。</p>
<p>将程序的过程抽象成函数（数学上的函数，是某种关系的映射）。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><blockquote>
<p>函数是一等公民：函数作为参数，函数作为返回值，函数可以被一个变量存储。</p>
<p>常用的高阶函数：forEach, map,every,some…</p>
</blockquote>
<h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分装一个forEach,接收两个参数，数组，函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span> (<span class="params">array, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key) fn(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">forEach([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><blockquote>
<p>意义：可以将函数的过程抽象化，我们只需知道我们想要的结果和实现的方法。将过程抽象化。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装once接收一个函数作为入参，返回一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">once</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> done = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">      done = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> pay = once(<span class="function"><span class="keyword">function</span> (<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`支付: <span class="subst">$&#123;money&#125;</span> RMB`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">pay(<span class="number">5</span>) <span class="comment">// 只会执行一次</span></span><br><span class="line">pay(<span class="number">5</span>)</span><br><span class="line">pay(<span class="number">5</span>)</span><br><span class="line">pay(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><blockquote>
<p>概念：一种固定的输入总会得到固定的结果。</p>
</blockquote>
<blockquote>
<p>Slice: 不会改变原数组 （纯函数）。</p>
<p>splice：会改变原数组（不纯的函数）。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// [1] 纯函数</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">0</span>, <span class="number">3</span>)) <span class="comment">// [1, 2, 3] 不纯的函数</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">0</span>, <span class="number">3</span>)) <span class="comment">// [4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">0</span>, <span class="number">3</span>))	<span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h2 id="lodash-工具库"><a href="#lodash-工具库" class="headerlink" title="lodash 工具库"></a>lodash 工具库</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flowRight函数组合，curry柯里化</span></span><br><span class="line"><span class="keyword">const</span> &#123; flowRight, curry &#125; = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="comment">// fp模块</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote>
<p>概念：在一个函数内部的一个函数，内部函数可以访问到外部函数作用域内的成员变量。</p>
</blockquote>
<blockquote>
<p>优点：可以延长函数内部成员的生命周期。</p>
<p>缺点：会造成内存泄露。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个缓存区域</span></span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 入参转化成字符串</span></span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">// 存在直接取缓存，不存在就调用获取</span></span><br><span class="line">    cache[key] = cache[key] || fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">// 返回缓存数据</span></span><br><span class="line">    <span class="keyword">return</span> cache[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArea);</span><br><span class="line"><span class="keyword">const</span> fn2 = memoize(getArea)</span><br><span class="line"><span class="built_in">console</span>.log(fn2(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(fn2(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(fn2(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(fn2(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><blockquote>
<p>概念：将函数的入参的一部分先传入，传入的这部分参数固定不变，等待接收剩余参数，最后将结果返回。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要求封装一个函数使fn(1, 2, 3),fn(1, 2)(3),fn(1)(2, 3)值相等</span></span><br><span class="line"><span class="comment">// 柯里化函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断实参长度和形参长度是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (args.length &lt; fn.length) &#123;</span><br><span class="line">      <span class="comment">// 小于的话返回一个函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 将剩余的参数和初始传递参数拼接之后一起传递，返回最终的结果</span></span><br><span class="line">          <span class="keyword">return</span> curried(...args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度相等的话，直接返回最终结果</span></span><br><span class="line">    <span class="keyword">return</span> fn(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个算法函数</span></span><br><span class="line"><span class="keyword">const</span> getSum = curry(<span class="function">(<span class="params">a, b, c</span>) =&gt;</span> a + b + c)</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>



<h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><blockquote>
<p>函数组合：将其他函数进行组合，形成一个新的函数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fp模块</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="comment">// const reverse = array =&gt; array.reverse()</span></span><br><span class="line"><span class="comment">// const last = array =&gt; array[0]</span></span><br><span class="line"><span class="comment">// const toUpper = s =&gt; s.toUpperCase() </span></span><br><span class="line"><span class="comment">// const compose = (...args) =&gt; value =&gt; args.reverse().reduce((acc, fn) =&gt; fn(acc), value)</span></span><br><span class="line"><span class="comment">// 直接使用lodash的函数组合flowRight，柯里化函数toUpper，last，reverse,从右往左依次执行</span></span><br><span class="line"><span class="keyword">const</span> fn = fp.flowRight(fp.toUpper, fp.last, fp.reverse)</span><br><span class="line"><span class="built_in">console</span>.log(fn([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])); <span class="comment">// &#x27;THREE&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="函子"><a href="#函子" class="headerlink" title="函子"></a>函子</h2><blockquote>
<p>概念：特殊的容器，用来存储值和值的变形关系。</p>
</blockquote>
<h3 id="Functor函子"><a href="#Functor函子" class="headerlink" title="Functor函子"></a>Functor函子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个静态方法of用来创建实例对象</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储一个私有的值，只能在函子内部使用</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暴露一个map方法，该方法接受一个函数作为参数,返回一个处理之后的新的函子</span></span><br><span class="line">  map (fn) &#123;</span><br><span class="line">    <span class="comment">// return new Container(fn(this._value))</span></span><br><span class="line">    <span class="keyword">return</span> Container.of(fn(<span class="built_in">this</span>._value)) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const r = new Container(&#x27;one&#x27;)</span></span><br><span class="line"><span class="comment">//             .map(x =&gt; x.toUpperCase())</span></span><br><span class="line"><span class="keyword">const</span> r = Container.of(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">            .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure>

<h3 id="MayBe函子"><a href="#MayBe函子" class="headerlink" title="MayBe函子"></a>MayBe函子</h3><blockquote>
<p>处理空值的函子</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MayBe</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个静态方法of用来创建实例对象</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MayBe(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储一个私有的值，只能在函子内部使用</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露一个map方法，该方法接受一个函数作为参数,返回一个处理之后的新的函子</span></span><br><span class="line">  map (fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.isEmpty() ? MayBe.of(<span class="built_in">this</span>._value) :  MayBe.of(fn(<span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断值是否为空</span></span><br><span class="line">  isEmpty () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value === <span class="literal">null</span> || <span class="built_in">this</span>._value === <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r = MayBe.of(<span class="literal">undefined</span>)</span><br><span class="line">            .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">            </span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure>

<h3 id="Either函子"><a href="#Either函子" class="headerlink" title="Either函子"></a>Either函子</h3><blockquote>
<p>处理异常的函子</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Left</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态of</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Left(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储一个私有的值，只能在函子内部使用</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露一个map方法，该方法接受一个函数作为参数,返回本身</span></span><br><span class="line">  map (fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理正确数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Right</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态of</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Right(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储一个私有的值，只能在函子内部使用</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露一个map方法，该方法接受一个函数作为参数,返回</span></span><br><span class="line">  map (fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> Right.of(fn(<span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> left = Left.of(<span class="number">5</span>)</span><br><span class="line">              .map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> right = Right.of(<span class="number">5</span>)</span><br><span class="line">              .map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>)</span><br><span class="line"><span class="comment">// console.log(left, right);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseString</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 返回正确的结果</span></span><br><span class="line">    <span class="keyword">return</span> Right.of(<span class="built_in">JSON</span>.parse(str))</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 处理异常，返回异常信息</span></span><br><span class="line">    <span class="keyword">return</span> Left.of(&#123;  <span class="attr">error</span>: error.message&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(parseString(<span class="string">&#x27;&#123; neme: zs &#125;&#x27;</span>)); <span class="comment">// Left &#123; _value: &#123; error: &#x27;Unexpected token n in JSON at position 2&#x27; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(parseString(<span class="string">&#x27;&#123; &quot;neme&quot;: &quot;zs&quot; &#125;&#x27;</span>)); <span class="comment">// Right &#123; _value: &#123; neme: &#x27;zs&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="IO函子"><a href="#IO函子" class="headerlink" title="IO函子"></a>IO函子</h3><blockquote>
<p>内部存储一个函数，在需要时调用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IO</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态of接收一个值，返回一个函数,将来需要时在调用</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function">() =&gt;</span> x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储一个函数</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = fn</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个新的IO，为了将当前的_value和map中传入的函数组合成新的函数作为IO的参数</span></span><br><span class="line">  map (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(fp.flowRight(f, <span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IO </span></span><br><span class="line"><span class="keyword">const</span> r = IO.of(process)</span><br><span class="line">            <span class="comment">// 返回node的执行路径 &#123; _value: [Function] &#125; </span></span><br><span class="line">            .map(<span class="function"><span class="params">x</span> =&gt;</span> x.execPath)</span><br><span class="line"><span class="built_in">console</span>.log(r._value()); <span class="comment">// /usr/local/bin/node</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Task函子"><a href="#Task函子" class="headerlink" title="Task函子"></a>Task函子</h3><blockquote>
<p>函子可以处理异步</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入folktale的组合函数compose，curry</span></span><br><span class="line"><span class="keyword">const</span> &#123; compose, curry &#125; = <span class="built_in">require</span>(<span class="string">&#x27;folktale/core/lambda&#x27;</span>)</span><br><span class="line"><span class="comment">// folktale的curry</span></span><br><span class="line"><span class="keyword">const</span> f = curry(<span class="number">3</span>, <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> x + y + z)</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入lodash的fp模块的函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; toUpper, first, split, find &#125; = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fn = compose(toUpper, first)</span><br><span class="line"><span class="keyword">const</span> r = fn([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br><span class="line"><span class="comment">// 引入folktale的异函数，返回一个函子</span></span><br><span class="line"><span class="keyword">const</span> &#123; task &#125; = <span class="built_in">require</span>(<span class="string">&#x27;folktale/concurrency/task&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// task传递一个函数，参数是resolver</span></span><br><span class="line">  <span class="keyword">return</span> task(<span class="function"><span class="params">resolver</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 调用文件读取，接受三个参数，文件名，字符编码，回掉，错误优先</span></span><br><span class="line">    fs.readFile(filename, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) resolver.reject(err)</span><br><span class="line">      resolver.resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// readFile调用返回的是Task函子，调用run方法</span></span><br><span class="line">readFile(<span class="string">&#x27;package.json&#x27;</span>)</span><br><span class="line">  .map(split(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">  .map(find(<span class="function"><span class="params">x</span> =&gt;</span> x.includes(<span class="string">&#x27;version&#x27;</span>)))</span><br><span class="line">  .run()</span><br><span class="line">  <span class="comment">// 监听run方法处理的结果</span></span><br><span class="line">  .listen(&#123;</span><br><span class="line">    onRejected: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;,</span><br><span class="line">    onResolved: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Pointed函子"><a href="#Pointed函子" class="headerlink" title="Pointed函子"></a>Pointed函子</h3><blockquote>
<p>Pointed 函子是实现了 of 静态方法的函子,避免了重复使用new来构建对象。</p>
<p>of 方法用来把值放到上下文。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123; </span><br><span class="line"><span class="comment">// Point函子</span></span><br><span class="line"><span class="comment">// 作用是把值放到一个新的函子里面返回，返回的函子就是一个上下文</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Container(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Monad函子"><a href="#Monad函子" class="headerlink" title="Monad函子"></a>Monad函子</h3><blockquote>
<p>Monad 函子是可以变扁的 Pointed 函子，用来解决IO函子嵌套问题，IO(IO(x))。</p>
<p>一个函子如果具有 join 和 of 两个方法并遵守一些定律就是一个 Monad。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IO</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态of接收一个值，返回一个函数,将来需要时在调用</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储一个函数</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = fn</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新的IO，为了将当前的_value和map中传入的函数组合成新的函数作为IO的参数</span></span><br><span class="line">  map (fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(fp.flowRight(fn, <span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  join () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同时调用 map join</span></span><br><span class="line">  flatMap (fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.map(fn).join()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回一个IO函子等待调用处理</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFileSync(filename, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印上一步的IO函子</span></span><br><span class="line"><span class="keyword">const</span> print = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = readFile(<span class="string">&#x27;package.json&#x27;</span>)</span><br><span class="line">          .flatMap(print)</span><br><span class="line">          .join()</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-异步编程"><a href="#JavaScript-异步编程" class="headerlink" title="JavaScript 异步编程"></a>JavaScript 异步编程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>JavaScript 语言的执行环境是单线程的，一次只能执行一个任务，多任务需要排队等候，这种模式可能会阻塞代码，导致代码执行效率低下。为了避免这个问题，出现了异步编程。一般是通过 callback 回调函数、事件发布/订阅、Promise 等来组织代码，本质都是通过回调函数来实现异步代码的存放与执行。</li>
</ul>
<h2 id="EventLoop-事件环和消息队列"><a href="#EventLoop-事件环和消息队列" class="headerlink" title="EventLoop 事件环和消息队列"></a>EventLoop 事件环和消息队列</h2><ul>
<li><strong>EventLoop</strong> 是一种循环机制 ，不断去轮询一些队列 ，从中找到 需要执行的任务并按顺序执行的一个执行模型。</li>
<li><strong>消息队列</strong> 是用来存放宏任务的队列， 比如定时器时间到了， 定时间内传入的方法引用会存到该队列， ajax回调之后的执行方法也会存到该队列。</li>
</ul>
<p>![image-20210422130003619](/Users/wkxk/Library/Application Support/typora-user-images/image-20210422130003619.png)</p>
<blockquote>
<p>一开始整个脚本作为一个宏任务执行。执行过程中同步代码直接执行，宏任务等待时间到达或者成功后，将方法的回调放入宏任务队列中，微任务进入微任务队列。</p>
<p>当前主线程的宏任务执行完出队，检查并清空微任务队列。接着执行浏览器 UI 线程的渲染工作，检查web worker 任务，有则执行。</p>
<p>然后再取出一个宏任务执行。以此循环…</p>
</blockquote>
<h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h2><ul>
<li><p><strong>宏任务</strong>可以理解为每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</p>
<ul>
<li>浏览器为了让 JS 内部宏任务 与 DOM 操作能够有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始前，对页面进行重新渲染。</li>
<li>宏任务包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、MessageChannel 等</li>
</ul>
</li>
<li><p><strong>微任务</strong>可以理解是在当前任务执行结束后需要立即执行的任务。也就是说，在当前任务后，在渲染之前，执行清空微任务。</p>
<p>所以它的响应速度相比宏任务会更快，因为无需等待 UI 渲染。</p>
<ul>
<li>微任务包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)等</li>
</ul>
</li>
</ul>
<h2 id="Promise手写实现"><a href="#Promise手写实现" class="headerlink" title="Promise手写实现"></a>Promise手写实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"><span class="comment">// 完成状态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line"><span class="comment">// 失败状态</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步执行方法封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncExecFun</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> fn(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行promise resolve功能</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, res, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回同一个promise</span></span><br><span class="line">  <span class="keyword">if</span> (promise === res) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise #&lt;MyPromise&gt;&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// promise结果</span></span><br><span class="line">  <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    res.then(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非promise结果</span></span><br><span class="line">    resolve(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 是个构造函数</span></span><br><span class="line"><span class="comment"> * 2. 传入一个可执行函数 函数的入参第一个为 fullFill函数 第二个为 reject函数；  函数立即执行，  参数函数异步执行</span></span><br><span class="line"><span class="comment"> * 3. 状态一旦更改就不可以变更  只能 pending =&gt; fulfilled 或者  pending =&gt; rejected</span></span><br><span class="line"><span class="comment"> * 4. then 的时候要处理入参的情况 successCallback 和failCallback 均可能为非函数</span></span><br><span class="line"><span class="comment"> *      默认的 failCallback 一定要将异常抛出， 这样下一个promise便可将其捕获 异常冒泡的目的</span></span><br><span class="line"><span class="comment"> * 5. then 中执行回调的时候要捕获异常 将其传给下一个promise</span></span><br><span class="line"><span class="comment"> *    如果promise状态未变更 则将回调方法添加到对应队列中</span></span><br><span class="line"><span class="comment"> *    如果promise状态已经变更 需要异步处理成功或者失败回调</span></span><br><span class="line"><span class="comment"> *    因为可能出现 回调结果和当前then返回的Promise一致 从而导致死循环问题</span></span><br><span class="line"><span class="comment"> * 6. catch只是then的一种特殊的写法 方便理解和使用</span></span><br><span class="line"><span class="comment"> * 7. finally 特点 1. 不过resolve或者reject都会执行</span></span><br><span class="line"><span class="comment"> *                2. 回调没有参数</span></span><br><span class="line"><span class="comment"> *                3. 返回一个Promise 且值可以穿透到下一个then或者catch</span></span><br><span class="line"><span class="comment"> * 8. Promise.resolve, Promise.reject 根据其参数返回对应的值 或者状态的Promise即可</span></span><br><span class="line"><span class="comment"> * 9. Proise.all 特点  1. 返回一个Promise</span></span><br><span class="line"><span class="comment"> *                    2. 入参是数组 resolve的情况下出参也是数组 且结果顺序和调用顺序一致</span></span><br><span class="line"><span class="comment"> *                    3. 所有的值或者promise都完成才能resolve 所有要计数</span></span><br><span class="line"><span class="comment"> *                    4. 只要有一个为reject 返回的Promise便reject</span></span><br><span class="line"><span class="comment"> * 10. Proise.race 特点 1. 返回一个Promise</span></span><br><span class="line"><span class="comment"> *                    2. 入参是数组 那么出参根据第一个成功或者失败的参数来确定</span></span><br><span class="line"><span class="comment"> *                    3. 只要有一个resolve 或者reject 便更改返回Promise的状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  status = PENDING;</span><br><span class="line">  value = <span class="literal">undefined</span>;</span><br><span class="line">  reason = <span class="literal">undefined</span>;</span><br><span class="line">  successCallbacks = [];</span><br><span class="line">  failCallbacks = [];</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">exector</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 立即执行传入参数</span></span><br><span class="line">    <span class="comment">// 参数直接写为 this.resolve  会导致函数内 this指向会发生改变</span></span><br><span class="line">    <span class="comment">// 异步执行状态变更</span></span><br><span class="line">    <span class="comment">// 捕获执行器的异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        exector(</span><br><span class="line">          (value) =&gt; asyncExecFun(<span class="function">() =&gt;</span> <span class="built_in">this</span>.resolve(value)),</span><br><span class="line">          (reason) =&gt; asyncExecFun(<span class="function">() =&gt;</span> <span class="built_in">this</span>.reject(reason))</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">this</span>.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果状态已经变更则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">    <span class="comment">// 执行所有成功回调</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.successCallbacks.length) <span class="built_in">this</span>.successCallbacks.shift()();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果状态已经变更则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.reason = reason;</span><br><span class="line">    <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.failCallbacks.length)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;(in MyPromise)&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行所有失败回调</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.failCallbacks.length) <span class="built_in">this</span>.failCallbacks.shift()();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">successCallback, failCallback</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 成功函数处理 忽略函数之外的其他值</span></span><br><span class="line">    successCallback =</span><br><span class="line">      <span class="keyword">typeof</span> successCallback == <span class="string">&quot;function&quot;</span> ? successCallback : <span class="function">(<span class="params">v</span>) =&gt;</span> v;</span><br><span class="line">    <span class="comment">// 失败函数处理 忽略函数之外的其他值 抛出异常  实现catch冒泡的关键</span></span><br><span class="line">    failCallback =</span><br><span class="line">      <span class="keyword">typeof</span> failCallback == <span class="string">&quot;function&quot;</span></span><br><span class="line">        ? failCallback</span><br><span class="line">        : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 统一异常处理逻辑</span></span><br><span class="line">      <span class="keyword">const</span> execFun = <span class="function">(<span class="params">fn, val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> res = fn(val);</span><br><span class="line">          resolvePromise(promise, res, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 执行成功回调</span></span><br><span class="line">      <span class="keyword">const</span> execSuccessCallback = <span class="function">() =&gt;</span> execFun(successCallback, <span class="built_in">this</span>.value);</span><br><span class="line">      <span class="comment">// 执行失败回调</span></span><br><span class="line">      <span class="keyword">const</span> execFailCallback = <span class="function">() =&gt;</span> execFun(failCallback, <span class="built_in">this</span>.reason);</span><br><span class="line">      <span class="comment">// 同步将对应成功或者失败回调事件加入对应回调队列</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 将成功回调加入队列</span></span><br><span class="line">        <span class="built_in">this</span>.successCallbacks.push(execSuccessCallback);</span><br><span class="line">        <span class="comment">// 讲失败回调加入队列</span></span><br><span class="line">        <span class="built_in">this</span>.failCallbacks.push(execFailCallback);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 延迟执行 可以将函数执行结果和当前then 返回的promise 进行比较</span></span><br><span class="line">      asyncExecFun(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经 fulfilled 可直接调用成功回调方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">          execSuccessCallback();</span><br><span class="line">          <span class="comment">// 如果已经 rejected 可直接调用失败回调方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">          execFailCallback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(failCallback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, failCallback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">finally</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">      <span class="comment">// 穿透正常值</span></span><br><span class="line">      (value) =&gt; MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">      (reason) =&gt;</span><br><span class="line">        MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 穿透异常信息</span></span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 否则返回一个 MyPromise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (reason <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> reason;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 否则返回一个 MyPromise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">array</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 存储结果</span></span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">// 存储数组长度</span></span><br><span class="line">    <span class="keyword">let</span> len = array.length;</span><br><span class="line">    <span class="comment">// 创建返回MyPromise</span></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 定义当前MyPromise的索引</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 添加数据的公用方法</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">addData</span>(<span class="params">key, data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        result[key] = data;</span><br><span class="line">        <span class="comment">// 索引递增</span></span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">// 全部执行完则resolve</span></span><br><span class="line">        <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 按顺序变量数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = array[i];</span><br><span class="line">        <span class="comment">// 如果是MyPromise则 按其规则处理</span></span><br><span class="line">        <span class="keyword">if</span> (curr <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          curr.then(<span class="function">(<span class="params">value</span>) =&gt;</span> addData(i, value), reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 非MyPromise直接赋值</span></span><br><span class="line">          addData(i, curr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 返回新的MyPromise实例</span></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只要有一个成功或者失败就返回</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">array</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = array[i];</span><br><span class="line">        <span class="comment">// MyPromise实例 结果处理</span></span><br><span class="line">        <span class="keyword">if</span> (curr <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          curr.then(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 非MyPromise实例处理</span></span><br><span class="line">          resolve(curr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MyPromise;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaScript高阶用法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Snabbdom深入剖析</title>
    <url>/2021/04/23/Snabbdom%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h2 id="什么是-Virtual-DOM"><a href="#什么是-Virtual-DOM" class="headerlink" title="什么是 Virtual DOM"></a>什么是 Virtual DOM</h2><ul>
<li><p>**Virtual DOM(虚拟 DOM)**，是由普通的 JS 对象来描述 DOM 对象，因为不是真实的 DOM 对象，所以叫 Virtual DOM</p>
</li>
<li><p>真实 DOM 成员</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> element) &#123;</span><br><span class="line">  s += key + <span class="string">&#x27;,&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br></pre></td></tr></table></figure></li>
<li><p>可以使用 Virtual DOM 来描述真实 DOM，示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  sel: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  children: <span class="literal">undefined</span>,</span><br><span class="line">  text: <span class="string">&quot;Hello Virtual DOM&quot;</span>,</span><br><span class="line">  elm: <span class="literal">undefined</span>,</span><br><span class="line">  key: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="为什么使用-Virtual-DOM"><a href="#为什么使用-Virtual-DOM" class="headerlink" title="为什么使用 Virtual DOM"></a>为什么使用 Virtual DOM</h2><ul>
<li>手动操作 DOM 比较麻烦，还需要考虑浏览器兼容性问题，虽然有 jQuery 等库简化 DOM 操作，但是随着项目的复杂 DOM 操作复杂提升</li>
<li>为了简化 DOM 的复杂操作于是出现了各种 MVVM 框架，MVVM 框架解决了视图和状态的同步问题</li>
<li>为了简化视图的操作我们可以使用模板引擎，但是模板引擎没有解决跟踪状态变化的问题，于是 Virtual DOM 出现了</li>
<li>Virtual DOM 的好处是当状态改变时不需要立即更新 DOM，只需要创建一个虚拟树来描述 DOM， Virtual DOM 内部将弄清楚如何有效(diff)的更新 DOM</li>
<li>参考 github 上 <a class="link"   href="https://github.com/Matt-Esch/virtual-dom" >virtual-dom<i class="fas fa-external-link-alt"></i></a> 的描述<ul>
<li>虚拟 DOM 可以维护程序的状态，跟踪上一次的状态</li>
<li>通过比较前后两次状态的差异更新真实 DOM</li>
</ul>
</li>
</ul>
<h2 id="虚拟-DOM-的作用"><a href="#虚拟-DOM-的作用" class="headerlink" title="虚拟 DOM 的作用"></a>虚拟 DOM 的作用</h2><ul>
<li><p>维护视图和状态的关系</p>
</li>
<li><p>复杂视图情况下提升渲染性能</p>
</li>
<li><p>除了渲染 DOM 以外，还可以实现 SSR(Nuxt.js/Next.js)、原生应用(Weex/React Native)、小程序(mpvue/uni-app)等</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20200102104642121.28drvtzb97rw.png"
                      alt="image-20200102104642121"
                ></p>
</li>
</ul>
<h2 id="Virtual-DOM-库"><a href="#Virtual-DOM-库" class="headerlink" title="Virtual DOM 库"></a>Virtual DOM 库</h2><ul>
<li><p><a class="link"   href="https://github.com/snabbdom/snabbdom" >Snabbdom<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li>Vue 2.x 内部使用的 Virtual DOM 就是改造的 Snabbdom</li>
<li>大约 200 SLOC（single line of code）</li>
<li>通过模块可扩展</li>
<li>源码使用 TypeScript 开发</li>
<li>最快的 Virtual DOM 之一</li>
</ul>
</li>
<li><p><a class="link"   href="https://github.com/Matt-Esch/virtual-dom" >virtual-dom<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><ul>
<li><a class="link"   href="https://codesandbox.io/s/jq-demo-5i7qp" >jQuery-demo<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://codesandbox.io/s/snabbdom-demo-4hbyb" >snabbdom-demo<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
</ul>
<h1 id="Snabbdom-基本使用"><a href="#Snabbdom-基本使用" class="headerlink" title="Snabbdom 基本使用"></a>Snabbdom 基本使用</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul>
<li><p>打包工具为了方便使用 <a class="link"   href="https://parceljs.org/getting_started.html" >parcel<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>创建项目，并安装 <a class="link"   href="https://parceljs.org/getting_started.html" >parcel<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建项目目录</span></span><br><span class="line">md snabbdom-demo</span><br><span class="line"><span class="comment"># 进入项目目录</span></span><br><span class="line"><span class="built_in">cd</span> snabbdom-demo</span><br><span class="line"><span class="comment"># 创建 package.json</span></span><br><span class="line">npm init -y</span><br><span class="line"><span class="comment"># 本地安装 parcel</span></span><br><span class="line">npm install parcel-bundler -D</span><br></pre></td></tr></table></figure></li>
<li><p>配置 package.json 的 scripts</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;parcel index.html --open&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;parcel build index.html&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建目录结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">│  index.html</span><br><span class="line">│  package.json</span><br><span class="line">└─src</span><br><span class="line">		<span class="number">01</span>-basicusage.js</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="导入-Snabbdom"><a href="#导入-Snabbdom" class="headerlink" title="导入 Snabbdom"></a>导入 Snabbdom</h2><h2 id="Snabbdom-文档"><a href="#Snabbdom-文档" class="headerlink" title="Snabbdom 文档"></a>Snabbdom 文档</h2><ul>
<li><p>看文档的意义</p>
<ul>
<li>学习任何一个库都要先看文档</li>
<li>通过文档了解库的作用</li>
<li>看文档中提供的示例，自己快速实现一个 demo</li>
<li>通过文档查看 API 的使用</li>
</ul>
</li>
<li><p>文档地址</p>
<ul>
<li><a class="link"   href="https://github.com/snabbdom/snabbdom" >https://github.com/snabbdom/snabbdom<i class="fas fa-external-link-alt"></i></a></li>
<li>当前版本 v2.1.0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># --depth 表示克隆深度, 1 表示只克隆最新的版本. 因为如果项目迭代的版本很多, 克隆会很慢</span><br><span class="line">git clone -b v2.1.0 --depth&#x3D;1 https:&#x2F;&#x2F;github.com&#x2F;snabbdom&#x2F;snabbdom.git</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="安装-Snabbdom"><a href="#安装-Snabbdom" class="headerlink" title="安装  Snabbdom"></a>安装  Snabbdom</h3><ul>
<li><p>安装 Snabbdom</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install snabbdom@2.1.0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="导入-Snabbdom-1"><a href="#导入-Snabbdom-1" class="headerlink" title="导入  Snabbdom"></a>导入  Snabbdom</h3><ul>
<li>Snabbdom 的两个核心函数 init 和 h() <ul>
<li>init() 是一个高阶函数，返回 patch() </li>
<li>h() 返回虚拟节点 VNode，这个函数我们在使用 Vue.js 的时候见过</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; init &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/init&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/h&#x27;</span></span><br><span class="line"><span class="keyword">const</span> patch = init([])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：此时运行的话会告诉我们找不到 init / h 模块，因为模块路径并不是 snabbdom/int，这个路径是在 package.json 中的 exports 字段设置的，而我们使用的打包工具不支持 exports 这个字段，webpack 4 也不支持，webpack 5 支持该字段。该字段在导入 snabbdom/init 的时候会补全路径成 snabbdom/build/package/init.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./init&quot;</span>: <span class="string">&quot;./build/package/init.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./h&quot;</span>: <span class="string">&quot;./build/package/h.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./helpers/attachto&quot;</span>: <span class="string">&quot;./build/package/helpers/attachto.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./hooks&quot;</span>: <span class="string">&quot;./build/package/hooks.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./htmldomapi&quot;</span>: <span class="string">&quot;./build/package/htmldomapi.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./is&quot;</span>: <span class="string">&quot;./build/package/is.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./jsx&quot;</span>: <span class="string">&quot;./build/package/jsx.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./modules/attributes&quot;</span>: <span class="string">&quot;./build/package/modules/attributes.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./modules/class&quot;</span>: <span class="string">&quot;./build/package/modules/class.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./modules/dataset&quot;</span>: <span class="string">&quot;./build/package/modules/dataset.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./modules/eventlisteners&quot;</span>: <span class="string">&quot;./build/package/modules/eventlisteners.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./modules/hero&quot;</span>: <span class="string">&quot;./build/package/modules/hero.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./modules/module&quot;</span>: <span class="string">&quot;./build/package/modules/module.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./modules/props&quot;</span>: <span class="string">&quot;./build/package/modules/props.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./modules/style&quot;</span>: <span class="string">&quot;./build/package/modules/style.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./thunk&quot;</span>: <span class="string">&quot;./build/package/thunk.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./tovnode&quot;</span>: <span class="string">&quot;./build/package/tovnode.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;./vnode&quot;</span>: <span class="string">&quot;./build/package/vnode.js&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果使用不支持 package.json 的 exports 字段的打包工具，我们应该把模块的路径写全<ul>
<li>查看安装的 snabbdom 的目录结构</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/h&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; init &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/init&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; classModule &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/modules/class&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>回顾 Vue 中的 render 函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>thunk() 是一种优化策略，可以在处理不可变数据时使用</li>
</ul>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/h&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; init &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/init&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 init() 函数创建 patch()</span></span><br><span class="line"><span class="comment">// init() 的参数是数组，将来可以传入模块，处理属性/样式/事件等</span></span><br><span class="line"><span class="keyword">let</span> patch = init([])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 h() 函数创建 vnode</span></span><br><span class="line"><span class="keyword">let</span> vnode = h(<span class="string">&#x27;div.cls&#x27;</span>, [</span><br><span class="line">  h(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;Hello Snabbdom&#x27;</span>),</span><br><span class="line">  h(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;这是段落&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// 把 vnode 渲染到空的 DOM 元素（替换）</span></span><br><span class="line"><span class="comment">// 会返回新的 vnode</span></span><br><span class="line"><span class="keyword">let</span> oldVnode = patch(app, vnode)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  vnode = h(<span class="string">&#x27;div.cls&#x27;</span>, [</span><br><span class="line">    h(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;Hello World&#x27;</span>),</span><br><span class="line">    h(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;这是段落&#x27;</span>)</span><br><span class="line">  ])</span><br><span class="line">  <span class="comment">// 把老的视图更新到新的状态</span></span><br><span class="line">  oldVnode = patch(oldVnode, vnode)</span><br><span class="line">  <span class="comment">// h(&#x27;!&#x27;) 是创建注释</span></span><br><span class="line">  patch(oldVnode, h(<span class="string">&#x27;!&#x27;</span>))</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>Snabbdom 的核心库并不能处理 DOM 元素的属性/样式/事件等，如果需要处理的话，可以使用模块</p>
<h3 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h3><ul>
<li>官方提供了 6 个模块<ul>
<li>attributes<ul>
<li>设置 DOM 元素的属性，使用 <code>setAttribute</code>()</li>
<li>处理布尔类型的属性</li>
</ul>
</li>
<li>props<ul>
<li>和 <code>attributes</code> 模块相似，设置 DOM 元素的属性 <code>element[attr] = value</code></li>
<li>不处理布尔类型的属性</li>
</ul>
</li>
<li>class<ul>
<li>切换类样式</li>
<li>注意：给元素设置类样式是通过 <code>sel</code> 选择器</li>
</ul>
</li>
<li>dataset<ul>
<li>设置 <code>data-*</code> 的自定义属性</li>
</ul>
</li>
<li>eventlisteners<ul>
<li>注册和移除事件</li>
</ul>
</li>
<li>style<ul>
<li>设置行内样式，支持动画</li>
<li>delayed/remove/destroy</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h3><ul>
<li>模块使用步骤：<ul>
<li>导入需要的模块</li>
<li>init() 中注册模块</li>
<li>使用 h() 函数创建 VNode 的时候，可以把第二个参数设置为对象，其他参数往后移</li>
</ul>
</li>
</ul>
<h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/h&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; init &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/init&#x27;</span></span><br><span class="line"><span class="comment">// 导入需要的模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; styleModule &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/modules/style&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventListenersModule &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/modules/eventlisteners&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 init() 函数创建 patch()</span></span><br><span class="line"><span class="comment">// init() 的参数是数组，将来可以传入模块，处理属性/样式/事件等</span></span><br><span class="line"><span class="keyword">let</span> patch = init([</span><br><span class="line">  <span class="comment">// 注册模块</span></span><br><span class="line">  styleModule,</span><br><span class="line">  eventListenersModule</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 h() 函数创建 vnode</span></span><br><span class="line"><span class="keyword">let</span> vnode = h(<span class="string">&#x27;div.cls&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 设置 DOM 元素的行内样式</span></span><br><span class="line">  style: &#123; <span class="attr">color</span>: <span class="string">&#x27;#DEDEDE&#x27;</span>, <span class="attr">backgroundColor</span>: <span class="string">&#x27;#181A1B&#x27;</span> &#125;,</span><br><span class="line">  <span class="comment">// 注册事件</span></span><br><span class="line">  on: &#123; <span class="attr">click</span>: clickHandler &#125;</span><br><span class="line">&#125;, [</span><br><span class="line">  h(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;Hello Snabbdom&#x27;</span>),</span><br><span class="line">  h(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;这是段落&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clickHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此处的 this 指向对应的 vnode</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.elm.innerHTML)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Snabbdom-源码解析"><a href="#Snabbdom-源码解析" class="headerlink" title="Snabbdom 源码解析"></a>Snabbdom 源码解析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="如何学习源码"><a href="#如何学习源码" class="headerlink" title="如何学习源码"></a>如何学习源码</h3><ul>
<li>先宏观了解</li>
<li>带着目标看源码</li>
<li>看源码的过程要不求甚解</li>
<li>调试</li>
<li>参考资料</li>
</ul>
<h3 id="Snabbdom-的核心"><a href="#Snabbdom-的核心" class="headerlink" title="Snabbdom 的核心"></a>Snabbdom 的核心</h3><ul>
<li>使用 h() 函数创建 JavaScript 对象(VNode)描述真实 DOM</li>
<li>init() 设置模块，创建 patch()</li>
<li>patch() 比较新旧两个 VNode</li>
<li>把变化的内容更新到真实 DOM 树上</li>
</ul>
<h3 id="Snabbdom-源码"><a href="#Snabbdom-源码" class="headerlink" title="Snabbdom 源码"></a>Snabbdom 源码</h3><ul>
<li><p>源码地址：</p>
<ul>
<li><a class="link"   href="https://github.com/snabbdom/snabbdom" >https://github.com/snabbdom/snabbdom<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
<li><p>src 目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── package</span><br><span class="line">│   ├── helpers</span><br><span class="line">│   │   └── attachto.ts   定义了 vnode.ts 中 AttachData 的数据结构</span><br><span class="line">│   ├── modules</span><br><span class="line">│   │   ├── attributes.ts</span><br><span class="line">│   │   ├── class.ts</span><br><span class="line">│   │   ├── dataset.ts</span><br><span class="line">│   │   ├── eventlisteners.ts</span><br><span class="line">│   │   ├── hero.ts       example 中使用到的自定义钩子</span><br><span class="line">│   │   ├── module.ts     定义了模块中用到的钩子函数</span><br><span class="line">│   │   ├── props.ts</span><br><span class="line">│   │   └── style.ts</span><br><span class="line">│   ├── h.ts              h() 函数，用来创建 VNode</span><br><span class="line">│   ├── hooks.ts          所有钩子函数的定义</span><br><span class="line">│   ├── htmldomapi.ts     对 DOM API 的包装</span><br><span class="line">│   ├── init.ts           加载 modules、DOMAPI，返回 patch 函数</span><br><span class="line">│   ├── is.ts             判断数组和原始值的函数</span><br><span class="line">│   ├── jsx-global.ts     jsx 的类型声明文件</span><br><span class="line">│   ├── jsx.ts            处理 jsx</span><br><span class="line">│   ├── thunk.ts          优化处理，对复杂视图不可变值得优化</span><br><span class="line">│   ├── tovnode.ts        DOM 转换成 VNode</span><br><span class="line">│   ├── ts-transform-js-extension.cjs</span><br><span class="line">│   ├── tsconfig.json     ts 的编译配置文件</span><br><span class="line">│   └── vnode.ts          虚拟节点定义</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="h-函数"><a href="#h-函数" class="headerlink" title="h 函数"></a>h 函数</h2><ul>
<li><p>h() 函数介绍</p>
<ul>
<li><p>在使用 Vue 的时候见过 h() 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure></li>
<li><p>h() 函数最早见于 <a class="link"   href="https://github.com/hyperhype/hyperscript" >hyperscript<i class="fas fa-external-link-alt"></i></a>，使用 JavaScript 创建超文本</p>
</li>
<li><p>Snabbdom 中的 h() 函数不是用来创建超文本，而是创建 VNode</p>
</li>
</ul>
</li>
<li><p>函数重载</p>
<ul>
<li><p>概念</p>
<ul>
<li><strong>参数个数</strong>或<strong>类型</strong>不同的函数</li>
<li>JavaScript 中没有重载的概念</li>
<li>TypeScript 中有重载，不过重载的实现还是通过代码调整参数</li>
</ul>
</li>
<li><p>重载的示意</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: number, b: number</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: number, b: number, c: number</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b + c)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: number, b: number</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a: number, b: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>源码位置：src/package/h.ts</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h 函数的重载</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span> (<span class="params">sel: string</span>): <span class="title">VNode</span></span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span> (<span class="params">sel: string, data: VNodeData | <span class="literal">null</span></span>): <span class="title">VNode</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="title">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span> (<span class="params">sel: string, children: VNodeChildren</span>): <span class="title">VNode</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="title">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span> (<span class="params">sel: string, data: VNodeData | <span class="literal">null</span>, children: VNodeChildren</span>): <span class="title">VNode</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="title">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span> (<span class="params">sel: any, b?: any, c?: any</span>): <span class="title">VNode</span> </span>&#123;</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function">  <span class="title">var</span> <span class="title">data</span>: <span class="title">VNodeData</span> = </span>&#123;&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">  <span class="title">var</span> <span class="title">children</span>: <span class="title">any</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">  <span class="title">var</span> <span class="title">text</span>: <span class="title">any</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">  <span class="title">var</span> <span class="title">i</span>: <span class="title">number</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">  // 处理参数，实现重载的机制</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">  <span class="title">if</span> (<span class="params">c !== <span class="literal">undefined</span></span>) </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">    // 处理三个参数的情况</span></span></span><br><span class="line"><span class="function"><span class="function">    // <span class="title">sel</span>、<span class="title">data</span>、<span class="title">children</span>/<span class="title">text</span></span></span></span><br><span class="line"><span class="function"><span class="function">    <span class="title">if</span> (<span class="params">b !== <span class="literal">null</span></span>) </span>&#123;</span></span><br><span class="line"><span class="function">      <span class="title">data</span> = <span class="title">b</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="title">if</span> (<span class="params">is.array(c)</span>) </span>&#123;</span><br><span class="line">      children = c</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(c)) &#123;</span><br><span class="line">      text = c</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &amp;&amp; c.sel) &#123;</span><br><span class="line">      children = [c]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b !== <span class="literal">undefined</span> &amp;&amp; b !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is.array(b)) &#123;</span><br><span class="line">      children = b</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(b)) &#123;</span><br><span class="line">      <span class="comment">// 如果 c 是字符串或者数字</span></span><br><span class="line">      text = b</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &amp;&amp; b.sel) &#123;</span><br><span class="line">      <span class="comment">// 如果 b 是 VNode</span></span><br><span class="line">      children = [b]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; data = b &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (children !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 children 中的原始值(string/number)</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">      <span class="comment">// 如果 child 是 string/number，创建文本节点</span></span><br><span class="line">      <span class="keyword">if</span> (is.primitive(children[i])) children[i] = vnode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, children[i], <span class="literal">undefined</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    sel[<span class="number">0</span>] === <span class="string">&#x27;s&#x27;</span> &amp;&amp; sel[<span class="number">1</span>] === <span class="string">&#x27;v&#x27;</span> &amp;&amp; sel[<span class="number">2</span>] === <span class="string">&#x27;g&#x27;</span> &amp;&amp;</span><br><span class="line">    (sel.length === <span class="number">3</span> || sel[<span class="number">3</span>] === <span class="string">&#x27;.&#x27;</span> || sel[<span class="number">3</span>] === <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 如果是 svg，添加命名空间</span></span><br><span class="line">    addNS(data, children, sel)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回 VNode</span></span><br><span class="line">  <span class="keyword">return</span> vnode(sel, data, children, text, <span class="literal">undefined</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h2><ul>
<li>一个 VNode 就是一个虚拟节点用来描述一个 DOM 元素，如果这个 VNode 有 children 就是 Virtual DOM </li>
<li>源码位置：src/package/vnode.ts</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface VNode &#123;</span><br><span class="line">  <span class="comment">// 选择器</span></span><br><span class="line">  sel: string | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 节点数据：属性/样式/事件等</span></span><br><span class="line">  data: VNodeData | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 子节点，和 text 只能互斥</span></span><br><span class="line">  children: <span class="built_in">Array</span>&lt;VNode | string&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 记录 vnode 对应的真实 DOM</span></span><br><span class="line">  elm: Node | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 节点中的内容，和 children 只能互斥</span></span><br><span class="line">  text: string | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 优化用</span></span><br><span class="line">  key: Key | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">vnode</span> (<span class="params">sel: string | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      data: any | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      children: <span class="built_in">Array</span>&lt;VNode | string&gt; | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      text: string | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      elm: Element | Text | <span class="literal">undefined</span></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = data === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : data.key</span><br><span class="line">  <span class="keyword">return</span> &#123; sel, data, children, text, elm, key &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="snabbdom"><a href="#snabbdom" class="headerlink" title="snabbdom"></a>snabbdom</h2><ul>
<li>patch(oldVnode, newVnode)</li>
<li>打补丁，把新节点中变化的内容渲染到真实 DOM，最后返回新节点作为下一次处理的旧节点</li>
<li>对比新旧 VNode 是否相同节点(节点的 key 和 sel 相同)</li>
<li>如果不是相同节点，删除之前的内容，重新渲染</li>
<li>如果是相同节点，再判断新的 VNode 是否有 text，如果有并且和 oldVnode 的 text 不同，直接更新文本内容</li>
<li>如果新的 VNode 有 children，判断子节点是否有变化，判断子节点的过程使用的就是 diff 算法</li>
<li>diff 过程只进行同层级比较</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20200102103653779.2xk8fi4x8tg0.png"
                      alt="image-20200102103653779"
                ></p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><ul>
<li><p><strong>功能：</strong>init(modules, domApi)，返回 patch() 函数（高阶函数）</p>
</li>
<li><p>为什么要使用高阶函数？</p>
<ul>
<li>因为 patch() 函数再外部会调用多次，每次调用依赖一些参数，比如：modules/domApi/cbs</li>
<li>通过高阶函数让 init() 内部形成闭包，返回的 patch() 可以访问到 modules/domApi/cbs，而不需要重新创建</li>
</ul>
</li>
<li><p>init() 在返回 patch() 之前，首先收集了所有模块中的钩子函数存储到 cbs 对象中</p>
</li>
<li><p>源码位置：src/package/init.ts</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hooks: <span class="built_in">Array</span>&lt;keyof Module&gt; = [<span class="string">&#x27;create&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;remove&#x27;</span>, <span class="string">&#x27;destroy&#x27;</span>, <span class="string">&#x27;pre&#x27;</span>, <span class="string">&#x27;post&#x27;</span>]</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span> (<span class="params">modules: <span class="built_in">Array</span>&lt;Partial&lt;Module&gt;&gt;, domApi?: DOMAPI</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i: number</span><br><span class="line">  <span class="keyword">let</span> j: number</span><br><span class="line">  <span class="keyword">const</span> cbs: ModuleHooks = &#123;</span><br><span class="line">    create: [],</span><br><span class="line">    update: [],</span><br><span class="line">    remove: [],</span><br><span class="line">    destroy: [],</span><br><span class="line">    pre: [],</span><br><span class="line">    post: []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化 api</span></span><br><span class="line">  <span class="keyword">const</span> api: DOMAPI = domApi !== <span class="literal">undefined</span> ? domApi : htmlDomApi</span><br><span class="line">  <span class="comment">// 把传入的所有模块的钩子方法，统一存储到 cbs 对象中</span></span><br><span class="line">  <span class="comment">// 最终构建的 cbs 对象的形式 cbs = [ create: [fn1, fn2], update: [], ... ]</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hooks.length; ++i) &#123;</span><br><span class="line">    <span class="comment">// cbs[&#x27;create&#x27;] = []</span></span><br><span class="line">    cbs[hooks[i]] = []</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; modules.length; ++j) &#123;</span><br><span class="line">      <span class="comment">// const hook = modules[0][&#x27;create&#x27;]</span></span><br><span class="line">      <span class="keyword">const</span> hook = modules[j][hooks[i]]</span><br><span class="line">      <span class="keyword">if</span> (hook !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        (cbs[hooks[i]] <span class="keyword">as</span> any[]).push(hook)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode: VNode | Element, vnode: VNode</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><ul>
<li><p><strong>功能：</strong></p>
<ul>
<li>传入新旧 VNode，对比差异，把差异渲染到 DOM</li>
<li>返回新的 VNode，作为下一次 patch() 的 oldVnode</li>
</ul>
</li>
<li><p><strong>执行过程：</strong></p>
<ul>
<li>首先执行<strong>模块</strong>中的<strong>钩子</strong>函数 <code>pre</code></li>
<li>如果 oldVnode 和 vnode 相同（key 和 sel 相同）<ul>
<li>调用 patchVnode()，找节点的差异并更新 DOM</li>
</ul>
</li>
<li>如果 oldVnode 是 DOM 元素<ul>
<li>把 DOM 元素转换成 oldVnode</li>
<li>调用 createElm() 把 vnode 转换为真实 DOM，记录到 vnode.elm</li>
<li>把刚创建的 DOM 元素插入到 parent 中</li>
<li>移除老节点</li>
<li>触发<strong>用户</strong>设置的 <code>create</code> <strong>钩子</strong>函数</li>
</ul>
</li>
</ul>
</li>
<li><p>源码位置：src/package/init.ts</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode: VNode | Element, vnode: VNode</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i: number, <span class="attr">elm</span>: Node, <span class="attr">parent</span>: Node</span><br><span class="line">  <span class="comment">// 保存新插入节点的队列，为了触发钩子函数</span></span><br><span class="line">  <span class="keyword">const</span> insertedVnodeQueue: VNodeQueue = []</span><br><span class="line">  <span class="comment">// 执行模块的 pre 钩子函数</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.pre.length; ++i) cbs.pre[i]()</span><br><span class="line">  <span class="comment">// 如果 oldVnode 不是 VNode，创建 VNode 并设置 elm </span></span><br><span class="line">  <span class="keyword">if</span> (!isVnode(oldVnode)) &#123;</span><br><span class="line">    <span class="comment">// 把 DOM 元素转换成空的 VNode</span></span><br><span class="line">    oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果新旧节点是相同节点(key 和 sel 相同)</span></span><br><span class="line">  <span class="keyword">if</span> (sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">    <span class="comment">// 找节点的差异并更新 DOM</span></span><br><span class="line">    patchVnode(oldVnode, vnode, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果新旧节点不同，vnode 创建对应的 DOM</span></span><br><span class="line">    <span class="comment">// 获取当前的 DOM 元素</span></span><br><span class="line">    elm = oldVnode.elm!</span><br><span class="line">    parent = api.parentNode(elm) <span class="keyword">as</span> Node</span><br><span class="line">    <span class="comment">// 触发 init/create 钩子函数,创建 DOM</span></span><br><span class="line">    createElm(vnode, insertedVnodeQueue)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果父节点不为空，把 vnode 对应的 DOM 插入到文档中</span></span><br><span class="line">      api.insertBefore(parent, vnode.elm!, api.nextSibling(elm))</span><br><span class="line">      <span class="comment">// 移除老节点</span></span><br><span class="line">      removeVnodes(parent, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行用户设置的 insert 钩子函数</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insertedVnodeQueue.length; ++i) &#123;</span><br><span class="line">    insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行模块的 post 钩子函数</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.post.length; ++i) cbs.post[i]()</span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="createElm"><a href="#createElm" class="headerlink" title="createElm"></a>createElm</h3><ul>
<li><p><strong>功能：</strong></p>
<ul>
<li>createElm(vnode, insertedVnodeQueue)，返回创建的 DOM 元素</li>
<li>创建 vnode 对应的 DOM 元素</li>
</ul>
</li>
<li><p><strong>执行过程：</strong></p>
<ul>
<li>首先触发<strong>用户</strong>设置的 <strong>init</strong> <strong>钩子</strong>函数</li>
<li>如果选择器是!，创建评论节点</li>
<li>如果选择器为空，创建文本节点</li>
<li>如果选择器不为空<ul>
<li>解析选择器，设置标签的 id 和 class 属性</li>
<li>执行<strong>模块</strong>的 <strong>create</strong> <strong>钩子</strong>函数</li>
<li>如果 vnode 有 children，创建子 vnode 对应的 DOM，追加到 DOM 树</li>
<li>如果 vnode 的 text 值是 string/number，创建文本节点并追击到 DOM 树</li>
<li>执行<strong>用户</strong>设置的 <strong>create</strong> <strong>钩子</strong>函数</li>
<li>如果有用户设置的 insert 钩子函数，把 vnode 添加到队列中</li>
</ul>
</li>
</ul>
</li>
<li><p>源码位置：src/package/init.ts</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params">vnode: VNode, insertedVnodeQueue: VNodeQueue</span>): <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i: any</span><br><span class="line">  <span class="keyword">let</span> data = vnode.data</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (data !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行用户设置的 init 钩子函数</span></span><br><span class="line">    <span class="keyword">const</span> init = data.hook?.init</span><br><span class="line">    <span class="keyword">if</span> (isDef(init)) &#123;</span><br><span class="line">      init(vnode)</span><br><span class="line">      data = vnode.data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> children = vnode.children</span><br><span class="line">  <span class="keyword">const</span> sel = vnode.sel</span><br><span class="line">  <span class="keyword">if</span> (sel === <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果选择器是!，创建注释节点</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">      vnode.text = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    vnode.elm = api.createComment(vnode.text!)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sel !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果选择器不为空</span></span><br><span class="line">    <span class="comment">// 解析选择器</span></span><br><span class="line">    <span class="comment">// Parse selector</span></span><br><span class="line">    <span class="keyword">const</span> hashIdx = sel.indexOf(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> dotIdx = sel.indexOf(<span class="string">&#x27;.&#x27;</span>, hashIdx)</span><br><span class="line">    <span class="keyword">const</span> hash = hashIdx &gt; <span class="number">0</span> ? hashIdx : sel.length</span><br><span class="line">    <span class="keyword">const</span> dot = dotIdx &gt; <span class="number">0</span> ? dotIdx : sel.length</span><br><span class="line">    <span class="keyword">const</span> tag = hashIdx !== -<span class="number">1</span> || dotIdx !== -<span class="number">1</span> ? sel.slice(<span class="number">0</span>, <span class="built_in">Math</span>.min(hash, dot)) : sel</span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = isDef(data) &amp;&amp; isDef(i = data.ns)</span><br><span class="line">      ? api.createElementNS(i, tag)</span><br><span class="line">      : api.createElement(tag)</span><br><span class="line">    <span class="keyword">if</span> (hash &lt; dot) elm.setAttribute(<span class="string">&#x27;id&#x27;</span>, sel.slice(hash + <span class="number">1</span>, dot))</span><br><span class="line">    <span class="keyword">if</span> (dotIdx &gt; <span class="number">0</span>) elm.setAttribute(<span class="string">&#x27;class&#x27;</span>, sel.slice(dot + <span class="number">1</span>).replace(<span class="regexp">/\./g</span>, <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">    <span class="comment">// 执行模块的 create 钩子函数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) cbs.create[i](emptyNode, vnode)</span><br><span class="line">    <span class="comment">// 如果 vnode 中有子节点，创建子 vnode 对应的 DOM 元素并追加到 DOM 树上</span></span><br><span class="line">    <span class="keyword">if</span> (is.array(children)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> ch = children[i]</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="literal">null</span>) &#123;</span><br><span class="line">          api.appendChild(elm, createElm(ch <span class="keyword">as</span> VNode, insertedVnodeQueue))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(vnode.text)) &#123;</span><br><span class="line">      <span class="comment">// 如果 vnode 的 text 值是 string/number，创建文本节点并追加到 DOM 树</span></span><br><span class="line">      api.appendChild(elm, api.createTextNode(vnode.text))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> hook = vnode.data!.hook</span><br><span class="line">    <span class="keyword">if</span> (isDef(hook)) &#123;</span><br><span class="line">      <span class="comment">// 执行用户传入的钩子 create</span></span><br><span class="line">      hook.create?.(emptyNode, vnode)</span><br><span class="line">      <span class="keyword">if</span> (hook.insert) &#123;</span><br><span class="line">        <span class="comment">// 把 vnode 添加到队列中，为后续执行 insert 钩子做准备</span></span><br><span class="line">        insertedVnodeQueue.push(vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果选择器为空，创建文本节点</span></span><br><span class="line">    vnode.elm = api.createTextNode(vnode.text!)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回新创建的 DOM                                </span></span><br><span class="line">  <span class="keyword">return</span> vnode.elm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><ul>
<li><p><strong>功能：</strong></p>
<ul>
<li>patchVnode(oldVnode, vnode, insertedVnodeQueue)</li>
<li>对比 oldVnode 和 vnode 的差异，把差异渲染到 DOM </li>
</ul>
</li>
<li><p><strong>执行过程：</strong></p>
<ul>
<li><p>首先执行<strong>用户</strong>设置的 <strong>prepatch</strong> <strong>钩子</strong>函数</p>
</li>
<li><p>执行 create 钩子函数</p>
<ul>
<li>首先执行<strong>模块</strong>的 <strong>create</strong> <strong>钩子</strong>函数</li>
<li>然后执行<strong>用户</strong>设置的 <strong>create</strong> <strong>钩子</strong>函数</li>
</ul>
</li>
<li><p>如果 <strong>vnode.text</strong> 未定义</p>
<ul>
<li>如果 <code>oldVnode.children</code> 和 <code>vnode.children</code> 都有值<ul>
<li>调用 <code>updateChildren()</code></li>
<li>使用 diff 算法对比子节点，更新子节点</li>
</ul>
</li>
<li>如果 <code>vnode.children</code> 有值，<code>oldVnode.children</code> 无值<ul>
<li>清空 DOM 元素</li>
<li>调用 <code>addVnodes()</code>，批量添加子节点</li>
</ul>
</li>
<li>如果 <code>oldVnode.children</code> 有值，<code>vnode.children</code> 无值<ul>
<li>调用 <code>removeVnodes()</code>，批量移除子节点</li>
</ul>
</li>
<li>如果 <strong>oldVnode.text</strong> 有值<ul>
<li>清空 DOM 元素的内容</li>
</ul>
</li>
</ul>
</li>
<li><p>如果设置了 <code>vnode.text</code> 并且和和 <code>oldVnode.text</code> 不等</p>
<ul>
<li>如果老节点有子节点，全部移除</li>
<li>设置 DOM 元素的 <code>textContent</code> 为 <code>vnode.text</code></li>
<li>最后执行用户<strong>设置的</strong> <strong>postpatch</strong> <strong>钩子</strong>函数</li>
</ul>
</li>
<li><p>源码位置：src/package/init.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function patchVnode (oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue) &#123;</span><br><span class="line">    const hook &#x3D; vnode.data?.hook</span><br><span class="line">    &#x2F;&#x2F; 首先执行用户设置的 prepatch 钩子函数</span><br><span class="line">    hook?.prepatch?.(oldVnode, vnode)</span><br><span class="line">    const elm &#x3D; vnode.elm &#x3D; oldVnode.elm!</span><br><span class="line">    const oldCh &#x3D; oldVnode.children as VNode[]</span><br><span class="line">    const ch &#x3D; vnode.children as VNode[]</span><br><span class="line">    &#x2F;&#x2F; 如果新老 vnode 相同返回</span><br><span class="line">    if (oldVnode &#x3D;&#x3D;&#x3D; vnode) return</span><br><span class="line">    if (vnode.data !&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">      &#x2F;&#x2F; 执行模块的 update 钩子函数</span><br><span class="line">      for (let i &#x3D; 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">      &#x2F;&#x2F; 执行用户设置的 update 钩子函数</span><br><span class="line">      vnode.data.hook?.update?.(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果 vnode.text 未定义</span><br><span class="line">    if (isUndef(vnode.text)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果新老节点都有 children</span><br><span class="line">      if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用 updateChildren 对比子节点，更新子节点</span><br><span class="line">        if (oldCh !&#x3D;&#x3D; ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue)</span><br><span class="line">      &#125; else if (isDef(ch)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果新节点有 children，老节点没有 children</span><br><span class="line">        &#x2F;&#x2F; 如果老节点有text，清空dom 元素的内容</span><br><span class="line">        if (isDef(oldVnode.text)) api.setTextContent(elm, &#39;&#39;)</span><br><span class="line">        &#x2F;&#x2F; 批量添加子节点</span><br><span class="line">        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)</span><br><span class="line">      &#125; else if (isDef(oldCh)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果老节点有children，新节点没有children</span><br><span class="line">        &#x2F;&#x2F; 批量移除子节点</span><br><span class="line">        removeVnodes(elm, oldCh, 0, oldCh.length - 1)</span><br><span class="line">      &#125; else if (isDef(oldVnode.text)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果老节点有 text，清空 DOM 元素</span><br><span class="line">        api.setTextContent(elm, &#39;&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (oldVnode.text !&#x3D;&#x3D; vnode.text) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果没有设置 vnode.text</span><br><span class="line">      if (isDef(oldCh)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果老节点有 children，移除</span><br><span class="line">        removeVnodes(elm, oldCh, 0, oldCh.length - 1)</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 设置 DOM 元素的 textContent 为 vnode.text</span><br><span class="line">      api.setTextContent(elm, vnode.text!)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 最后执行用户设置的 postpatch 钩子函数</span><br><span class="line">    hook?.postpatch?.(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><ul>
<li><p><strong>功能：</strong></p>
<ul>
<li>diff 算法的核心，对比新旧节点的 children，更新 DOM</li>
</ul>
</li>
<li><p><strong>执行过程：</strong></p>
<ul>
<li>要对比两棵树的差异，我们可以取第一棵树的每一个节点依次和第二课树的每一个节点比较，但是这样的时间复杂度为 O(n^3)</li>
<li>在DOM 操作的时候我们很少很少会把一个父节点移动/更新到某一个子节点</li>
<li>因此只需要找<strong>同级别</strong>的子<strong>节点</strong>依次<strong>比较</strong>，然后再找下一级别的节点比较，这样算法的时间复杂度为 O(n)</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20200102103653779.2xk8fi4x8tg0.png"
                      alt="image-20200102103653779.png"
                ></p>
<ul>
<li>在进行同级别节点比较的时候，首先会对新老节点数组的开始和结尾节点设置标记索引，遍历的过程中移动索引</li>
<li>在对<strong>开始和结束节点</strong>比较的时候，总共有四种情况<ul>
<li>oldStartVnode / newStartVnode (旧开始节点 / 新开始节点)</li>
<li>oldEndVnode / newEndVnode (旧结束节点 / 新结束节点)</li>
<li>oldStartVnode / oldEndVnode (旧开始节点 / 新结束节点)</li>
<li>oldEndVnode / newStartVnode (旧结束节点 / 新开始节点)</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20200109184608649.5sn8s9wdufk0.png"
                      alt="image-20200109184608649"
                ></p>
<ul>
<li>开始节点和结束节点比较，这两种情况类似<ul>
<li>oldStartVnode / newStartVnode (旧开始节点 / 新开始节点)</li>
<li>oldEndVnode / newEndVnode (旧结束节点 / 新结束节点)</li>
</ul>
</li>
<li>如果 oldStartVnode 和 newStartVnode 是 sameVnode (key 和 sel 相同)<ul>
<li>调用 patchVnode() 对比和更新节点</li>
<li>把旧开始和新开始索引往后移动  oldStartIdx++ / oldEndIdx++</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20200103121812840.6hxchhphz4c0.png"
                      alt="image-20200103121812840"
                ></p>
<ul>
<li>oldStartVnode / newEndVnode (旧开始节点 / 新结束节点) 相同<ul>
<li>调用 patchVnode() 对比和更新节点</li>
<li>把 oldStartVnode 对应的 DOM 元素，移动到右边 - 更新索引</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20200103125428541.3uajwl6tgi60.png"
                      alt="image-20200103125428541"
                ></p>
<ul>
<li>oldEndVnode / newStartVnode (旧结束节点 / 新开始节点) 相同<ul>
<li>调用 patchVnode() 对比和更新节点</li>
<li>把 oldEndVnode 对应的 DOM 元素，移动到左边</li>
<li>更新索引</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20200103125735048.3w57o49590o0.png"
                      alt="image-20200103125735048"
                ></p>
<ul>
<li>如果不是以上四种情况<ul>
<li>遍历新节点，使用 newStartNode 的 key 在老节点数组中找相同节点</li>
<li>如果没有找到，说明 newStartNode 是新节点<ul>
<li>创建新节点对应的 DOM 元素，插入到 DOM 树中</li>
</ul>
</li>
<li>如果找到了<ul>
<li>判断新节点和找到的老节点的 sel 选择器是否相同</li>
<li>如果不相同，说明节点被修改了<ul>
<li>重新创建对应的 DOM 元素，插入到 DOM 树中</li>
</ul>
</li>
<li>如果相同，把 elmToMove 对应的 DOM 元素，移动到左边</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20200109184822439.720rfdretlo0.png"
                      alt="image-20200109184822439"
                ></p>
<ul>
<li>循环结束<ul>
<li>当老节点的所有子节点先遍历完 (oldStartIdx &gt; oldEndIdx)，循环结束</li>
<li>新节点的所有子节点先遍历完 (newStartIdx &gt; newEndIdx)，循环结束</li>
</ul>
</li>
<li>如果老节点的数组先遍历完(oldStartIdx &gt; oldEndIdx)，说明新节点有剩余，把剩余节点批量插入到右边</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20200103150918335.41xk9i229f00.png"
                      alt="image-20200103150918335"
                ></p>
<p>​    </p>
<ul>
<li>如果新节点的数组先遍历完(newStartIdx &gt; newEndIdx)，说明老节点有剩余，把剩余节点批量删除</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20200109194751093.ldt2k0j95rk.png"
                      alt="image-20200109194751093"
                ></p>
</li>
<li><p>源码位置：src/package/init.ts</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm: Node,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldCh: VNode[],</span></span></span><br><span class="line"><span class="function"><span class="params">  newCh: VNode[],</span></span></span><br><span class="line"><span class="function"><span class="params">  insertedVnodeQueue: VNodeQueue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx: KeyToIndexMap | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">let</span> idxInOld: number</span><br><span class="line">  <span class="keyword">let</span> elmToMove: VNode</span><br><span class="line">  <span class="keyword">let</span> before: any</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// 索引变化后，可能会把节点设置为空</span></span><br><span class="line">    <span class="keyword">if</span> (oldStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 节点为空移动索引</span></span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode might have been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    <span class="comment">// 比较开始和结束节点的四种情况</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// 1. 比较老开始节点和新的开始节点</span></span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// 2. 比较老结束节点和新的结束节点</span></span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">      <span class="comment">// 3. 比较老开始节点和新的结束节点</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      api.insertBefore(parentElm, oldStartVnode.elm!, api.nextSibling(oldEndVnode.elm!))</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">      <span class="comment">// 4. 比较老结束节点和新的开始节点</span></span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">      api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 开始节点和结束节点都不相同</span></span><br><span class="line">      <span class="comment">// 使用 newStartNode 的 key 再老节点数组中找相同节点</span></span><br><span class="line">      <span class="comment">// 先设置记录 key 和 index 的对象</span></span><br><span class="line">      <span class="keyword">if</span> (oldKeyToIdx === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 遍历 newStartVnode, 从老的节点中找相同 key 的 oldVnode 的索引</span></span><br><span class="line">      idxInOld = oldKeyToIdx[newStartVnode.key <span class="keyword">as</span> string]</span><br><span class="line">      <span class="comment">// 如果是新的vnode</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        <span class="comment">// 如果没找到，newStartNode 是新节点</span></span><br><span class="line">        <span class="comment">// 创建元素插入 DOM 树</span></span><br><span class="line">        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm!)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果找到相同 key 相同的老节点，记录到 elmToMove 遍历</span></span><br><span class="line">        elmToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="keyword">if</span> (elmToMove.sel !== newStartVnode.sel) &#123;</span><br><span class="line">          <span class="comment">// 如果新旧节点的选择器不同</span></span><br><span class="line">          <span class="comment">// 创建新开始节点对应的 DOM 元素，插入到 DOM 树中</span></span><br><span class="line">          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm!)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果相同，patchVnode()</span></span><br><span class="line">          <span class="comment">// 把 elmToMove 对应的 DOM 元素，移动到左边</span></span><br><span class="line">          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span> <span class="keyword">as</span> any</span><br><span class="line">          api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重新给 newStartVnode 赋值，指向下一个新节点</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环结束，老节点数组先遍历完成或者新节点数组先遍历完成</span></span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &lt;= oldEndIdx || newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      <span class="comment">// 如果老节点数组先遍历完成，说明有新的节点剩余</span></span><br><span class="line">      <span class="comment">// 把剩余的新节点都插入到右边</span></span><br><span class="line">      before = newCh[newEndIdx + <span class="number">1</span>] == <span class="literal">null</span> ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果新节点数组先遍历完成，说明老节点有剩余</span></span><br><span class="line">      <span class="comment">// 批量删除老节点</span></span><br><span class="line">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="简述-Diff-算法的执行过程"><a href="#简述-Diff-算法的执行过程" class="headerlink" title="简述 Diff 算法的执行过程"></a>简述 Diff 算法的执行过程</h2><ul>
<li><p>diff算法是一种通过同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，所以时间复杂度只有 O(n)。 </p>
</li>
<li><p>diff算法有两个比较显著的特点： </p>
<ul>
<li>1、比较只会在同层级进行, 不会跨层级比较。 </li>
<li>2、在diff比较的过程中，循环从两边向中间收拢。 </li>
</ul>
</li>
<li><p>diff流程： </p>
<ul>
<li>1 、首先定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode 的两边的索引。 </li>
<li>2、接下来是一个 while 循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 会逐渐向中间靠拢。while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。<ul>
<li>while 循环中会遇到四种情况： <ul>
<li>情形一：当新老 VNode 节点的 start 是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的开始索引都加 1。 </li>
<li>情形二：当新老 VNode 节点的 end  是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的结束索引都减 1。 </li>
<li>情形三：当老 VNode 节点的 start 和新 VNode 节点的 end  是同一节点时，这说明这次数据更新后 oldStartVnode 已经跑到了 oldEndVnode 后面去了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1。 </li>
<li>情形四：当老 VNode 节点的 end 和新 VNode 节点的 start 是同一节点时，这说明这次数据更新后 oldEndVnode 跑到了 oldStartVnode 的前面去了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1。  </li>
</ul>
</li>
</ul>
</li>
<li>3、while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。 <ul>
<li>情形一：如果在循环中，oldStartIdx大于oldEndIdx了，那就表示oldChildren比newChildren先循环完毕，那么newChildren里面剩余的节点都是需要新增的节点，把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中 </li>
<li>情形二：如果在循环中，newStartIdx大于newEndIdx了，那就表示newChildren比oldChildren先循环完毕，那么oldChildren里面剩余的节点都是需要删除的节点，把[oldStartIdx, oldEndIdx]之间的所有节点都删除</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue原理剖析</category>
      </categories>
      <tags>
        <tag>Snabbdom</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码剖析(一) — Vue首次渲染</title>
    <url>/2021/04/23/Vue%E9%A6%96%E6%AC%A1%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h2 id="Vue源码的获取"><a href="#Vue源码的获取" class="headerlink" title="Vue源码的获取"></a>Vue源码的获取</h2><ul>
<li><p>项目地址：<a class="link"   href="https://github.com/vuejs/vue" >https://github.com/vuejs/vue<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>Fork 一份到自己仓库，克隆到本地，可以自己写注释提交到 github</p>
</li>
</ul>
<h2 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a><strong>源码目录结构</strong></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">	├─compiler 编译相关 </span><br><span class="line">	├─core Vue 核心库 </span><br><span class="line">	├─platforms 平台相关代码 </span><br><span class="line">	├─server SSR，服务端渲染 </span><br><span class="line">	├─sfc .vue 文件编译为 js 对象 </span><br><span class="line">	└─shared 公共的代码</span><br></pre></td></tr></table></figure>

<h2 id="了解-Flow"><a href="#了解-Flow" class="headerlink" title="了解 Flow"></a><strong>了解</strong> <strong>Flow</strong></h2><ul>
<li><p>官网：<a class="link"   href="https://flflow.org/" >https://flflow.org/<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>JavaScript 的<strong>静态类型检查器</strong></p>
</li>
<li><p>Flow 的静态类型检查错误是通过静态类型推断实现的</p>
<ul>
<li>文件开头通过<code>// @flow</code>或者 <code>/* @flow */ </code>声明</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n: number</span>): <span class="title">number</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> n * n; </span><br><span class="line">&#125;</span><br><span class="line">square(<span class="string">&quot;2&quot;</span>); <span class="comment">// Error! </span></span><br></pre></td></tr></table></figure>

<h2 id="调试设置"><a href="#调试设置" class="headerlink" title="调试设置"></a><strong>调试设置</strong></h2><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a><strong>打包</strong></h3><ul>
<li><p>打包工具 Rollup</p>
<ul>
<li>Vue.js 源码的打包工具使用的是 Rollup，比 Webpack 轻量</li>
<li>Webpack 把所有文件当做模块，Rollup 只处理 js 文件更适合在 Vue.js 这样的库中使用</li>
<li>Rollup 打包不会生成冗余的代码</li>
</ul>
</li>
<li><p>安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i</span><br></pre></td></tr></table></figure></li>
<li><p>设置 sourcemap</p>
<ul>
<li>package.json 文件中的 dev 脚本中添加参数 –sourcemap</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;dev&quot;</span>: <span class="string">&quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web- full-dev&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>执行 dev </p>
<ul>
<li>npm run dev 执行打包，用的是 rollup，-w 参数是监听文件的变化，文件变化自动重新打包</li>
<li>结果：</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423152550926.2rcfbgah7p40.png"
                      alt="image-20210423152550926"
                ></p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a><strong>调试</strong></h3><ul>
<li><p>examples 的示例中引入的 vue.min.js 改为 vue.js</p>
</li>
<li><p>打开 Chrome 的调试工具中的 source</p>
</li>
</ul>
<h3 id="Vue-的不同构建版本"><a href="#Vue-的不同构建版本" class="headerlink" title="Vue 的不同构建版本"></a><strong>Vue</strong> <strong>的不同构建版本</strong></h3><ul>
<li><p>npm run build 重新打包所有文件</p>
</li>
<li><p>官方文档 - 对不同构建版本的解释</p>
</li>
<li><p>dist\README.md</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">UMD</th>
<th align="center">CommonJS</th>
<th align="center">ES Module</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Full</strong></td>
<td align="center">vue.js</td>
<td align="center">vue.common.js</td>
<td align="center">vue.esm.js</td>
</tr>
<tr>
<td align="center"><strong>Runtime-only</strong></td>
<td align="center">vue.runtime.js</td>
<td align="center">vue.runtime.common.js</td>
<td align="center">vue.runtime.esm.js</td>
</tr>
<tr>
<td align="center"><strong>Full (production)</strong></td>
<td align="center">vue.min.js</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>Runtime-only (production)</strong></td>
<td align="center">vue.runtime.min.js</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h3><ul>
<li><p><strong>完整版</strong>：同时包含<strong>编译器</strong>和<strong>运行时</strong>的版本。</p>
</li>
<li><p><strong>编译器</strong>：用来将模板字符串编译成为 JavaScript 渲染函数的代码，体积大、效率低。</p>
</li>
<li><p><strong>运行时</strong>：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码，体积小、效率高。基本上就是除去编译器的代码。</p>
</li>
<li><p><strong>UMD</strong>：UMD 版本<strong>通用的模块版本</strong>，支持多种模块方式。 vue.js 默认文件就是运行时 + 编译器的UMD 版本</p>
</li>
<li><p><strong>CommonJS**</strong>(cjs)**：CommonJS 版本用来配合老的打包工具比如 Browserify 或 webpack 1。</p>
</li>
<li><p><strong>ES Module</strong>：从 2.6 开始 Vue 会提供两个 ES Modules (ESM) 构建文件，为现代打包工具提供的版本。</p>
<ul>
<li><p>ESM 格式被设计为可以被静态分析，所以打包工具可以利用这一点来进行“tree-shaking”并将用不到的代码排除出最终的包。</p>
</li>
<li><p>ES6 模块与 CommonJS 模块的差异</p>
</li>
</ul>
</li>
</ul>
<h3 id="Runtime-Compiler-vs-Runtime-only"><a href="#Runtime-Compiler-vs-Runtime-only" class="headerlink" title="Runtime + Compiler vs. Runtime-only"></a><strong>Runtime + Compiler vs. Runtime-only</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compiler </span></span><br><span class="line"><span class="comment">// 需要编译器，把 template 转换成 render 函数 </span></span><br><span class="line"><span class="comment">// const vm = new Vue(&#123; </span></span><br><span class="line"><span class="comment">// 	el: &#x27;#app&#x27;, </span></span><br><span class="line"><span class="comment">// 	template: &#x27;&lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;&#x27;, </span></span><br><span class="line"><span class="comment">// 	data: &#123; </span></span><br><span class="line"><span class="comment">// 		msg: &#x27;Hello Vue&#x27; </span></span><br><span class="line"><span class="comment">// 	&#125; </span></span><br><span class="line"><span class="comment">// &#125;) </span></span><br><span class="line"><span class="comment">// Runtime </span></span><br><span class="line"><span class="comment">// 不需要编译器 </span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>, </span><br><span class="line">  render (h) &#123; </span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;h1&#x27;</span>, <span class="built_in">this</span>.msg) </span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123; </span><br><span class="line">    msg: <span class="string">&#x27;Hello Vue&#x27;</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>推荐使用运行时版本，因为运行时版本相比完整版体积要小大约 30%</p>
</li>
<li><p>基于 Vue-CLI 创建的项目默认使用的是 vue.runtime.esm.js</p>
<ul>
<li>通过查看 webpack 的配置文件</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue inspect &gt; output.js</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>： *.vue 文件中的模板是在构建时预编译的，最终打包后的结果不需要编译器，只需要运行时版本即可</li>
</ul>
<h2 id="寻找入口文件"><a href="#寻找入口文件" class="headerlink" title="寻找入口文件"></a><strong>寻找入口文件</strong></h2><ul>
<li>查看 dist/vue.js 的构建过程</li>
</ul>
<h2 id="执行构建"><a href="#执行构建" class="headerlink" title="执行构建"></a><strong>执行构建</strong></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run dev </span><br><span class="line"><span class="comment"># &quot;dev&quot;: &quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev&quot; </span></span><br><span class="line"><span class="comment"># --environment TARGET:web-full-dev 设置环境变量 TARGET</span></span><br></pre></td></tr></table></figure>

<ul>
<li>script/config.js 的执行过程<ul>
<li>作用：生成 rollup 构建的配置文件</li>
<li>使用环境变量 TARGET = web-full-dev</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断环境变量是否有 TARGET </span></span><br><span class="line"><span class="comment">// 如果有的话 使用 genConfig() 生成 rollup 配置文件 </span></span><br><span class="line"><span class="keyword">if</span> (process.env.TARGET) &#123; </span><br><span class="line">  <span class="built_in">module</span>.exports = genConfig(process.env.TARGET) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="comment">// 否则获取全部配置</span></span><br><span class="line">  <span class="built_in">exports</span>.getBuild = genConfig <span class="built_in">exports</span>.getAllBuilds = <span class="function">() =&gt;</span> <span class="built_in">Object</span>.keys(builds).map(genConfig) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>genConfifig(name)<ul>
<li>根据环境变量 TARGET 获取配置信息</li>
<li>builds[name] 获取生成配置的信息</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Runtime+compiler development build (Browser) </span></span><br><span class="line"><span class="string">&#x27;web-full-dev&#x27;</span>: &#123; </span><br><span class="line">  entry: resolve(<span class="string">&#x27;web/entry-runtime-with-compiler.js&#x27;</span>), </span><br><span class="line">  dest: resolve(<span class="string">&#x27;dist/vue.js&#x27;</span>), </span><br><span class="line">  format: <span class="string">&#x27;umd&#x27;</span>, </span><br><span class="line">  env: <span class="string">&#x27;development&#x27;</span>, </span><br><span class="line">  alias: &#123; <span class="attr">he</span>: <span class="string">&#x27;./entity-decoder&#x27;</span> &#125;, </span><br><span class="line">  banner </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>resolve()<ul>
<li>获取入口和出口文件的绝对路径</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aliases = <span class="built_in">require</span>(<span class="string">&#x27;./alias&#x27;</span>) </span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">p</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 根据路径中的前半部分去alias中找别名 </span></span><br><span class="line">  <span class="keyword">const</span> base = p.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>] </span><br><span class="line">  <span class="keyword">if</span> (aliases[base]) &#123; </span><br><span class="line">    <span class="keyword">return</span> path.resolve(aliases[base], p.slice(base.length + <span class="number">1</span>)) </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>, p) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<ul>
<li><p>把 src/platforms/web/entry-runtime-with-compiler.js 构建成 dist/vue.js，如果设置 –sourcemap 会生成 vue.js.map</p>
</li>
<li><p>src/platform 文件夹下是 Vue 可以构建成不同平台下使用的库，目前有 weex 和 web，还有服务器端渲染的库</p>
</li>
</ul>
<h2 id="从入口开始"><a href="#从入口开始" class="headerlink" title="从入口开始"></a><strong>从入口开始</strong></h2><ul>
<li><p>src/platform/web/entry-runtime-with-compiler.js</p>
</li>
<li><p>阅读源码记录</p>
<ul>
<li><p>el 不能是 body 或者 html 标签</p>
</li>
<li><p>如果没有 render，把 template 转换成 render 函数</p>
</li>
<li><p>如果有 render 方法，直接调用 mount 挂载 DOM</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. el 不能是 body 或者 html </span></span><br><span class="line"><span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123; </span><br><span class="line">  process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; </span><br><span class="line">    warn( <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> options = <span class="built_in">this</span>.$options <span class="keyword">if</span> (!options.render) &#123; </span><br><span class="line">  <span class="comment">// 2. 把 template/el 转换成 render 函数 </span></span><br><span class="line">  …… </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 调用 mount 方法，挂载 DOM </span></span><br><span class="line"><span class="keyword">return</span> mount.call(<span class="built_in">this</span>, el, hydrating)</span><br></pre></td></tr></table></figure>

<ul>
<li>调试代码<ul>
<li>调试的方法</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123; </span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>, </span><br><span class="line">  template: <span class="string">&#x27;&lt;h3&gt;Hello template&lt;/h3&gt;&#x27;</span>, </span><br><span class="line">  render (h) &#123; </span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;h4&#x27;</span>, <span class="string">&#x27;Hello render&#x27;</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Vue-的构造函数在哪里"><a href="#Vue-的构造函数在哪里" class="headerlink" title="Vue 的构造函数在哪里"></a><strong>Vue</strong> <strong>的构造函数在哪里</strong></h2><ul>
<li><p>src/platform/web/entry-runtime-with-compiler.js 中引用了 ‘./runtime/index’</p>
</li>
<li><p>src/platform/web/runtime/index.js</p>
<ul>
<li><p>设置 Vue.confifig</p>
</li>
<li><p>设置平台相关的指令和组件</p>
<ul>
<li><p>指令 v-model、v-show</p>
</li>
<li><p>组件 transition、transition-group</p>
</li>
</ul>
</li>
<li><p>设置平台相关的 <strong>patch</strong> 方法（打补丁方法，对比新旧的 VNode）</p>
</li>
<li><p><strong>设置</strong> <strong>$mount</strong> <strong>方法，挂载</strong> <strong>DOM</strong></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// install platform runtime directives &amp; components </span></span><br><span class="line">extend(Vue.options.directives, platformDirectives) </span><br><span class="line">extend(Vue.options.components, platformComponents)</span><br><span class="line"><span class="comment">// install platform patch function </span></span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop </span><br><span class="line"><span class="comment">// public mount method </span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">	el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean </span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123; </span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span> </span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>src/platform/web/runtime/index.js 中引用了 ‘core/index’</p>
</li>
<li><p>src/core/index.js</p>
<ul>
<li>定义了 Vue 的静态方法</li>
<li>initGlobalAPI(Vue)</li>
</ul>
</li>
<li><p>src/core/index.js 中引用了 ‘./instance/index’</p>
</li>
<li><p>src/core/instance/index.js</p>
<ul>
<li>定义了 Vue 的构造函数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue) ) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用 _init() 方法 </span></span><br><span class="line">  <span class="built_in">this</span>._init(options) &#125;</span><br><span class="line"><span class="comment">// 注册 vm 的 _init() 方法，初始化 </span></span><br><span class="line">vm initMixin(Vue) </span><br><span class="line"><span class="comment">// 注册 vm 的 $data/$props/$set/$delete/$watch </span></span><br><span class="line">stateMixin(Vue) </span><br><span class="line"><span class="comment">// 初始化事件相关方法 </span></span><br><span class="line"><span class="comment">// $on/$once/$off/$emit </span></span><br><span class="line">eventsMixin(Vue) </span><br><span class="line"><span class="comment">// 初始化生命周期相关的混入方法 </span></span><br><span class="line"><span class="comment">// _update/$forceUpdate/$destroy </span></span><br><span class="line">lifecycleMixin(Vue) </span><br><span class="line"><span class="comment">// 混入 render </span></span><br><span class="line"><span class="comment">// $nextTick/_render </span></span><br><span class="line">renderMixin(Vue)</span><br></pre></td></tr></table></figure>

<h2 id="四个导出-Vue-的模块"><a href="#四个导出-Vue-的模块" class="headerlink" title="四个导出 Vue 的模块"></a><strong>四个导出</strong> <strong>Vue</strong> <strong>的模块</strong></h2><ul>
<li>src/<strong>platforms/web</strong>/entry-runtime-with-compiler.js<ul>
<li>web 平台相关的入口</li>
<li>重写了平台相关的 $mount() 方法</li>
<li>注册了 Vue.compile() 方法，传递一个 HTML 字符串返回 render 函数</li>
</ul>
</li>
<li>src/<strong>platforms/web</strong>/runtime/index.js<ul>
<li>web 平台相关</li>
<li>注册和平台相关的全局指令：v-model、v-show</li>
<li>注册和平台相关的全局组件： v-transition、v-transition-group</li>
<li>全局方法：<ul>
<li>__patch__：把虚拟 DOM 转换成真实 DOM</li>
<li>$mount：挂载方法</li>
</ul>
</li>
</ul>
</li>
<li>src/<strong>core</strong>/index.js<ul>
<li>与平台无关</li>
<li>设置了 Vue 的静态方法，initGlobalAPI(Vue)</li>
</ul>
</li>
<li>src/<strong>core</strong>/instance/index.js<ul>
<li>与平台无关</li>
<li>定义了构造函数，调用了 this._init(options) 方法</li>
<li>给 Vue 中混入了常用的实例成员</li>
</ul>
</li>
</ul>
<h2 id="Vue-的初始化"><a href="#Vue-的初始化" class="headerlink" title="Vue 的初始化"></a><strong>Vue</strong> <strong>的初始化</strong></h2><p><strong>src/core/global-api/index.js</strong></p>
<ul>
<li><p>初始化 Vue 的静态方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册 Vue 的静态属性/方法 </span></span><br><span class="line">initGlobalAPI(Vue) </span><br><span class="line"><span class="comment">// src/core/global-api/index.js </span></span><br><span class="line"><span class="comment">// 初始化 Vue.config 对象 </span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue, <span class="string">&#x27;config&#x27;</span>, configDef) </span><br><span class="line"><span class="comment">// exposed util methods. </span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> these are not considered part of the public API - avoid relying on </span></span><br><span class="line"><span class="comment">// them unless you are aware of the risk. </span></span><br><span class="line"><span class="comment">// 这些工具方法不视作全局API的一部分，除非你已经意识到某些风险，否则不要去依赖他们 </span></span><br><span class="line">Vue.util = &#123; warn, extend, mergeOptions, defineReactive &#125;</span><br><span class="line"><span class="comment">// 静态方法 set/delete/nextTick Vue.set = set Vue.delete = del Vue.nextTick = nextTick </span></span><br><span class="line"><span class="comment">// 2.6 explicit observable API </span></span><br><span class="line"><span class="comment">// 让一个对象可响应 </span></span><br><span class="line">Vue.observable = &lt;T&gt;(obj: T): <span class="function"><span class="params">T</span> =&gt;</span> &#123; observe(obj) <span class="keyword">return</span> obj &#125;</span><br><span class="line"><span class="comment">// 初始化 Vue.options 对象，并给其扩展 </span></span><br><span class="line"><span class="comment">// components/directives/filters/_base </span></span><br><span class="line">Vue.options = <span class="built_in">Object</span>.create(<span class="literal">null</span>) </span><br><span class="line">ASSET_TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123; Vue.options[type + <span class="string">&#x27;s&#x27;</span>] = <span class="built_in">Object</span>.create(<span class="literal">null</span>) &#125;)</span><br><span class="line"><span class="comment">// this is used to identify the &quot;base&quot; constructor to extend all plain- object </span></span><br><span class="line"><span class="comment">// components with in Weex&#x27;s multi-instance scenarios. </span></span><br><span class="line">Vue.options._base = Vue </span><br><span class="line"><span class="comment">// 设置 keep-alive 组件 </span></span><br><span class="line">extend(Vue.options.components, builtInComponents) </span><br><span class="line"><span class="comment">// 注册 Vue.use() 用来注册插件 </span></span><br><span class="line">initUse(Vue) </span><br><span class="line"><span class="comment">// 注册 Vue.mixin() 实现混入 </span></span><br><span class="line">initMixin(Vue) </span><br><span class="line"><span class="comment">// 注册 Vue.extend() 基于传入的 options 返回一个组件的构造函数 </span></span><br><span class="line">initExtend(Vue) </span><br><span class="line"><span class="comment">// 注册 Vue.directive()、 Vue.component()、Vue.filter() </span></span><br><span class="line">initAssetRegisters(Vue)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>src/core/instance/index.js</strong></p>
<ul>
<li>定义 Vue 的构造函数</li>
<li>初始化 Vue 的实例成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处不用 class 的原因是因为方便，后续给 Vue 实例混入实例成员 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue) ) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>) </span><br><span class="line">  &#125;</span><br><span class="line">	<span class="built_in">this</span>._init(options) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册 vm 的 _init() 方法，初始化 </span></span><br><span class="line">vm initMixin(Vue) </span><br><span class="line"><span class="comment">// 注册 vm 的 $data/$props/$set/$delete/$watch </span></span><br><span class="line">stateMixin(Vue) </span><br><span class="line"><span class="comment">// 初始化事件相关方法 </span></span><br><span class="line"><span class="comment">// $on/$once/$off/$emit </span></span><br><span class="line">eventsMixin(Vue) </span><br><span class="line"><span class="comment">// 初始化生命周期相关的混入方法 </span></span><br><span class="line"><span class="comment">// _update/$forceUpdate/$destroy </span></span><br><span class="line">lifecycleMixin(Vue) </span><br><span class="line"><span class="comment">// 混入 render // $nextTick/_render </span></span><br><span class="line">renderMixin(Vue)</span><br></pre></td></tr></table></figure>

<ul>
<li>initMixin(Vue)<ul>
<li>初始化 _init() 方法</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src\core\instance\init.js </span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// 给 Vue 实例增加 _init() 方法 </span></span><br><span class="line">  <span class="comment">// 合并 options / 初始化操作 </span></span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123; </span><br><span class="line">    <span class="comment">// a flag to avoid this being observed </span></span><br><span class="line">    <span class="comment">// 如果是 Vue 实例不需要被 observe </span></span><br><span class="line">    vm._isVue = <span class="literal">true</span> </span><br><span class="line">    <span class="comment">// merge options </span></span><br><span class="line">    <span class="comment">// 合并 options </span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123; </span><br><span class="line">      <span class="comment">// optimize internal component instantiation </span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the </span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment. </span></span><br><span class="line">      initInternalComponent(vm, options) </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span> </span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123; </span><br><span class="line">      initProxy(vm) </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      vm._renderProxy = vm </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm._self = vm </span><br><span class="line">    <span class="comment">// vm 的生命周期相关变量初始化 </span></span><br><span class="line">    <span class="comment">// $children/$parent/$root/$refs initLifecycle(vm) </span></span><br><span class="line">    <span class="comment">// vm 的事件监听初始化, 父组件绑定在当前组件上的事件 </span></span><br><span class="line">    initEvents(vm) </span><br><span class="line">    <span class="comment">// vm 的编译render初始化 </span></span><br><span class="line">    <span class="comment">// $slots/$scopedSlots/_c/$createElement/$attrs/$listeners </span></span><br><span class="line">    initRender(vm) </span><br><span class="line">    <span class="comment">// beforeCreate 生命钩子的回调</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>) </span><br><span class="line">    <span class="comment">// 把 inject 的成员注入到 vm 上 </span></span><br><span class="line">    initInjections(vm) </span><br><span class="line">    <span class="comment">// resolve injections before data/props </span></span><br><span class="line">    <span class="comment">// 初始化状态 vm 的 _props/methods/_data/computed/watch </span></span><br><span class="line">    initState(vm) </span><br><span class="line">    <span class="comment">// 初始化 provide </span></span><br><span class="line">    initProvide(vm) </span><br><span class="line">    <span class="comment">// resolve provide after data/props </span></span><br><span class="line">    <span class="comment">// created 生命钩子的回调 </span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;created&#x27;</span>) </span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span> </span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123; </span><br><span class="line">      vm._name = formatComponentName(vm, <span class="literal">false</span>) </span><br><span class="line">      mark(endTag) </span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有提供 el，调用 $mount() 挂载 </span></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123; </span><br><span class="line">      vm.$mount(vm.$options.el) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="首次渲染过程"><a href="#首次渲染过程" class="headerlink" title="首次渲染过程"></a><strong>首次渲染过程</strong></h2><ul>
<li><p>Vue 初始化完毕，开始真正的执行</p>
</li>
<li><p>调用 new Vue() 之前，已经初始化完毕</p>
</li>
<li><p>通过调试代码，记录首次渲染过程</p>
</li>
</ul>
<h2 id="数据响应式原理"><a href="#数据响应式原理" class="headerlink" title="数据响应式原理"></a><strong>数据响应式原理</strong></h2><h3 id="通过查看源码解决下面问题"><a href="#通过查看源码解决下面问题" class="headerlink" title="通过查看源码解决下面问题"></a><strong>通过查看源码解决下面问题</strong></h3><ul>
<li><p>vm.msg = { count: 0 } ，重新给属性赋值，是否是响应式的？</p>
</li>
<li><p>vm.arr[0] = 4 ，给数组元素赋值，视图是否会更新</p>
</li>
<li><p>vm.arr.length = 0 ，修改数组的 length，视图是否会更新</p>
</li>
<li><p>vm.arr.push(4) ，视图是否会更新</p>
</li>
</ul>
<h3 id="响应式处理的入口"><a href="#响应式处理的入口" class="headerlink" title="响应式处理的入口"></a><strong>响应式处理的入口</strong></h3><p>整个响应式处理的过程是比较复杂的，下面我们先从</p>
<ul>
<li><p>src\core\instance\init.js</p>
<ul>
<li><p>initState(vm) vm 状态的初始化</p>
</li>
<li><p>初始化了 _data、_props、methods 等</p>
</li>
</ul>
</li>
<li><p>src\core\instance\state.js</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据的初始化 </span></span><br><span class="line"><span class="keyword">if</span> (opts.data) &#123; </span><br><span class="line">  initData(vm) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>initData(vm) vm 数据的初始化</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data </span><br><span class="line">  <span class="comment">// 初始化 _data，组件中 data 是函数，调用函数返回结果 </span></span><br><span class="line">  <span class="comment">// 否则直接返回 data </span></span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span> ? getData(data, vm) : data || &#123;&#125; </span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">// proxy data on instance </span></span><br><span class="line">  <span class="comment">// 获取 data 中的所有属性 </span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data) </span><br><span class="line">  <span class="comment">// 获取 props / methods </span></span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props </span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods </span><br><span class="line">  <span class="keyword">let</span> i = keys.length </span><br><span class="line">  <span class="comment">// 判断 data 上的成员是否和 props/methods 重名 </span></span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">// observe data </span></span><br><span class="line">  <span class="comment">// 数据的响应式处理 </span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>) &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>src\core\observer\index.js<ul>
<li>observe(value, asRootData) </li>
<li>负责为每一个 Object 类型的 value 创建一个 observer 实例</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"> value: any, </span></span></span><br><span class="line"><span class="function"><span class="params"> asRootData: ?boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 判断 value 是否是对象 </span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123; </span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ob: Observer | <span class="keyword">void</span> </span><br><span class="line"><span class="comment">// 如果 value 有 __ob__(observer对象) 属性 结束 </span></span><br><span class="line"><span class="keyword">if</span> (hasOwn(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123; </span><br><span class="line">  ob = value.__ob__ </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( </span><br><span class="line">  shouldObserve &amp;&amp; </span><br><span class="line">  !isServerRendering() &amp;&amp; </span><br><span class="line">  (<span class="built_in">Array</span>.isArray(value) || </span><br><span class="line">   isPlainObject(value)) &amp;&amp; </span><br><span class="line">  <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">  !value._isVue </span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// 创建一个 Observer 对象</span></span><br><span class="line">  ob = <span class="keyword">new</span> Observer(value) </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123; </span><br><span class="line">  ob.vmCount++ </span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> ob </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a><strong>Observer</strong></h3><ul>
<li>src\core\observer\index.js<ul>
<li>对对象做响应化处理</li>
<li>对数组做响应化处理</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 观测对象 </span></span><br><span class="line">  value: any; </span><br><span class="line">  <span class="comment">// 依赖对象 </span></span><br><span class="line">  dep: Dep; </span><br><span class="line">  <span class="comment">// 实例计数器 </span></span><br><span class="line">  vmCount: number; </span><br><span class="line">  <span class="comment">// number of vms that have this object as root $data </span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value: any</span>) &#123; </span><br><span class="line">    <span class="built_in">this</span>.value = value </span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep() </span><br><span class="line">    <span class="comment">// 初始化实例的 vmCount 为0 </span></span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span> </span><br><span class="line">    <span class="comment">// 将实例挂载到观测对象的 __ob__ 属性，设置为不可枚举 </span></span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>) </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123; </span><br><span class="line">      <span class="comment">// 数组的响应式处理 </span></span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123; </span><br><span class="line">        protoAugment(value, arrayMethods) </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys) </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为数组中的每一个对象创建一个 observer 实例 </span></span><br><span class="line">      <span class="built_in">this</span>.observeArray(value) </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// 对象的响应化处理 </span></span><br><span class="line">      <span class="comment">// 遍历对象中的每一个属性，转换成 setter/getter </span></span><br><span class="line">      <span class="built_in">this</span>.walk(value) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Walk through all properties and convert them into </span></span><br><span class="line"><span class="comment">  * getter/setters. This method should only be called when </span></span><br><span class="line"><span class="comment">  * value type is Object. </span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123; </span><br><span class="line">    <span class="comment">// 获取观察对象的每一个属性 </span></span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj) </span><br><span class="line">    <span class="comment">// 遍历每一个属性，设置为响应式数据 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123; </span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Observe a list of Array items. </span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123; </span><br><span class="line">      observe(items[i]) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>walk(obj) <ul>
<li>遍历 obj 的所有属性，为每一个属性调用 defifineReactive() 方法，设置 getter/setter</li>
</ul>
</li>
</ul>
<h3 id="defifineReactive"><a href="#defifineReactive" class="headerlink" title="defifineReactive()"></a><strong>defifineReactive()</strong></h3><ul>
<li><p>src\core\observer\index.js</p>
</li>
<li><p>defifineReactive(obj, key, val, customSetter, shallow)</p>
<ul>
<li>为一个对象定义一个响应式的属性，每一个属性对应一个 dep 对象</li>
<li>如果该属性的值是对象，继续调用 observe</li>
<li>如果给属性赋新值，继续调用 observe</li>
<li>如果数据更新发送通知</li>
</ul>
</li>
</ul>
<h3 id="对象响应式处理"><a href="#对象响应式处理" class="headerlink" title="对象响应式处理"></a><strong>对象响应式处理</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为一个对象定义一个响应式的属性 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Define a reactive property on an Object. </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">  obj: <span class="built_in">Object</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">  key: string, </span></span></span><br><span class="line"><span class="function"><span class="params">  val: any, </span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?<span class="built_in">Function</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 为每一个属性，创建依赖对象实例 </span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep() </span><br><span class="line">  <span class="comment">// 获取 obj 的属性描述符对象 </span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key) </span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 提供预定义的存取器函数 </span></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters </span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get </span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set </span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123; </span><br><span class="line">    val = obj[key] </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 判断是否递归观察子对象，并将子对象属性都转换成 getter/setter，返回子观察对象 </span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val) </span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>, </span><br><span class="line">    configurable: <span class="literal">true</span>, </span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">      <span class="comment">// 如果预定义的 getter 存在则 value 等于getter 调用的返回值 </span></span><br><span class="line">      <span class="comment">// 否则直接赋予属性值 </span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val </span><br><span class="line">      <span class="comment">// 如果存在当前依赖目标，即 watcher 对象，则建立依赖 </span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123; </span><br><span class="line">        <span class="comment">// dep() 添加相互的依赖 </span></span><br><span class="line">        <span class="comment">// 1个组件对应一个 watcher 对象 </span></span><br><span class="line">        <span class="comment">// 1个watcher会对应多个dep（要观察的属性很多） </span></span><br><span class="line">        <span class="comment">// 我们可以手动创建多个 watcher 监听1个属性的变化，1个dep可以对应多个watcher </span></span><br><span class="line">        dep.depend() </span><br><span class="line">        <span class="comment">// 如果子观察目标存在，建立子对象的依赖关系，将来 Vue.set() 会用到 </span></span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123; </span><br><span class="line">          childOb.dep.depend() </span><br><span class="line">          <span class="comment">// 如果属性是数组，则特殊处理收集数组对象依赖 </span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123; </span><br><span class="line">            dependArray(value) </span><br><span class="line">          &#125; </span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回属性值 </span></span><br><span class="line">      <span class="keyword">return</span> value </span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123; </span><br><span class="line">      <span class="comment">// 如果预定义的 getter 存在则 value 等于getter 调用的返回值 </span></span><br><span class="line">      <span class="comment">// 否则直接赋予属性值 </span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val </span><br><span class="line">      <span class="comment">// 如果新值等于旧值或者新值旧值为null则不执行 </span></span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span> </span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; </span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span> </span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123; </span><br><span class="line">        customSetter() </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果没有 setter 直接返回 </span></span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter </span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span> </span><br><span class="line">      <span class="comment">// 如果预定义setter存在则调用，否则直接更新新值 </span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123; </span><br><span class="line">        setter.call(obj, newVal) </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        val = newVal </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3. 如果新值是对象，观察子对象并返回 子的 observer 对象 </span></span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal) </span><br><span class="line">      <span class="comment">// 4. 发布更改通知 </span></span><br><span class="line">      dep.notify() </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的响应式处理"><a href="#数组的响应式处理" class="headerlink" title="数组的响应式处理"></a><strong>数组的响应式处理</strong></h3><ul>
<li>Observer 的构造函数中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的响应式处理 </span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123; </span><br><span class="line">  <span class="keyword">if</span> (hasProto) &#123; </span><br><span class="line">    protoAugment(value, arrayMethods) </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    copyAugment(value, arrayMethods, arrayKeys) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为数组中的每一个对象创建一个 observer 实例 </span></span><br><span class="line">  <span class="built_in">this</span>.observeArray(value) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="comment">// 编译对象中的每一个属性，转换成 setter/getter </span></span><br><span class="line">  <span class="built_in">this</span>.walk(value) </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src: <span class="built_in">Object</span></span>) </span>&#123; </span><br><span class="line">  <span class="comment">/* eslint-disable no-proto */</span> </span><br><span class="line">  target.__proto__ = src </span><br><span class="line">  <span class="comment">/* eslint-enable no-proto */</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* istanbul ignore next */</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span> (<span class="params">target: <span class="built_in">Object</span>, src: <span class="built_in">Object</span>, keys: <span class="built_in">Array</span>&lt;string&gt;</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i] </span><br><span class="line">    def(target, key, src[key]) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>处理数组修改数据的方法<ul>
<li>src\core\observer\array.js</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype </span><br><span class="line"><span class="comment">// 克隆数组的原型 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto) </span><br><span class="line"><span class="comment">// 修改数组元素的方法</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [ </span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span> </span><br><span class="line">]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Intercept mutating methods and emit events </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// cache original method </span></span><br><span class="line">  <span class="comment">// 保存数组原方法 </span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method] </span><br><span class="line">  <span class="comment">// 调用 Object.defineProperty() 重新定义修改数组的方法 </span></span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 执行数组的原始方法 </span></span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    <span class="comment">// 获取数组对象的 ob 对象 </span></span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__ </span><br><span class="line">    <span class="keyword">let</span> inserted </span><br><span class="line">    <span class="keyword">switch</span> (method) &#123; </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>: </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>: </span><br><span class="line">        inserted = args </span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>: </span><br><span class="line">        inserted = args.slice(<span class="number">2</span>) </span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对插入的新元素，重新遍历数组元素设置为响应式数据 </span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted) </span><br><span class="line">    <span class="comment">// notify change </span></span><br><span class="line">    <span class="comment">// 调用了修改数组的方法，调用数组的ob对象发送通知 </span></span><br><span class="line">    ob.dep.notify() </span><br><span class="line">    <span class="keyword">return</span> result </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Dep-类"><a href="#Dep-类" class="headerlink" title="Dep 类"></a><strong>Dep</strong> <strong>类</strong></h3><ul>
<li><p>src\core\observer\dep.js</p>
</li>
<li><p>依赖对象</p>
</li>
<li><p>记录 watcher 对象</p>
</li>
<li><p>depend() – watcher 记录对应的 dep</p>
</li>
<li><p>发布通知</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 在 defineReactive() 的 getter 中创建 dep 对象，并判断 Dep.target 是否有值（一会 再来看有什么 时候有值得）, 调用 dep.depend() </span><br><span class="line"><span class="number">2.</span> dep.depend() 内部调用 Dep.target.addDep(<span class="built_in">this</span>)，也就是 watcher 的 addDep() 方 法，它内部最 调用 dep.addSub(<span class="built_in">this</span>)，把 watcher 对象，添加到 dep.subs.push(watcher) 中，也 就是把订阅者 添加到 dep 的 subs 数组中，当数据变化的时候调用 watcher 对象的 update() 方法 </span><br><span class="line"><span class="number">3.</span> 什么时候设置的 Dep.target? 通过简单的案例调试观察。调用 mountComponent() 方法的时 候，创建了 渲染 watcher 对象，执行 watcher 中的 get() 方法 </span><br><span class="line"><span class="number">4.</span> get() 方法内部调用 pushTarget(<span class="built_in">this</span>)，把当前 Dep.target = watcher，同时把当前 watcher 入栈， 因为有父子组件嵌套的时候先把父组件对应的 watcher 入栈，再去处理子组件的 watcher，子 组件的处理完毕 后，再把父组件对应的 watcher 出栈，继续操作 </span><br><span class="line"><span class="number">5.</span> Dep.target 用来存放目前正在使用的watcher。全局唯一，并且一次也只能有一个 watcher 被使用 <span class="number">1234567891011</span> </span><br><span class="line"><span class="comment">// dep 是个可观察对象，可以有多个指令订阅它 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A dep is an observable that can have multiple </span></span><br><span class="line"><span class="comment">* directives subscribing to it. </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 静态属性，watcher 对象 </span></span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  <span class="comment">// dep 实例 Id </span></span><br><span class="line">  id: number; </span><br><span class="line">	<span class="comment">// dep 实例对应的 watcher 对象/订阅者数组 </span></span><br><span class="line">	subs: <span class="built_in">Array</span>&lt;Watcher&gt;; </span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="built_in">this</span>.id = uid++ </span><br><span class="line">    <span class="built_in">this</span>.subs = [] </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加新的订阅者 watcher 对象 </span></span><br><span class="line">  addSub (sub: Watcher) &#123; </span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除订阅者 </span></span><br><span class="line">  removeSub (sub: Watcher) &#123; </span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将观察对象和 watcher 建立依赖 </span></span><br><span class="line">  depend () &#123; </span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123; </span><br><span class="line">      <span class="comment">// 如果 target 存在，把 dep 对象添加到 watcher 的依赖中 </span></span><br><span class="line">      Dep.target.addDep(<span class="built_in">this</span>) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发布通知 </span></span><br><span class="line">  notify () &#123; </span><br><span class="line">    <span class="comment">// stabilize the subscriber list first </span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice() </span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123; </span><br><span class="line">      <span class="comment">// subs aren&#x27;t sorted in scheduler if not running async </span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct </span></span><br><span class="line">      <span class="comment">// order </span></span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用每个订阅者的update方法实现更新 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123; </span><br><span class="line">      subs[i].update() </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dep.target 用来存放目前正在使用的watcher </span></span><br><span class="line"><span class="comment">// 全局唯一，并且一次也只能有一个watcher被使用 </span></span><br><span class="line"><span class="comment">// The current target watcher being evaluated. </span></span><br><span class="line"><span class="comment">// This is globally unique because only one watcher </span></span><br><span class="line"><span class="comment">// can be evaluated at a time. </span></span><br><span class="line">Dep.target = <span class="literal">null</span> </span><br><span class="line"><span class="keyword">const</span> targetStack = [] </span><br><span class="line"><span class="comment">// 入栈并将当前 watcher 赋值给Dep.target </span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">target: ?Watcher</span>) </span>&#123; </span><br><span class="line">  targetStack.push(target) </span><br><span class="line">  Dep.target = target </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 出栈操作 </span></span><br><span class="line">  targetStack.pop() </span><br><span class="line">  Dep.target = targetStack[targetStack.length - <span class="number">1</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Watcher-类"><a href="#Watcher-类" class="headerlink" title="Watcher 类"></a><strong>Watcher</strong> <strong>类</strong></h3><ul>
<li><p>Watcher 分为三种，Computed Watcher、用户 Watcher (侦听器)、<strong>渲染</strong> <strong>Watcher</strong></p>
</li>
<li><p>渲染 Watcher 的创建时机</p>
<ul>
<li>/src/core/instance/lifecycle.js</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">	vm: Component, </span></span></span><br><span class="line"><span class="function"><span class="params">   el: ?Element, </span></span></span><br><span class="line"><span class="function"><span class="params">   hydrating?: boolean </span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Component</span> </span>&#123; </span><br><span class="line">  vm.$el = el ……callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>) </span><br><span class="line">  <span class="keyword">let</span> updateComponent </span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span> </span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123; </span><br><span class="line">    …… </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      vm._update(vm._render(), hydrating) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建渲染 Watcher，expOrFn 为 updateComponent </span></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor </span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child </span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined </span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123; before () &#123; </span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; </span><br><span class="line">      callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>) </span><br><span class="line">  hydrating = <span class="literal">false</span> </span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self </span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123; </span><br><span class="line">    vm._isMounted = <span class="literal">true</span> callHook(vm, <span class="string">&#x27;mounted&#x27;</span>) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>渲染 wacher 创建的位置 lifecycle.js 的 mountComponent 函数中</p>
</li>
<li><p>Wacher 的构造函数初始化，处理 expOrFn （渲染 watcher 和侦听器处理不同）</p>
</li>
<li><p>调用 this.get() ，它里面调用 pushTarget() 然后 this.getter.call(vm, vm) （对于渲染 wacher 调 用 updateComponent），如果是用户 wacher 会获取属性的值（触发get操作）</p>
</li>
<li><p>当数据更新的时候，dep 中调用 notify() 方法，notify() 中调用 wacher 的 update() 方法</p>
</li>
<li><p>update() 中调用 queueWatcher()</p>
</li>
<li><p>queueWatcher() 是一个核心方法，去除重复操作，调用 flflushSchedulerQueue() 刷新队列并执行watcher</p>
</li>
<li><p>flflushSchedulerQueue() 中对 wacher 排序，遍历所有 wacher ，如果有 before，触发生命周期的钩子函数 beforeUpdate，执行 wacher.run()，它内部调用 this.get()，然后调用 this.cb() (渲染wacher 的 cb 是 noop)</p>
</li>
<li><p>整个流程结束</p>
</li>
</ul>
<h3 id="实例方法-数据"><a href="#实例方法-数据" class="headerlink" title="实例方法/数据"></a><strong>实例方法</strong>/数据</h3><h4 id="vm-set"><a href="#vm-set" class="headerlink" title="vm.$set"></a><strong>vm.$set</strong></h4><ul>
<li>功能<ul>
<li>向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于 向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = ‘hi’)</li>
</ul>
</li>
</ul>
<blockquote>
<p>**注意:**对象不能是 Vue 实例，或者 Vue 实例的根数据对象。 </p>
</blockquote>
<ul>
<li>示例</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$set(obj,<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>定义位置</strong></p>
<ul>
<li>Vue.set()<ul>
<li> global-api/index.js</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态方法 set/delete/nextTick Vue.set = set</span></span><br><span class="line">Vue.delete = del</span><br><span class="line">Vue.nextTick = nextTick</span><br></pre></td></tr></table></figure>

<ul>
<li>vm.$set()<ul>
<li> instance/index.js</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册 vm 的 $data/$props/$set/$delete/$watch </span></span><br><span class="line"><span class="comment">// instance/state.js</span></span><br><span class="line">stateMixin(Vue)</span><br><span class="line"><span class="comment">// instance/state.js</span></span><br><span class="line">Vue.prototype.$set = set</span><br><span class="line">Vue.prototype.$delete = del</span><br></pre></td></tr></table></figure>

<p><strong>源码</strong></p>
<ul>
<li>set() 方法<ul>
<li> observer/index.js</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set a property on an object. Adds the new property and</span></span><br><span class="line"><span class="comment"> * triggers change notification if the property doesn&#x27;t</span></span><br><span class="line"><span class="comment"> * already exist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: <span class="built_in">Array</span>&lt;any&gt; | <span class="built_in">Object</span>, key: any, val: any</span>): <span class="title">any</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    (isUndef(target) || isPrimitive(target))</span><br><span class="line">)&#123;</span><br><span class="line">  warn(<span class="string">`Cannot set reactive property on undefined, null, or primitive</span></span><br><span class="line"><span class="string">  value: <span class="subst">$&#123;(target: any)&#125;</span>`</span>)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 判断 target 是否是对象，key 是否是合法的索引</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">	target.length = <span class="built_in">Math</span>.max(target.length, key) </span><br><span class="line">  <span class="comment">// 通过 splice 对key位置的元素进行替换</span></span><br><span class="line">	<span class="comment">// splice 在 array.js进行了响应化的处理 target.splice(key, 1, val)</span></span><br><span class="line">	<span class="keyword">return</span> val </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 key 在对象中已经存在直接赋值</span></span><br><span class="line"><span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">		<span class="keyword">return</span> val </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 target 中的 observer 对象</span></span><br><span class="line"><span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line"><span class="comment">// 如果 target 是 vue 实例或者$data 直接返回 </span></span><br><span class="line"><span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">&#x27;Avoid adding reactive properties to a Vue instance or its root $data</span></span><br><span class="line"><span class="string">  &#x27;</span>+</span><br><span class="line">  <span class="string">&#x27;at runtime - declare it upfront in the data option.&#x27;</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> val </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 ob 不存在，target 不是响应式对象直接赋值 </span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">		<span class="keyword">return</span> val </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把 key 设置为响应式属性 </span></span><br><span class="line">  defineReactive(ob.value, key, val) </span><br><span class="line">  <span class="comment">// 发送通知</span></span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vm-delete"><a href="#vm-delete" class="headerlink" title="vm.$delete"></a><strong>vm.$delete</strong></h4><ul>
<li>功能<ul>
<li>删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。</li>
</ul>
</li>
</ul>
<blockquote>
<p>**注意:**目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。</p>
</blockquote>
<ul>
<li> 示例</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$delete(vm.obj,<span class="string">&#x27;msg&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>定义位置</strong></p>
<ul>
<li>Vue.delete() <ul>
<li>global-api/index.js</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态方法 set/delete/nextTick </span></span><br><span class="line">Vue.set = set</span><br><span class="line">Vue.delete = del</span><br><span class="line">Vue.nextTick = nextTick</span><br></pre></td></tr></table></figure>

<ul>
<li>vm.$delete()<ul>
<li> instance/index.js</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册 vm 的 $data/$props/$set/$delete/$watch </span></span><br><span class="line">stateMixin(Vue)</span><br><span class="line"><span class="comment">// instance/state.js</span></span><br><span class="line">Vue.prototype.$set = set</span><br><span class="line">Vue.prototype.$delete = del</span><br></pre></td></tr></table></figure>

<p><strong>源码</strong></p>
<ul>
<li>src\core\observer\index.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delete a property and trigger change if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">del</span> (<span class="params">target: <span class="built_in">Array</span>&lt;any&gt; | <span class="built_in">Object</span>, key: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">(isUndef(target) || isPrimitive(target)) )&#123;</span><br><span class="line">    warn(<span class="string">`Cannot delete reactive property on undefined, null, or primitive</span></span><br><span class="line"><span class="string">		value: <span class="subst">$&#123;(target: any)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否是数组，以及 key 是否合法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">	<span class="comment">// 如果是数组通过 splice 删除 </span></span><br><span class="line">  <span class="comment">// splice 做过响应式处理 </span></span><br><span class="line">  target.splice(key, <span class="number">1</span>) </span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 target 的 ob 对象</span></span><br><span class="line"><span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line"><span class="comment">// target 如果是 Vue 实例或者 $data 对象，直接返回 </span></span><br><span class="line"><span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">&#x27;Avoid deleting properties on a Vue instance or its root $data &#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;- just set it to null.&#x27;</span></span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 target 对象没有 key 属性直接返回 if (!hasOwn(target, key)) &#123;</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除属性</span></span><br><span class="line"><span class="keyword">delete</span> target[key] </span><br><span class="line"><span class="keyword">if</span> (!ob) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 ob 发送通知</span></span><br><span class="line">  ob.dep.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vm-watch"><a href="#vm-watch" class="headerlink" title="vm.$watch"></a><strong>vm.$watch</strong></h4><p>vm.$watch( expOrFn, callback, [options] )</p>
<ul>
<li><p>功能</p>
<ul>
<li>观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只 接受监督的键路径。对于更复杂的表达式，用一个函数取代。</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><p>expOrFn:要监视的 $data 中的属性，可以是表达式或函数</p>
</li>
<li><p>callback:数据变化后执行的函数</p>
<ul>
<li>函数:回调函数</li>
<li>对象:具有 handler 属性(字符串或者函数)，如果该属性为字符串则 methods 中相应 的定义</li>
</ul>
</li>
<li><p>options:可选的选项</p>
<ul>
<li>deep:布尔类型，深度监听</li>
<li>immediate:布尔类型，是否立即执行一次回调函数 </li>
</ul>
</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    b: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    msg: <span class="string">&#x27;Hello Vue&#x27;</span>,</span><br><span class="line">    user: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;诸葛&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;亮&#x27;</span> </span><br><span class="line">    &#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// expOrFn 是表达式</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;msg&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newVal, oldVal)</span><br><span class="line">&#125;)</span><br><span class="line">vm.$watch(<span class="string">&#x27;user.firstName&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newVal)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// expOrFn 是函数 vm.$watch(function () &#123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newVal)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// deep 是 true，消耗性能</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;user&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 此时的 newVal 是 user 对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(newVal === vm.user)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">deep: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="comment">// immediate 是 true</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;msg&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newVal)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  immediate: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="三种类型的-Watcher-对象"><a href="#三种类型的-Watcher-对象" class="headerlink" title="三种类型的 Watcher 对象"></a><strong>三种类型的</strong> <strong>Watcher</strong> <strong>对象</strong></h4><ul>
<li>没有静态方法，因为 $watch 方法中要使用 Vue 的实例</li>
<li>Watcher 分三种:计算属性 Watcher、用户 Watcher (侦听器)、渲染 Watcher </li>
<li>创建顺序:计算属性 Watcher、用户 Watcher (侦听器)、渲染 Watcher </li>
<li>vm.$watch()<ul>
<li>src\core\instance\state.js</li>
</ul>
</li>
</ul>
<p><strong>源码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn: string | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: <span class="built_in">Object</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 Vue 实例 this</span></span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span> </span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">	<span class="comment">// 判断如果 cb 是对象执行 createWatcher</span></span><br><span class="line">    <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">  &#125;</span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line">  <span class="comment">// 标记为用户 watcher</span></span><br><span class="line">  options.user = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 创建用户 watcher 对象</span></span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options) </span><br><span class="line">  <span class="comment">// 判断 immediate 如果为 true</span></span><br><span class="line">  <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">  <span class="comment">// 立即执行一次 cb 回调，并且把当前值传入 </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      cb.call(vm, watcher.value)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      handleError(error, vm, <span class="string">`callback for immediate watcher</span></span><br><span class="line"><span class="string">  &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span>)</span><br><span class="line">  &#125; &#125;</span><br><span class="line">  <span class="comment">// 返回取消监听的方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    watcher.teardown()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看渲染 watcher 的执行过程<ul>
<li> 当数据更新，defineReactive 的 set 方法中调用 dep.notify()</li>
<li> 调用 watcher 的 update()</li>
<li> 调用 queueWatcher()，把 wacher 存入队列，如果已经存入，不重复添加</li>
<li>循环调用 flushSchedulerQueue()<ul>
<li>通过 nextTick()，在消息循环结束之前时候调用 flushSchedulerQueue() </li>
</ul>
</li>
<li>调用 wacher.run()<ul>
<li>调用 wacher.get() 获取最新值 </li>
<li>如果是渲染 wacher 结束 </li>
<li>如果是用户 watcher，调用 this.cb()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="异步更新队列nextTick"><a href="#异步更新队列nextTick" class="headerlink" title="异步更新队列nextTick()"></a><strong>异步更新队列nextTick()</strong></h4><ul>
<li>Vue 更新 DOM 是异步执行的，批量的<ul>
<li>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</li>
</ul>
</li>
<li>vm.$nextTick(function () { /* 操作 DOM */ }) / Vue.nextTick(function () {})</li>
</ul>
<p><strong>vm.$nextTick()</strong> <strong>代码演示</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&#x27;Hello nextTick&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      name: <span class="string">&#x27;Vue.js&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      title: <span class="string">&#x27;Title&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.msg = <span class="string">&#x27;Hello World&#x27;</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.name = <span class="string">&#x27;Hello snabbdom&#x27;</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.title = <span class="string">&#x27;Vue.js&#x27;</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.p1.textContent)</span></span><br><span class="line">&#125;) &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>定义位置</strong></p>
<ul>
<li>src\core\instance\render.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span> (<span class="params">fn: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextTick(fn, <span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>源码</strong></p>
<ul>
<li>手动调用 vm.$nextTick()</li>
<li>在 Watcher 的 queueWatcher 中执行 nextTick() </li>
<li>src\core\util\next-tick.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"><span class="comment">// The nextTick behavior leverages the microtask queue, which can be</span></span><br><span class="line">accessed</span><br><span class="line"><span class="comment">// via either native Promise.then or MutationObserver.</span></span><br><span class="line"><span class="comment">// MutationObserver has wider support, however it is seriously bugged in</span></span><br><span class="line"><span class="comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span><br><span class="line"><span class="comment">// completely stops working after triggering a few times... so, if native</span></span><br><span class="line"><span class="comment">// Promise is available, we will use it:</span></span><br><span class="line"><span class="comment">/* istanbul ignore next, $flow-disable-line */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="comment">// In problematic UIWebViews, Promise.then doesn&#x27;t completely break,</span></span><br><span class="line">but</span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into</span></span><br><span class="line">the</span><br><span class="line">    <span class="comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">&#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">isNative(MutationObserver) ||</span><br><span class="line"> <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">&#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Technically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) </span>&#123; <span class="keyword">let</span> _resolve</span><br><span class="line"><span class="comment">// 把 cb 加上异常处理存入 callbacks 数组中 callbacks.push(() =&gt; &#123;</span></span><br><span class="line"><span class="keyword">if</span> (cb) &#123; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 调用 cb()</span></span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) </span><br><span class="line">      _resolve(ctx)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc()</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line"><span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="comment">// 返回 promise 对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue源码剖析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
