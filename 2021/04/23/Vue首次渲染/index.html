<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="JavaScript,Vue2,Vue3,Vite,Webpack,node"><meta name="description" content="wkxk的个人博客，主要涉及到编程(JavaScript,Vue2,Vue3,Webpack,node),助于个人学习提升，分享学习过程"><meta name="author" content="wkxk"><title>Vue源码剖析(一) — Vue首次渲染 | wkxk&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/logo.7kmeykeizco0.svg"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"www.iwkxk.com",root:"/",language:"zh",path:"search.xml"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0,init_open:!0},style:{primary_color:"#0066CC",avatar:"https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/avator.2use3mem6940.svg",favicon:"https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/logo.7kmeykeizco0.svg",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"愿你眼里有光，眼底无霜，心有大海，胸无睚眦。风尘自仆仆，你我当归人。"},scroll:{progress_bar:{enable:!0},percent:{enable:!0}}},local_search:{enable:!0,preload:!0},code_copy:{enable:!0,style:"default"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.2"},KEEP.language_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"}</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-title" href="/">wkxk&#39;s Blog</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">HOME</a></li><li class="menu-item"><a href="/archives">ARCHIVES</a></li><li class="menu-item"><a href="/links">LINKS</a></li><li class="menu-item"><a href="/about">ABOUT</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">HOME</a></li><li class="drawer-menu-item flex-center"><a href="/archives">ARCHIVES</a></li><li class="drawer-menu-item flex-center"><a href="/links">LINKS</a></li><li class="drawer-menu-item flex-center"><a href="/about">ABOUT</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">Vue源码剖析(一) — Vue首次渲染</span></div><div class="article-header"><div class="avatar"><img src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/avator.2use3mem6940.svg"></div><div class="info"><div class="author"><span class="name">wkxk</span> <span class="author-label">前端攻城狮</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp;2021-04-23 15:29:09 </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/Vue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">Vue源码剖析</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Vue/">Vue</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>7.5k Words</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>36 Mins</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h2 id="Vue源码的获取"><a href="#Vue源码的获取" class="headerlink" title="Vue源码的获取"></a>Vue源码的获取</h2><ul><li><p>项目地址：<a class="link" target="_blank" rel="noopener" href="https://github.com/vuejs/vue">https://github.com/vuejs/vue<i class="fas fa-external-link-alt"></i></a></p></li><li><p>Fork 一份到自己仓库，克隆到本地，可以自己写注释提交到 github</p></li></ul><h2 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a><strong>源码目录结构</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">	├─compiler 编译相关 </span><br><span class="line">	├─core Vue 核心库 </span><br><span class="line">	├─platforms 平台相关代码 </span><br><span class="line">	├─server SSR，服务端渲染 </span><br><span class="line">	├─sfc .vue 文件编译为 js 对象 </span><br><span class="line">	└─shared 公共的代码</span><br></pre></td></tr></table></figure><h2 id="了解-Flow"><a href="#了解-Flow" class="headerlink" title="了解 Flow"></a><strong>了解</strong> <strong>Flow</strong></h2><ul><li><p>官网：<a class="link" target="_blank" rel="noopener" href="https://flflow.org/">https://flflow.org/<i class="fas fa-external-link-alt"></i></a></p></li><li><p>JavaScript 的<strong>静态类型检查器</strong></p></li><li><p>Flow 的静态类型检查错误是通过静态类型推断实现的</p><ul><li>文件开头通过<code>// @flow</code>或者 <code>/* @flow */</code>声明</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n: number</span>): <span class="title">number</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> n * n; </span><br><span class="line">&#125;</span><br><span class="line">square(<span class="string">&quot;2&quot;</span>); <span class="comment">// Error! </span></span><br></pre></td></tr></table></figure><h2 id="调试设置"><a href="#调试设置" class="headerlink" title="调试设置"></a><strong>调试设置</strong></h2><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a><strong>打包</strong></h3><ul><li><p>打包工具 Rollup</p><ul><li>Vue.js 源码的打包工具使用的是 Rollup，比 Webpack 轻量</li><li>Webpack 把所有文件当做模块，Rollup 只处理 js 文件更适合在 Vue.js 这样的库中使用</li><li>Rollup 打包不会生成冗余的代码</li></ul></li><li><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br></pre></td></tr></table></figure></li><li><p>设置 sourcemap</p><ul><li>package.json 文件中的 dev 脚本中添加参数 –sourcemap</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dev&quot;</span>: <span class="string">&quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web- full-dev&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>执行 dev</p><ul><li>npm run dev 执行打包，用的是 rollup，-w 参数是监听文件的变化，文件变化自动重新打包</li><li>结果：</li></ul></li></ul><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210423152550926.2rcfbgah7p40.png" alt="image-20210423152550926"></p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a><strong>调试</strong></h3><ul><li><p>examples 的示例中引入的 vue.min.js 改为 vue.js</p></li><li><p>打开 Chrome 的调试工具中的 source</p></li></ul><h3 id="Vue-的不同构建版本"><a href="#Vue-的不同构建版本" class="headerlink" title="Vue 的不同构建版本"></a><strong>Vue</strong> <strong>的不同构建版本</strong></h3><ul><li><p>npm run build 重新打包所有文件</p></li><li><p>官方文档 - 对不同构建版本的解释</p></li><li><p>dist\README.md</p></li></ul><table><thead><tr><th align="center"></th><th align="center">UMD</th><th align="center">CommonJS</th><th align="center">ES Module</th></tr></thead><tbody><tr><td align="center"><strong>Full</strong></td><td align="center">vue.js</td><td align="center">vue.common.js</td><td align="center">vue.esm.js</td></tr><tr><td align="center"><strong>Runtime-only</strong></td><td align="center">vue.runtime.js</td><td align="center">vue.runtime.common.js</td><td align="center">vue.runtime.esm.js</td></tr><tr><td align="center"><strong>Full (production)</strong></td><td align="center">vue.min.js</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>Runtime-only (production)</strong></td><td align="center">vue.runtime.min.js</td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h3><ul><li><p><strong>完整版</strong>：同时包含<strong>编译器</strong>和<strong>运行时</strong>的版本。</p></li><li><p><strong>编译器</strong>：用来将模板字符串编译成为 JavaScript 渲染函数的代码，体积大、效率低。</p></li><li><p><strong>运行时</strong>：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码，体积小、效率高。基本上就是除去编译器的代码。</p></li><li><p><strong>UMD</strong>：UMD 版本<strong>通用的模块版本</strong>，支持多种模块方式。 vue.js 默认文件就是运行时 + 编译器的UMD 版本</p></li><li><p><strong>CommonJS**</strong>(cjs)**：CommonJS 版本用来配合老的打包工具比如 Browserify 或 webpack 1。</p></li><li><p><strong>ES Module</strong>：从 2.6 开始 Vue 会提供两个 ES Modules (ESM) 构建文件，为现代打包工具提供的版本。</p><ul><li><p>ESM 格式被设计为可以被静态分析，所以打包工具可以利用这一点来进行“tree-shaking”并将用不到的代码排除出最终的包。</p></li><li><p>ES6 模块与 CommonJS 模块的差异</p></li></ul></li></ul><h3 id="Runtime-Compiler-vs-Runtime-only"><a href="#Runtime-Compiler-vs-Runtime-only" class="headerlink" title="Runtime + Compiler vs. Runtime-only"></a><strong>Runtime + Compiler vs. Runtime-only</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compiler </span></span><br><span class="line"><span class="comment">// 需要编译器，把 template 转换成 render 函数 </span></span><br><span class="line"><span class="comment">// const vm = new Vue(&#123; </span></span><br><span class="line"><span class="comment">// 	el: &#x27;#app&#x27;, </span></span><br><span class="line"><span class="comment">// 	template: &#x27;&lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;&#x27;, </span></span><br><span class="line"><span class="comment">// 	data: &#123; </span></span><br><span class="line"><span class="comment">// 		msg: &#x27;Hello Vue&#x27; </span></span><br><span class="line"><span class="comment">// 	&#125; </span></span><br><span class="line"><span class="comment">// &#125;) </span></span><br><span class="line"><span class="comment">// Runtime </span></span><br><span class="line"><span class="comment">// 不需要编译器 </span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>, </span><br><span class="line">  render (h) &#123; </span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;h1&#x27;</span>, <span class="built_in">this</span>.msg) </span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123; </span><br><span class="line">    msg: <span class="string">&#x27;Hello Vue&#x27;</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>推荐使用运行时版本，因为运行时版本相比完整版体积要小大约 30%</p></li><li><p>基于 Vue-CLI 创建的项目默认使用的是 vue.runtime.esm.js</p><ul><li>通过查看 webpack 的配置文件</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue inspect &gt; output.js</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>： *.vue 文件中的模板是在构建时预编译的，最终打包后的结果不需要编译器，只需要运行时版本即可</li></ul><h2 id="寻找入口文件"><a href="#寻找入口文件" class="headerlink" title="寻找入口文件"></a><strong>寻找入口文件</strong></h2><ul><li>查看 dist/vue.js 的构建过程</li></ul><h2 id="执行构建"><a href="#执行构建" class="headerlink" title="执行构建"></a><strong>执行构建</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run dev </span><br><span class="line"><span class="comment"># &quot;dev&quot;: &quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev&quot; </span></span><br><span class="line"><span class="comment"># --environment TARGET:web-full-dev 设置环境变量 TARGET</span></span><br></pre></td></tr></table></figure><ul><li>script/config.js 的执行过程<ul><li>作用：生成 rollup 构建的配置文件</li><li>使用环境变量 TARGET = web-full-dev</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断环境变量是否有 TARGET </span></span><br><span class="line"><span class="comment">// 如果有的话 使用 genConfig() 生成 rollup 配置文件 </span></span><br><span class="line"><span class="keyword">if</span> (process.env.TARGET) &#123; </span><br><span class="line">  <span class="built_in">module</span>.exports = genConfig(process.env.TARGET) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="comment">// 否则获取全部配置</span></span><br><span class="line">  <span class="built_in">exports</span>.getBuild = genConfig <span class="built_in">exports</span>.getAllBuilds = <span class="function">() =&gt;</span> <span class="built_in">Object</span>.keys(builds).map(genConfig) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>genConfifig(name)<ul><li>根据环境变量 TARGET 获取配置信息</li><li>builds[name] 获取生成配置的信息</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runtime+compiler development build (Browser) </span></span><br><span class="line"><span class="string">&#x27;web-full-dev&#x27;</span>: &#123; </span><br><span class="line">  entry: resolve(<span class="string">&#x27;web/entry-runtime-with-compiler.js&#x27;</span>), </span><br><span class="line">  dest: resolve(<span class="string">&#x27;dist/vue.js&#x27;</span>), </span><br><span class="line">  format: <span class="string">&#x27;umd&#x27;</span>, </span><br><span class="line">  env: <span class="string">&#x27;development&#x27;</span>, </span><br><span class="line">  alias: &#123; <span class="attr">he</span>: <span class="string">&#x27;./entity-decoder&#x27;</span> &#125;, </span><br><span class="line">  banner </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>resolve()<ul><li>获取入口和出口文件的绝对路径</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aliases = <span class="built_in">require</span>(<span class="string">&#x27;./alias&#x27;</span>) </span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">p</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 根据路径中的前半部分去alias中找别名 </span></span><br><span class="line">  <span class="keyword">const</span> base = p.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>] </span><br><span class="line">  <span class="keyword">if</span> (aliases[base]) &#123; </span><br><span class="line">    <span class="keyword">return</span> path.resolve(aliases[base], p.slice(base.length + <span class="number">1</span>)) </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>, p) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><ul><li><p>把 src/platforms/web/entry-runtime-with-compiler.js 构建成 dist/vue.js，如果设置 –sourcemap 会生成 vue.js.map</p></li><li><p>src/platform 文件夹下是 Vue 可以构建成不同平台下使用的库，目前有 weex 和 web，还有服务器端渲染的库</p></li></ul><h2 id="从入口开始"><a href="#从入口开始" class="headerlink" title="从入口开始"></a><strong>从入口开始</strong></h2><ul><li><p>src/platform/web/entry-runtime-with-compiler.js</p></li><li><p>阅读源码记录</p><ul><li><p>el 不能是 body 或者 html 标签</p></li><li><p>如果没有 render，把 template 转换成 render 函数</p></li><li><p>如果有 render 方法，直接调用 mount 挂载 DOM</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. el 不能是 body 或者 html </span></span><br><span class="line"><span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123; </span><br><span class="line">  process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; </span><br><span class="line">    warn( <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> options = <span class="built_in">this</span>.$options <span class="keyword">if</span> (!options.render) &#123; </span><br><span class="line">  <span class="comment">// 2. 把 template/el 转换成 render 函数 </span></span><br><span class="line">  …… </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 调用 mount 方法，挂载 DOM </span></span><br><span class="line"><span class="keyword">return</span> mount.call(<span class="built_in">this</span>, el, hydrating)</span><br></pre></td></tr></table></figure><ul><li>调试代码<ul><li>调试的方法</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123; </span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>, </span><br><span class="line">  template: <span class="string">&#x27;&lt;h3&gt;Hello template&lt;/h3&gt;&#x27;</span>, </span><br><span class="line">  render (h) &#123; </span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;h4&#x27;</span>, <span class="string">&#x27;Hello render&#x27;</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Vue-的构造函数在哪里"><a href="#Vue-的构造函数在哪里" class="headerlink" title="Vue 的构造函数在哪里"></a><strong>Vue</strong> <strong>的构造函数在哪里</strong></h2><ul><li><p>src/platform/web/entry-runtime-with-compiler.js 中引用了 ‘./runtime/index’</p></li><li><p>src/platform/web/runtime/index.js</p><ul><li><p>设置 Vue.confifig</p></li><li><p>设置平台相关的指令和组件</p><ul><li><p>指令 v-model、v-show</p></li><li><p>组件 transition、transition-group</p></li></ul></li><li><p>设置平台相关的 <strong>patch</strong> 方法（打补丁方法，对比新旧的 VNode）</p></li><li><p><strong>设置</strong> <strong>$mount</strong> <strong>方法，挂载</strong> <strong>DOM</strong></p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// install platform runtime directives &amp; components </span></span><br><span class="line">extend(Vue.options.directives, platformDirectives) </span><br><span class="line">extend(Vue.options.components, platformComponents)</span><br><span class="line"><span class="comment">// install platform patch function </span></span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop </span><br><span class="line"><span class="comment">// public mount method </span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">	el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean </span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123; </span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span> </span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>src/platform/web/runtime/index.js 中引用了 ‘core/index’</p></li><li><p>src/core/index.js</p><ul><li>定义了 Vue 的静态方法</li><li>initGlobalAPI(Vue)</li></ul></li><li><p>src/core/index.js 中引用了 ‘./instance/index’</p></li><li><p>src/core/instance/index.js</p><ul><li>定义了 Vue 的构造函数</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue) ) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用 _init() 方法 </span></span><br><span class="line">  <span class="built_in">this</span>._init(options) &#125;</span><br><span class="line"><span class="comment">// 注册 vm 的 _init() 方法，初始化 </span></span><br><span class="line">vm initMixin(Vue) </span><br><span class="line"><span class="comment">// 注册 vm 的 $data/$props/$set/$delete/$watch </span></span><br><span class="line">stateMixin(Vue) </span><br><span class="line"><span class="comment">// 初始化事件相关方法 </span></span><br><span class="line"><span class="comment">// $on/$once/$off/$emit </span></span><br><span class="line">eventsMixin(Vue) </span><br><span class="line"><span class="comment">// 初始化生命周期相关的混入方法 </span></span><br><span class="line"><span class="comment">// _update/$forceUpdate/$destroy </span></span><br><span class="line">lifecycleMixin(Vue) </span><br><span class="line"><span class="comment">// 混入 render </span></span><br><span class="line"><span class="comment">// $nextTick/_render </span></span><br><span class="line">renderMixin(Vue)</span><br></pre></td></tr></table></figure><h2 id="四个导出-Vue-的模块"><a href="#四个导出-Vue-的模块" class="headerlink" title="四个导出 Vue 的模块"></a><strong>四个导出</strong> <strong>Vue</strong> <strong>的模块</strong></h2><ul><li>src/<strong>platforms/web</strong>/entry-runtime-with-compiler.js<ul><li>web 平台相关的入口</li><li>重写了平台相关的 $mount() 方法</li><li>注册了 Vue.compile() 方法，传递一个 HTML 字符串返回 render 函数</li></ul></li><li>src/<strong>platforms/web</strong>/runtime/index.js<ul><li>web 平台相关</li><li>注册和平台相关的全局指令：v-model、v-show</li><li>注册和平台相关的全局组件： v-transition、v-transition-group</li><li>全局方法：<ul><li>__patch__：把虚拟 DOM 转换成真实 DOM</li><li>$mount：挂载方法</li></ul></li></ul></li><li>src/<strong>core</strong>/index.js<ul><li>与平台无关</li><li>设置了 Vue 的静态方法，initGlobalAPI(Vue)</li></ul></li><li>src/<strong>core</strong>/instance/index.js<ul><li>与平台无关</li><li>定义了构造函数，调用了 this._init(options) 方法</li><li>给 Vue 中混入了常用的实例成员</li></ul></li></ul><h2 id="Vue-的初始化"><a href="#Vue-的初始化" class="headerlink" title="Vue 的初始化"></a><strong>Vue</strong> <strong>的初始化</strong></h2><p><strong>src/core/global-api/index.js</strong></p><ul><li><p>初始化 Vue 的静态方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 Vue 的静态属性/方法 </span></span><br><span class="line">initGlobalAPI(Vue) </span><br><span class="line"><span class="comment">// src/core/global-api/index.js </span></span><br><span class="line"><span class="comment">// 初始化 Vue.config 对象 </span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue, <span class="string">&#x27;config&#x27;</span>, configDef) </span><br><span class="line"><span class="comment">// exposed util methods. </span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> these are not considered part of the public API - avoid relying on </span></span><br><span class="line"><span class="comment">// them unless you are aware of the risk. </span></span><br><span class="line"><span class="comment">// 这些工具方法不视作全局API的一部分，除非你已经意识到某些风险，否则不要去依赖他们 </span></span><br><span class="line">Vue.util = &#123; warn, extend, mergeOptions, defineReactive &#125;</span><br><span class="line"><span class="comment">// 静态方法 set/delete/nextTick Vue.set = set Vue.delete = del Vue.nextTick = nextTick </span></span><br><span class="line"><span class="comment">// 2.6 explicit observable API </span></span><br><span class="line"><span class="comment">// 让一个对象可响应 </span></span><br><span class="line">Vue.observable = &lt;T&gt;(obj: T): <span class="function"><span class="params">T</span> =&gt;</span> &#123; observe(obj) <span class="keyword">return</span> obj &#125;</span><br><span class="line"><span class="comment">// 初始化 Vue.options 对象，并给其扩展 </span></span><br><span class="line"><span class="comment">// components/directives/filters/_base </span></span><br><span class="line">Vue.options = <span class="built_in">Object</span>.create(<span class="literal">null</span>) </span><br><span class="line">ASSET_TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123; Vue.options[type + <span class="string">&#x27;s&#x27;</span>] = <span class="built_in">Object</span>.create(<span class="literal">null</span>) &#125;)</span><br><span class="line"><span class="comment">// this is used to identify the &quot;base&quot; constructor to extend all plain- object </span></span><br><span class="line"><span class="comment">// components with in Weex&#x27;s multi-instance scenarios. </span></span><br><span class="line">Vue.options._base = Vue </span><br><span class="line"><span class="comment">// 设置 keep-alive 组件 </span></span><br><span class="line">extend(Vue.options.components, builtInComponents) </span><br><span class="line"><span class="comment">// 注册 Vue.use() 用来注册插件 </span></span><br><span class="line">initUse(Vue) </span><br><span class="line"><span class="comment">// 注册 Vue.mixin() 实现混入 </span></span><br><span class="line">initMixin(Vue) </span><br><span class="line"><span class="comment">// 注册 Vue.extend() 基于传入的 options 返回一个组件的构造函数 </span></span><br><span class="line">initExtend(Vue) </span><br><span class="line"><span class="comment">// 注册 Vue.directive()、 Vue.component()、Vue.filter() </span></span><br><span class="line">initAssetRegisters(Vue)</span><br></pre></td></tr></table></figure></li></ul><p><strong>src/core/instance/index.js</strong></p><ul><li>定义 Vue 的构造函数</li><li>初始化 Vue 的实例成员</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处不用 class 的原因是因为方便，后续给 Vue 实例混入实例成员 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue) ) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>) </span><br><span class="line">  &#125;</span><br><span class="line">	<span class="built_in">this</span>._init(options) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册 vm 的 _init() 方法，初始化 </span></span><br><span class="line">vm initMixin(Vue) </span><br><span class="line"><span class="comment">// 注册 vm 的 $data/$props/$set/$delete/$watch </span></span><br><span class="line">stateMixin(Vue) </span><br><span class="line"><span class="comment">// 初始化事件相关方法 </span></span><br><span class="line"><span class="comment">// $on/$once/$off/$emit </span></span><br><span class="line">eventsMixin(Vue) </span><br><span class="line"><span class="comment">// 初始化生命周期相关的混入方法 </span></span><br><span class="line"><span class="comment">// _update/$forceUpdate/$destroy </span></span><br><span class="line">lifecycleMixin(Vue) </span><br><span class="line"><span class="comment">// 混入 render // $nextTick/_render </span></span><br><span class="line">renderMixin(Vue)</span><br></pre></td></tr></table></figure><ul><li>initMixin(Vue)<ul><li>初始化 _init() 方法</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\instance\init.js </span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// 给 Vue 实例增加 _init() 方法 </span></span><br><span class="line">  <span class="comment">// 合并 options / 初始化操作 </span></span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123; </span><br><span class="line">    <span class="comment">// a flag to avoid this being observed </span></span><br><span class="line">    <span class="comment">// 如果是 Vue 实例不需要被 observe </span></span><br><span class="line">    vm._isVue = <span class="literal">true</span> </span><br><span class="line">    <span class="comment">// merge options </span></span><br><span class="line">    <span class="comment">// 合并 options </span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123; </span><br><span class="line">      <span class="comment">// optimize internal component instantiation </span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the </span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment. </span></span><br><span class="line">      initInternalComponent(vm, options) </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span> </span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123; </span><br><span class="line">      initProxy(vm) </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      vm._renderProxy = vm </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm._self = vm </span><br><span class="line">    <span class="comment">// vm 的生命周期相关变量初始化 </span></span><br><span class="line">    <span class="comment">// $children/$parent/$root/$refs initLifecycle(vm) </span></span><br><span class="line">    <span class="comment">// vm 的事件监听初始化, 父组件绑定在当前组件上的事件 </span></span><br><span class="line">    initEvents(vm) </span><br><span class="line">    <span class="comment">// vm 的编译render初始化 </span></span><br><span class="line">    <span class="comment">// $slots/$scopedSlots/_c/$createElement/$attrs/$listeners </span></span><br><span class="line">    initRender(vm) </span><br><span class="line">    <span class="comment">// beforeCreate 生命钩子的回调</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>) </span><br><span class="line">    <span class="comment">// 把 inject 的成员注入到 vm 上 </span></span><br><span class="line">    initInjections(vm) </span><br><span class="line">    <span class="comment">// resolve injections before data/props </span></span><br><span class="line">    <span class="comment">// 初始化状态 vm 的 _props/methods/_data/computed/watch </span></span><br><span class="line">    initState(vm) </span><br><span class="line">    <span class="comment">// 初始化 provide </span></span><br><span class="line">    initProvide(vm) </span><br><span class="line">    <span class="comment">// resolve provide after data/props </span></span><br><span class="line">    <span class="comment">// created 生命钩子的回调 </span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;created&#x27;</span>) </span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span> </span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123; </span><br><span class="line">      vm._name = formatComponentName(vm, <span class="literal">false</span>) </span><br><span class="line">      mark(endTag) </span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有提供 el，调用 $mount() 挂载 </span></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123; </span><br><span class="line">      vm.$mount(vm.$options.el) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="首次渲染过程"><a href="#首次渲染过程" class="headerlink" title="首次渲染过程"></a><strong>首次渲染过程</strong></h2><ul><li><p>Vue 初始化完毕，开始真正的执行</p></li><li><p>调用 new Vue() 之前，已经初始化完毕</p></li><li><p>通过调试代码，记录首次渲染过程</p></li></ul><h2 id="数据响应式原理"><a href="#数据响应式原理" class="headerlink" title="数据响应式原理"></a><strong>数据响应式原理</strong></h2><h3 id="通过查看源码解决下面问题"><a href="#通过查看源码解决下面问题" class="headerlink" title="通过查看源码解决下面问题"></a><strong>通过查看源码解决下面问题</strong></h3><ul><li><p>vm.msg = { count: 0 } ，重新给属性赋值，是否是响应式的？</p></li><li><p>vm.arr[0] = 4 ，给数组元素赋值，视图是否会更新</p></li><li><p>vm.arr.length = 0 ，修改数组的 length，视图是否会更新</p></li><li><p>vm.arr.push(4) ，视图是否会更新</p></li></ul><h3 id="响应式处理的入口"><a href="#响应式处理的入口" class="headerlink" title="响应式处理的入口"></a><strong>响应式处理的入口</strong></h3><p>整个响应式处理的过程是比较复杂的，下面我们先从</p><ul><li><p>src\core\instance\init.js</p><ul><li><p>initState(vm) vm 状态的初始化</p></li><li><p>初始化了 _data、_props、methods 等</p></li></ul></li><li><p>src\core\instance\state.js</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据的初始化 </span></span><br><span class="line"><span class="keyword">if</span> (opts.data) &#123; </span><br><span class="line">  initData(vm) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>initData(vm) vm 数据的初始化</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data </span><br><span class="line">  <span class="comment">// 初始化 _data，组件中 data 是函数，调用函数返回结果 </span></span><br><span class="line">  <span class="comment">// 否则直接返回 data </span></span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span> ? getData(data, vm) : data || &#123;&#125; </span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">// proxy data on instance </span></span><br><span class="line">  <span class="comment">// 获取 data 中的所有属性 </span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data) </span><br><span class="line">  <span class="comment">// 获取 props / methods </span></span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props </span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods </span><br><span class="line">  <span class="keyword">let</span> i = keys.length </span><br><span class="line">  <span class="comment">// 判断 data 上的成员是否和 props/methods 重名 </span></span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">// observe data </span></span><br><span class="line">  <span class="comment">// 数据的响应式处理 </span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>) &#125;</span><br></pre></td></tr></table></figure><ul><li>src\core\observer\index.js<ul><li>observe(value, asRootData)</li><li>负责为每一个 Object 类型的 value 创建一个 observer 实例</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"> value: any, </span></span></span><br><span class="line"><span class="function"><span class="params"> asRootData: ?boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 判断 value 是否是对象 </span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123; </span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ob: Observer | <span class="keyword">void</span> </span><br><span class="line"><span class="comment">// 如果 value 有 __ob__(observer对象) 属性 结束 </span></span><br><span class="line"><span class="keyword">if</span> (hasOwn(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123; </span><br><span class="line">  ob = value.__ob__ </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( </span><br><span class="line">  shouldObserve &amp;&amp; </span><br><span class="line">  !isServerRendering() &amp;&amp; </span><br><span class="line">  (<span class="built_in">Array</span>.isArray(value) || </span><br><span class="line">   isPlainObject(value)) &amp;&amp; </span><br><span class="line">  <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">  !value._isVue </span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// 创建一个 Observer 对象</span></span><br><span class="line">  ob = <span class="keyword">new</span> Observer(value) </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123; </span><br><span class="line">  ob.vmCount++ </span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> ob </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a><strong>Observer</strong></h3><ul><li>src\core\observer\index.js<ul><li>对对象做响应化处理</li><li>对数组做响应化处理</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 观测对象 </span></span><br><span class="line">  value: any; </span><br><span class="line">  <span class="comment">// 依赖对象 </span></span><br><span class="line">  dep: Dep; </span><br><span class="line">  <span class="comment">// 实例计数器 </span></span><br><span class="line">  vmCount: number; </span><br><span class="line">  <span class="comment">// number of vms that have this object as root $data </span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value: any</span>) &#123; </span><br><span class="line">    <span class="built_in">this</span>.value = value </span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep() </span><br><span class="line">    <span class="comment">// 初始化实例的 vmCount 为0 </span></span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span> </span><br><span class="line">    <span class="comment">// 将实例挂载到观测对象的 __ob__ 属性，设置为不可枚举 </span></span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>) </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123; </span><br><span class="line">      <span class="comment">// 数组的响应式处理 </span></span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123; </span><br><span class="line">        protoAugment(value, arrayMethods) </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys) </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为数组中的每一个对象创建一个 observer 实例 </span></span><br><span class="line">      <span class="built_in">this</span>.observeArray(value) </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// 对象的响应化处理 </span></span><br><span class="line">      <span class="comment">// 遍历对象中的每一个属性，转换成 setter/getter </span></span><br><span class="line">      <span class="built_in">this</span>.walk(value) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Walk through all properties and convert them into </span></span><br><span class="line"><span class="comment">  * getter/setters. This method should only be called when </span></span><br><span class="line"><span class="comment">  * value type is Object. </span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123; </span><br><span class="line">    <span class="comment">// 获取观察对象的每一个属性 </span></span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj) </span><br><span class="line">    <span class="comment">// 遍历每一个属性，设置为响应式数据 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123; </span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Observe a list of Array items. </span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123; </span><br><span class="line">      observe(items[i]) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>walk(obj)<ul><li>遍历 obj 的所有属性，为每一个属性调用 defifineReactive() 方法，设置 getter/setter</li></ul></li></ul><h3 id="defifineReactive"><a href="#defifineReactive" class="headerlink" title="defifineReactive()"></a><strong>defifineReactive()</strong></h3><ul><li><p>src\core\observer\index.js</p></li><li><p>defifineReactive(obj, key, val, customSetter, shallow)</p><ul><li>为一个对象定义一个响应式的属性，每一个属性对应一个 dep 对象</li><li>如果该属性的值是对象，继续调用 observe</li><li>如果给属性赋新值，继续调用 observe</li><li>如果数据更新发送通知</li></ul></li></ul><h3 id="对象响应式处理"><a href="#对象响应式处理" class="headerlink" title="对象响应式处理"></a><strong>对象响应式处理</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为一个对象定义一个响应式的属性 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Define a reactive property on an Object. </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">  obj: <span class="built_in">Object</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">  key: string, </span></span></span><br><span class="line"><span class="function"><span class="params">  val: any, </span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?<span class="built_in">Function</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 为每一个属性，创建依赖对象实例 </span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep() </span><br><span class="line">  <span class="comment">// 获取 obj 的属性描述符对象 </span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key) </span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 提供预定义的存取器函数 </span></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters </span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get </span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set </span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123; </span><br><span class="line">    val = obj[key] </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 判断是否递归观察子对象，并将子对象属性都转换成 getter/setter，返回子观察对象 </span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val) </span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>, </span><br><span class="line">    configurable: <span class="literal">true</span>, </span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">      <span class="comment">// 如果预定义的 getter 存在则 value 等于getter 调用的返回值 </span></span><br><span class="line">      <span class="comment">// 否则直接赋予属性值 </span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val </span><br><span class="line">      <span class="comment">// 如果存在当前依赖目标，即 watcher 对象，则建立依赖 </span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123; </span><br><span class="line">        <span class="comment">// dep() 添加相互的依赖 </span></span><br><span class="line">        <span class="comment">// 1个组件对应一个 watcher 对象 </span></span><br><span class="line">        <span class="comment">// 1个watcher会对应多个dep（要观察的属性很多） </span></span><br><span class="line">        <span class="comment">// 我们可以手动创建多个 watcher 监听1个属性的变化，1个dep可以对应多个watcher </span></span><br><span class="line">        dep.depend() </span><br><span class="line">        <span class="comment">// 如果子观察目标存在，建立子对象的依赖关系，将来 Vue.set() 会用到 </span></span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123; </span><br><span class="line">          childOb.dep.depend() </span><br><span class="line">          <span class="comment">// 如果属性是数组，则特殊处理收集数组对象依赖 </span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123; </span><br><span class="line">            dependArray(value) </span><br><span class="line">          &#125; </span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回属性值 </span></span><br><span class="line">      <span class="keyword">return</span> value </span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123; </span><br><span class="line">      <span class="comment">// 如果预定义的 getter 存在则 value 等于getter 调用的返回值 </span></span><br><span class="line">      <span class="comment">// 否则直接赋予属性值 </span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val </span><br><span class="line">      <span class="comment">// 如果新值等于旧值或者新值旧值为null则不执行 </span></span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span> </span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; </span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span> </span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123; </span><br><span class="line">        customSetter() </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果没有 setter 直接返回 </span></span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter </span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span> </span><br><span class="line">      <span class="comment">// 如果预定义setter存在则调用，否则直接更新新值 </span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123; </span><br><span class="line">        setter.call(obj, newVal) </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        val = newVal </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3. 如果新值是对象，观察子对象并返回 子的 observer 对象 </span></span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal) </span><br><span class="line">      <span class="comment">// 4. 发布更改通知 </span></span><br><span class="line">      dep.notify() </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组的响应式处理"><a href="#数组的响应式处理" class="headerlink" title="数组的响应式处理"></a><strong>数组的响应式处理</strong></h3><ul><li>Observer 的构造函数中</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的响应式处理 </span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123; </span><br><span class="line">  <span class="keyword">if</span> (hasProto) &#123; </span><br><span class="line">    protoAugment(value, arrayMethods) </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    copyAugment(value, arrayMethods, arrayKeys) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为数组中的每一个对象创建一个 observer 实例 </span></span><br><span class="line">  <span class="built_in">this</span>.observeArray(value) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="comment">// 编译对象中的每一个属性，转换成 setter/getter </span></span><br><span class="line">  <span class="built_in">this</span>.walk(value) </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src: <span class="built_in">Object</span></span>) </span>&#123; </span><br><span class="line">  <span class="comment">/* eslint-disable no-proto */</span> </span><br><span class="line">  target.__proto__ = src </span><br><span class="line">  <span class="comment">/* eslint-enable no-proto */</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* istanbul ignore next */</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span> (<span class="params">target: <span class="built_in">Object</span>, src: <span class="built_in">Object</span>, keys: <span class="built_in">Array</span>&lt;string&gt;</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i] </span><br><span class="line">    def(target, key, src[key]) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理数组修改数据的方法<ul><li>src\core\observer\array.js</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype </span><br><span class="line"><span class="comment">// 克隆数组的原型 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto) </span><br><span class="line"><span class="comment">// 修改数组元素的方法</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [ </span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span> </span><br><span class="line">]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Intercept mutating methods and emit events </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// cache original method </span></span><br><span class="line">  <span class="comment">// 保存数组原方法 </span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method] </span><br><span class="line">  <span class="comment">// 调用 Object.defineProperty() 重新定义修改数组的方法 </span></span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 执行数组的原始方法 </span></span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    <span class="comment">// 获取数组对象的 ob 对象 </span></span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__ </span><br><span class="line">    <span class="keyword">let</span> inserted </span><br><span class="line">    <span class="keyword">switch</span> (method) &#123; </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>: </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>: </span><br><span class="line">        inserted = args </span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>: </span><br><span class="line">        inserted = args.slice(<span class="number">2</span>) </span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对插入的新元素，重新遍历数组元素设置为响应式数据 </span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted) </span><br><span class="line">    <span class="comment">// notify change </span></span><br><span class="line">    <span class="comment">// 调用了修改数组的方法，调用数组的ob对象发送通知 </span></span><br><span class="line">    ob.dep.notify() </span><br><span class="line">    <span class="keyword">return</span> result </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Dep-类"><a href="#Dep-类" class="headerlink" title="Dep 类"></a><strong>Dep</strong> <strong>类</strong></h3><ul><li><p>src\core\observer\dep.js</p></li><li><p>依赖对象</p></li><li><p>记录 watcher 对象</p></li><li><p>depend() – watcher 记录对应的 dep</p></li><li><p>发布通知</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 在 defineReactive() 的 getter 中创建 dep 对象，并判断 Dep.target 是否有值（一会 再来看有什么 时候有值得）, 调用 dep.depend() </span><br><span class="line"><span class="number">2.</span> dep.depend() 内部调用 Dep.target.addDep(<span class="built_in">this</span>)，也就是 watcher 的 addDep() 方 法，它内部最 调用 dep.addSub(<span class="built_in">this</span>)，把 watcher 对象，添加到 dep.subs.push(watcher) 中，也 就是把订阅者 添加到 dep 的 subs 数组中，当数据变化的时候调用 watcher 对象的 update() 方法 </span><br><span class="line"><span class="number">3.</span> 什么时候设置的 Dep.target? 通过简单的案例调试观察。调用 mountComponent() 方法的时 候，创建了 渲染 watcher 对象，执行 watcher 中的 get() 方法 </span><br><span class="line"><span class="number">4.</span> get() 方法内部调用 pushTarget(<span class="built_in">this</span>)，把当前 Dep.target = watcher，同时把当前 watcher 入栈， 因为有父子组件嵌套的时候先把父组件对应的 watcher 入栈，再去处理子组件的 watcher，子 组件的处理完毕 后，再把父组件对应的 watcher 出栈，继续操作 </span><br><span class="line"><span class="number">5.</span> Dep.target 用来存放目前正在使用的watcher。全局唯一，并且一次也只能有一个 watcher 被使用 <span class="number">1234567891011</span> </span><br><span class="line"><span class="comment">// dep 是个可观察对象，可以有多个指令订阅它 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A dep is an observable that can have multiple </span></span><br><span class="line"><span class="comment">* directives subscribing to it. </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 静态属性，watcher 对象 </span></span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  <span class="comment">// dep 实例 Id </span></span><br><span class="line">  id: number; </span><br><span class="line">	<span class="comment">// dep 实例对应的 watcher 对象/订阅者数组 </span></span><br><span class="line">	subs: <span class="built_in">Array</span>&lt;Watcher&gt;; </span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="built_in">this</span>.id = uid++ </span><br><span class="line">    <span class="built_in">this</span>.subs = [] </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加新的订阅者 watcher 对象 </span></span><br><span class="line">  addSub (sub: Watcher) &#123; </span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除订阅者 </span></span><br><span class="line">  removeSub (sub: Watcher) &#123; </span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将观察对象和 watcher 建立依赖 </span></span><br><span class="line">  depend () &#123; </span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123; </span><br><span class="line">      <span class="comment">// 如果 target 存在，把 dep 对象添加到 watcher 的依赖中 </span></span><br><span class="line">      Dep.target.addDep(<span class="built_in">this</span>) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发布通知 </span></span><br><span class="line">  notify () &#123; </span><br><span class="line">    <span class="comment">// stabilize the subscriber list first </span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice() </span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123; </span><br><span class="line">      <span class="comment">// subs aren&#x27;t sorted in scheduler if not running async </span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct </span></span><br><span class="line">      <span class="comment">// order </span></span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用每个订阅者的update方法实现更新 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123; </span><br><span class="line">      subs[i].update() </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dep.target 用来存放目前正在使用的watcher </span></span><br><span class="line"><span class="comment">// 全局唯一，并且一次也只能有一个watcher被使用 </span></span><br><span class="line"><span class="comment">// The current target watcher being evaluated. </span></span><br><span class="line"><span class="comment">// This is globally unique because only one watcher </span></span><br><span class="line"><span class="comment">// can be evaluated at a time. </span></span><br><span class="line">Dep.target = <span class="literal">null</span> </span><br><span class="line"><span class="keyword">const</span> targetStack = [] </span><br><span class="line"><span class="comment">// 入栈并将当前 watcher 赋值给Dep.target </span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">target: ?Watcher</span>) </span>&#123; </span><br><span class="line">  targetStack.push(target) </span><br><span class="line">  Dep.target = target </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 出栈操作 </span></span><br><span class="line">  targetStack.pop() </span><br><span class="line">  Dep.target = targetStack[targetStack.length - <span class="number">1</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Watcher-类"><a href="#Watcher-类" class="headerlink" title="Watcher 类"></a><strong>Watcher</strong> <strong>类</strong></h3><ul><li><p>Watcher 分为三种，Computed Watcher、用户 Watcher (侦听器)、<strong>渲染</strong> <strong>Watcher</strong></p></li><li><p>渲染 Watcher 的创建时机</p><ul><li>/src/core/instance/lifecycle.js</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">	vm: Component, </span></span></span><br><span class="line"><span class="function"><span class="params">   el: ?Element, </span></span></span><br><span class="line"><span class="function"><span class="params">   hydrating?: boolean </span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Component</span> </span>&#123; </span><br><span class="line">  vm.$el = el ……callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>) </span><br><span class="line">  <span class="keyword">let</span> updateComponent </span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span> </span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123; </span><br><span class="line">    …… </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      vm._update(vm._render(), hydrating) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建渲染 Watcher，expOrFn 为 updateComponent </span></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor </span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child </span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined </span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123; before () &#123; </span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; </span><br><span class="line">      callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>) </span><br><span class="line">  hydrating = <span class="literal">false</span> </span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self </span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123; </span><br><span class="line">    vm._isMounted = <span class="literal">true</span> callHook(vm, <span class="string">&#x27;mounted&#x27;</span>) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>渲染 wacher 创建的位置 lifecycle.js 的 mountComponent 函数中</p></li><li><p>Wacher 的构造函数初始化，处理 expOrFn （渲染 watcher 和侦听器处理不同）</p></li><li><p>调用 this.get() ，它里面调用 pushTarget() 然后 this.getter.call(vm, vm) （对于渲染 wacher 调 用 updateComponent），如果是用户 wacher 会获取属性的值（触发get操作）</p></li><li><p>当数据更新的时候，dep 中调用 notify() 方法，notify() 中调用 wacher 的 update() 方法</p></li><li><p>update() 中调用 queueWatcher()</p></li><li><p>queueWatcher() 是一个核心方法，去除重复操作，调用 flflushSchedulerQueue() 刷新队列并执行watcher</p></li><li><p>flflushSchedulerQueue() 中对 wacher 排序，遍历所有 wacher ，如果有 before，触发生命周期的钩子函数 beforeUpdate，执行 wacher.run()，它内部调用 this.get()，然后调用 this.cb() (渲染wacher 的 cb 是 noop)</p></li><li><p>整个流程结束</p></li></ul><h3 id="实例方法-数据"><a href="#实例方法-数据" class="headerlink" title="实例方法/数据"></a><strong>实例方法</strong>/数据</h3><h4 id="vm-set"><a href="#vm-set" class="headerlink" title="vm.$set"></a><strong>vm.$set</strong></h4><ul><li>功能<ul><li>向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于 向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = ‘hi’)</li></ul></li></ul><blockquote><p>**注意:**对象不能是 Vue 实例，或者 Vue 实例的根数据对象。</p></blockquote><ul><li>示例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$set(obj,<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>定义位置</strong></p><ul><li>Vue.set()<ul><li>global-api/index.js</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态方法 set/delete/nextTick Vue.set = set</span></span><br><span class="line">Vue.delete = del</span><br><span class="line">Vue.nextTick = nextTick</span><br></pre></td></tr></table></figure><ul><li>vm.$set()<ul><li>instance/index.js</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 vm 的 $data/$props/$set/$delete/$watch </span></span><br><span class="line"><span class="comment">// instance/state.js</span></span><br><span class="line">stateMixin(Vue)</span><br><span class="line"><span class="comment">// instance/state.js</span></span><br><span class="line">Vue.prototype.$set = set</span><br><span class="line">Vue.prototype.$delete = del</span><br></pre></td></tr></table></figure><p><strong>源码</strong></p><ul><li>set() 方法<ul><li>observer/index.js</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set a property on an object. Adds the new property and</span></span><br><span class="line"><span class="comment"> * triggers change notification if the property doesn&#x27;t</span></span><br><span class="line"><span class="comment"> * already exist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: <span class="built_in">Array</span>&lt;any&gt; | <span class="built_in">Object</span>, key: any, val: any</span>): <span class="title">any</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    (isUndef(target) || isPrimitive(target))</span><br><span class="line">)&#123;</span><br><span class="line">  warn(<span class="string">`Cannot set reactive property on undefined, null, or primitive</span></span><br><span class="line"><span class="string">  value: <span class="subst">$&#123;(target: any)&#125;</span>`</span>)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 判断 target 是否是对象，key 是否是合法的索引</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">	target.length = <span class="built_in">Math</span>.max(target.length, key) </span><br><span class="line">  <span class="comment">// 通过 splice 对key位置的元素进行替换</span></span><br><span class="line">	<span class="comment">// splice 在 array.js进行了响应化的处理 target.splice(key, 1, val)</span></span><br><span class="line">	<span class="keyword">return</span> val </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 key 在对象中已经存在直接赋值</span></span><br><span class="line"><span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">		<span class="keyword">return</span> val </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 target 中的 observer 对象</span></span><br><span class="line"><span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line"><span class="comment">// 如果 target 是 vue 实例或者$data 直接返回 </span></span><br><span class="line"><span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">&#x27;Avoid adding reactive properties to a Vue instance or its root $data</span></span><br><span class="line"><span class="string">  &#x27;</span>+</span><br><span class="line">  <span class="string">&#x27;at runtime - declare it upfront in the data option.&#x27;</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> val </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 ob 不存在，target 不是响应式对象直接赋值 </span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">		<span class="keyword">return</span> val </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把 key 设置为响应式属性 </span></span><br><span class="line">  defineReactive(ob.value, key, val) </span><br><span class="line">  <span class="comment">// 发送通知</span></span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vm-delete"><a href="#vm-delete" class="headerlink" title="vm.$delete"></a><strong>vm.$delete</strong></h4><ul><li>功能<ul><li>删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。</li></ul></li></ul><blockquote><p>**注意:**目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。</p></blockquote><ul><li>示例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$delete(vm.obj,<span class="string">&#x27;msg&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>定义位置</strong></p><ul><li>Vue.delete()<ul><li>global-api/index.js</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态方法 set/delete/nextTick </span></span><br><span class="line">Vue.set = set</span><br><span class="line">Vue.delete = del</span><br><span class="line">Vue.nextTick = nextTick</span><br></pre></td></tr></table></figure><ul><li>vm.$delete()<ul><li>instance/index.js</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 vm 的 $data/$props/$set/$delete/$watch </span></span><br><span class="line">stateMixin(Vue)</span><br><span class="line"><span class="comment">// instance/state.js</span></span><br><span class="line">Vue.prototype.$set = set</span><br><span class="line">Vue.prototype.$delete = del</span><br></pre></td></tr></table></figure><p><strong>源码</strong></p><ul><li>src\core\observer\index.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delete a property and trigger change if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">del</span> (<span class="params">target: <span class="built_in">Array</span>&lt;any&gt; | <span class="built_in">Object</span>, key: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">(isUndef(target) || isPrimitive(target)) )&#123;</span><br><span class="line">    warn(<span class="string">`Cannot delete reactive property on undefined, null, or primitive</span></span><br><span class="line"><span class="string">		value: <span class="subst">$&#123;(target: any)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否是数组，以及 key 是否合法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">	<span class="comment">// 如果是数组通过 splice 删除 </span></span><br><span class="line">  <span class="comment">// splice 做过响应式处理 </span></span><br><span class="line">  target.splice(key, <span class="number">1</span>) </span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 target 的 ob 对象</span></span><br><span class="line"><span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line"><span class="comment">// target 如果是 Vue 实例或者 $data 对象，直接返回 </span></span><br><span class="line"><span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">&#x27;Avoid deleting properties on a Vue instance or its root $data &#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;- just set it to null.&#x27;</span></span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 target 对象没有 key 属性直接返回 if (!hasOwn(target, key)) &#123;</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除属性</span></span><br><span class="line"><span class="keyword">delete</span> target[key] </span><br><span class="line"><span class="keyword">if</span> (!ob) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 ob 发送通知</span></span><br><span class="line">  ob.dep.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vm-watch"><a href="#vm-watch" class="headerlink" title="vm.$watch"></a><strong>vm.$watch</strong></h4><p>vm.$watch( expOrFn, callback, [options] )</p><ul><li><p>功能</p><ul><li>观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只 接受监督的键路径。对于更复杂的表达式，用一个函数取代。</li></ul></li><li><p>参数</p><ul><li><p>expOrFn:要监视的 $data 中的属性，可以是表达式或函数</p></li><li><p>callback:数据变化后执行的函数</p><ul><li>函数:回调函数</li><li>对象:具有 handler 属性(字符串或者函数)，如果该属性为字符串则 methods 中相应 的定义</li></ul></li><li><p>options:可选的选项</p><ul><li>deep:布尔类型，深度监听</li><li>immediate:布尔类型，是否立即执行一次回调函数</li></ul></li></ul></li><li><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    b: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    msg: <span class="string">&#x27;Hello Vue&#x27;</span>,</span><br><span class="line">    user: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;诸葛&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;亮&#x27;</span> </span><br><span class="line">    &#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// expOrFn 是表达式</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;msg&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newVal, oldVal)</span><br><span class="line">&#125;)</span><br><span class="line">vm.$watch(<span class="string">&#x27;user.firstName&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newVal)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// expOrFn 是函数 vm.$watch(function () &#123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newVal)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// deep 是 true，消耗性能</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;user&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 此时的 newVal 是 user 对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(newVal === vm.user)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">deep: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="comment">// immediate 是 true</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;msg&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newVal)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  immediate: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="三种类型的-Watcher-对象"><a href="#三种类型的-Watcher-对象" class="headerlink" title="三种类型的 Watcher 对象"></a><strong>三种类型的</strong> <strong>Watcher</strong> <strong>对象</strong></h4><ul><li>没有静态方法，因为 $watch 方法中要使用 Vue 的实例</li><li>Watcher 分三种:计算属性 Watcher、用户 Watcher (侦听器)、渲染 Watcher</li><li>创建顺序:计算属性 Watcher、用户 Watcher (侦听器)、渲染 Watcher</li><li>vm.$watch()<ul><li>src\core\instance\state.js</li></ul></li></ul><p><strong>源码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn: string | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: <span class="built_in">Object</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 Vue 实例 this</span></span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span> </span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">	<span class="comment">// 判断如果 cb 是对象执行 createWatcher</span></span><br><span class="line">    <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">  &#125;</span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line">  <span class="comment">// 标记为用户 watcher</span></span><br><span class="line">  options.user = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 创建用户 watcher 对象</span></span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options) </span><br><span class="line">  <span class="comment">// 判断 immediate 如果为 true</span></span><br><span class="line">  <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">  <span class="comment">// 立即执行一次 cb 回调，并且把当前值传入 </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      cb.call(vm, watcher.value)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      handleError(error, vm, <span class="string">`callback for immediate watcher</span></span><br><span class="line"><span class="string">  &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span>)</span><br><span class="line">  &#125; &#125;</span><br><span class="line">  <span class="comment">// 返回取消监听的方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    watcher.teardown()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看渲染 watcher 的执行过程<ul><li>当数据更新，defineReactive 的 set 方法中调用 dep.notify()</li><li>调用 watcher 的 update()</li><li>调用 queueWatcher()，把 wacher 存入队列，如果已经存入，不重复添加</li><li>循环调用 flushSchedulerQueue()<ul><li>通过 nextTick()，在消息循环结束之前时候调用 flushSchedulerQueue()</li></ul></li><li>调用 wacher.run()<ul><li>调用 wacher.get() 获取最新值</li><li>如果是渲染 wacher 结束</li><li>如果是用户 watcher，调用 this.cb()</li></ul></li></ul></li></ul><h4 id="异步更新队列nextTick"><a href="#异步更新队列nextTick" class="headerlink" title="异步更新队列nextTick()"></a><strong>异步更新队列nextTick()</strong></h4><ul><li>Vue 更新 DOM 是异步执行的，批量的<ul><li>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</li></ul></li><li>vm.$nextTick(function () { /* 操作 DOM */ }) / Vue.nextTick(function () {})</li></ul><p><strong>vm.$nextTick()</strong> <strong>代码演示</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">&#x27;Hello nextTick&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      name: <span class="string">&#x27;Vue.js&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      title: <span class="string">&#x27;Title&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.msg = <span class="string">&#x27;Hello World&#x27;</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.name = <span class="string">&#x27;Hello snabbdom&#x27;</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.title = <span class="string">&#x27;Vue.js&#x27;</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.p1.textContent)</span></span><br><span class="line">&#125;) &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>定义位置</strong></p><ul><li>src\core\instance\render.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span> (<span class="params">fn: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextTick(fn, <span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码</strong></p><ul><li>手动调用 vm.$nextTick()</li><li>在 Watcher 的 queueWatcher 中执行 nextTick()</li><li>src\core\util\next-tick.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"><span class="comment">// The nextTick behavior leverages the microtask queue, which can be</span></span><br><span class="line">accessed</span><br><span class="line"><span class="comment">// via either native Promise.then or MutationObserver.</span></span><br><span class="line"><span class="comment">// MutationObserver has wider support, however it is seriously bugged in</span></span><br><span class="line"><span class="comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span><br><span class="line"><span class="comment">// completely stops working after triggering a few times... so, if native</span></span><br><span class="line"><span class="comment">// Promise is available, we will use it:</span></span><br><span class="line"><span class="comment">/* istanbul ignore next, $flow-disable-line */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="comment">// In problematic UIWebViews, Promise.then doesn&#x27;t completely break,</span></span><br><span class="line">but</span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into</span></span><br><span class="line">the</span><br><span class="line">    <span class="comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">&#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">isNative(MutationObserver) ||</span><br><span class="line"> <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">&#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Technically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) </span>&#123; <span class="keyword">let</span> _resolve</span><br><span class="line"><span class="comment">// 把 cb 加上异常处理存入 callbacks 数组中 callbacks.push(() =&gt; &#123;</span></span><br><span class="line"><span class="keyword">if</span> (cb) &#123; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 调用 cb()</span></span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) </span><br><span class="line">      _resolve(ctx)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc()</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line"><span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="comment">// 返回 promise 对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>Post title：Vue源码剖析(一) — Vue首次渲染</li><li>Post author：wkxk</li><li>Create time：2021-04-23 15:29:09</li><li>Post link：http://www.iwkxk.com/2021/04/23/Vue首次渲染/</li><li>Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.</li></ul></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2021/04/23/Vue%E8%99%9A%E6%8B%9FDOM/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">Vue源码剖析(二) — Vue虚拟DOM</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2021/04/23/Snabbdom%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/"><span class="title flex-center"><span class="post-nav-title-item">Snabbdom深入剖析</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;Comments</i></div><div id="gitalk-container"></div><script data-pjax src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script><script data-pjax>function loadGitalk(){let e=decodeURI(location.pathname);e.length>50&&(e=e.substring(0,47)+"...");try{Gitalk&&new Gitalk({clientID:"95ee2e163d7f20d8de19",clientSecret:"ad675c3bdff4af0fa754ab836be591c2e3aeb688",repo:"my-gitalk",owner:"wkxk",admin:["wkxk"],id:e,language:"zh"}).render("gitalk-container")}catch(e){window.Gitalk=null}}{const e=setTimeout(()=>{loadGitalk(),clearTimeout(e)},1e3)}</script></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span>&nbsp;-&nbsp; 2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">wkxk</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">Totalview&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue%E6%BA%90%E7%A0%81%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="nav-number">1.</span> <span class="nav-text">Vue源码的获取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">源码目录结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-Flow"><span class="nav-number">3.</span> <span class="nav-text">了解 Flow</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E8%AE%BE%E7%BD%AE"><span class="nav-number">4.</span> <span class="nav-text">调试设置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%8C%85"><span class="nav-number">4.1.</span> <span class="nav-text">打包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95"><span class="nav-number">4.2.</span> <span class="nav-text">调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-%E7%9A%84%E4%B8%8D%E5%90%8C%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC"><span class="nav-number">4.3.</span> <span class="nav-text">Vue 的不同构建版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AF%E8%AF%AD"><span class="nav-number">4.4.</span> <span class="nav-text">术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runtime-Compiler-vs-Runtime-only"><span class="nav-number">4.5.</span> <span class="nav-text">Runtime + Compiler vs. Runtime-only</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6"><span class="nav-number">5.</span> <span class="nav-text">寻找入口文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%9E%84%E5%BB%BA"><span class="nav-number">6.</span> <span class="nav-text">执行构建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%85%A5%E5%8F%A3%E5%BC%80%E5%A7%8B"><span class="nav-number">7.</span> <span class="nav-text">从入口开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-number">8.</span> <span class="nav-text">Vue 的构造函数在哪里</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E4%B8%AA%E5%AF%BC%E5%87%BA-Vue-%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="nav-number">9.</span> <span class="nav-text">四个导出 Vue 的模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">10.</span> <span class="nav-text">Vue 的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A6%96%E6%AC%A1%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="nav-number">11.</span> <span class="nav-text">首次渲染过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="nav-number">12.</span> <span class="nav-text">数据响应式原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%9F%A5%E7%9C%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E5%86%B3%E4%B8%8B%E9%9D%A2%E9%97%AE%E9%A2%98"><span class="nav-number">12.1.</span> <span class="nav-text">通过查看源码解决下面问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%A4%84%E7%90%86%E7%9A%84%E5%85%A5%E5%8F%A3"><span class="nav-number">12.2.</span> <span class="nav-text">响应式处理的入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Observer"><span class="nav-number">12.3.</span> <span class="nav-text">Observer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defifineReactive"><span class="nav-number">12.4.</span> <span class="nav-text">defifineReactive()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%93%8D%E5%BA%94%E5%BC%8F%E5%A4%84%E7%90%86"><span class="nav-number">12.5.</span> <span class="nav-text">对象响应式处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%A4%84%E7%90%86"><span class="nav-number">12.6.</span> <span class="nav-text">数组的响应式处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dep-%E7%B1%BB"><span class="nav-number">12.7.</span> <span class="nav-text">Dep 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Watcher-%E7%B1%BB"><span class="nav-number">12.8.</span> <span class="nav-text">Watcher 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-%E6%95%B0%E6%8D%AE"><span class="nav-number">12.9.</span> <span class="nav-text">实例方法&#x2F;数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vm-set"><span class="nav-number">12.9.1.</span> <span class="nav-text">vm.$set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vm-delete"><span class="nav-number">12.9.2.</span> <span class="nav-text">vm.$delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vm-watch"><span class="nav-number">12.9.3.</span> <span class="nav-text">vm.$watch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84-Watcher-%E5%AF%B9%E8%B1%A1"><span class="nav-number">12.9.4.</span> <span class="nav-text">三种类型的 Watcher 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97nextTick"><span class="nav-number">12.9.5.</span> <span class="nav-text">异步更新队列nextTick()</span></a></li></ol></li></ol></li></ol></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/code-copy.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1});document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),e.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>