<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="JavaScript,Vue2,Vue3,Vite,Webpack,node"><meta name="description" content="wkxk的个人博客，主要涉及到编程(JavaScript,Vue2,Vue3,Webpack,node),助于个人学习提升，分享学习过程"><meta name="author" content="wkxk"><title>函数式编程与JS异步编程、手写Promise | wkxk&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/logo.7kmeykeizco0.svg"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"www.iwkxk.com",root:"/",language:"zh",path:"search.xml"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0,init_open:!0},style:{primary_color:"#0066CC",avatar:"https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/avator.2use3mem6940.svg",favicon:"https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/logo.7kmeykeizco0.svg",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"愿你眼里有光，眼底无霜，心有大海，胸无睚眦。风尘自仆仆，你我当归人。"},scroll:{progress_bar:{enable:!0},percent:{enable:!0}}},local_search:{enable:!0,preload:!0},code_copy:{enable:!0,style:"default"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.2"},KEEP.language_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"}</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-title" href="/">wkxk&#39;s Blog</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">HOME</a></li><li class="menu-item"><a href="/archives">ARCHIVES</a></li><li class="menu-item"><a href="/links">LINKS</a></li><li class="menu-item"><a href="/about">ABOUT</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">HOME</a></li><li class="drawer-menu-item flex-center"><a href="/archives">ARCHIVES</a></li><li class="drawer-menu-item flex-center"><a href="/links">LINKS</a></li><li class="drawer-menu-item flex-center"><a href="/about">ABOUT</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">函数式编程与JS异步编程、手写Promise</span></div><div class="article-header"><div class="avatar"><img src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/avator.2use3mem6940.svg"></div><div class="info"><div class="author"><span class="name">wkxk</span> <span class="author-label">前端攻城狮</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp;2021-04-20 17:35:17 </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/JavaScript%E9%AB%98%E9%98%B6%E7%94%A8%E6%B3%95/">JavaScript高阶用法</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/JavaScript/">JavaScript</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>4.2k Words</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>18 Mins</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><p>概念：（Functional Programming 简称FP） 一种编程思想，对运算过程的一种抽象。</p><p>将程序的过程抽象成函数（数学上的函数，是某种关系的映射）。</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><blockquote><p>函数是一等公民：函数作为参数，函数作为返回值，函数可以被一个变量存储。</p><p>常用的高阶函数：forEach, map,every,some…</p></blockquote><h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分装一个forEach,接收两个参数，数组，函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span> (<span class="params">array, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key) fn(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">forEach([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><blockquote><p>意义：可以将函数的过程抽象化，我们只需知道我们想要的结果和实现的方法。将过程抽象化。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装once接收一个函数作为入参，返回一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">once</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> done = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">      done = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> pay = once(<span class="function"><span class="keyword">function</span> (<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`支付: <span class="subst">$&#123;money&#125;</span> RMB`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">pay(<span class="number">5</span>) <span class="comment">// 只会执行一次</span></span><br><span class="line">pay(<span class="number">5</span>)</span><br><span class="line">pay(<span class="number">5</span>)</span><br><span class="line">pay(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><blockquote><p>概念：一种固定的输入总会得到固定的结果。</p></blockquote><blockquote><p>Slice: 不会改变原数组 （纯函数）。</p><p>splice：会改变原数组（不纯的函数）。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// [1] 纯函数</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">0</span>, <span class="number">3</span>)) <span class="comment">// [1, 2, 3] 不纯的函数</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">0</span>, <span class="number">3</span>)) <span class="comment">// [4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">0</span>, <span class="number">3</span>))	<span class="comment">// []</span></span><br></pre></td></tr></table></figure><h2 id="lodash-工具库"><a href="#lodash-工具库" class="headerlink" title="lodash 工具库"></a>lodash 工具库</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flowRight函数组合，curry柯里化</span></span><br><span class="line"><span class="keyword">const</span> &#123; flowRight, curry &#125; = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="comment">// fp模块</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>概念：在一个函数内部的一个函数，内部函数可以访问到外部函数作用域内的成员变量。</p></blockquote><blockquote><p>优点：可以延长函数内部成员的生命周期。</p><p>缺点：会造成内存泄露。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个缓存区域</span></span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 入参转化成字符串</span></span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">// 存在直接取缓存，不存在就调用获取</span></span><br><span class="line">    cache[key] = cache[key] || fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">// 返回缓存数据</span></span><br><span class="line">    <span class="keyword">return</span> cache[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArea);</span><br><span class="line"><span class="keyword">const</span> fn2 = memoize(getArea)</span><br><span class="line"><span class="built_in">console</span>.log(fn2(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(fn2(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(fn2(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(fn2(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><blockquote><p>概念：将函数的入参的一部分先传入，传入的这部分参数固定不变，等待接收剩余参数，最后将结果返回。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求封装一个函数使fn(1, 2, 3),fn(1, 2)(3),fn(1)(2, 3)值相等</span></span><br><span class="line"><span class="comment">// 柯里化函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断实参长度和形参长度是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (args.length &lt; fn.length) &#123;</span><br><span class="line">      <span class="comment">// 小于的话返回一个函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 将剩余的参数和初始传递参数拼接之后一起传递，返回最终的结果</span></span><br><span class="line">          <span class="keyword">return</span> curried(...args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度相等的话，直接返回最终结果</span></span><br><span class="line">    <span class="keyword">return</span> fn(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个算法函数</span></span><br><span class="line"><span class="keyword">const</span> getSum = curry(<span class="function">(<span class="params">a, b, c</span>) =&gt;</span> a + b + c)</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><blockquote><p>函数组合：将其他函数进行组合，形成一个新的函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fp模块</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="comment">// const reverse = array =&gt; array.reverse()</span></span><br><span class="line"><span class="comment">// const last = array =&gt; array[0]</span></span><br><span class="line"><span class="comment">// const toUpper = s =&gt; s.toUpperCase() </span></span><br><span class="line"><span class="comment">// const compose = (...args) =&gt; value =&gt; args.reverse().reduce((acc, fn) =&gt; fn(acc), value)</span></span><br><span class="line"><span class="comment">// 直接使用lodash的函数组合flowRight，柯里化函数toUpper，last，reverse,从右往左依次执行</span></span><br><span class="line"><span class="keyword">const</span> fn = fp.flowRight(fp.toUpper, fp.last, fp.reverse)</span><br><span class="line"><span class="built_in">console</span>.log(fn([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])); <span class="comment">// &#x27;THREE&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="函子"><a href="#函子" class="headerlink" title="函子"></a>函子</h2><blockquote><p>概念：特殊的容器，用来存储值和值的变形关系。</p></blockquote><h3 id="Functor函子"><a href="#Functor函子" class="headerlink" title="Functor函子"></a>Functor函子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个静态方法of用来创建实例对象</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储一个私有的值，只能在函子内部使用</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暴露一个map方法，该方法接受一个函数作为参数,返回一个处理之后的新的函子</span></span><br><span class="line">  map (fn) &#123;</span><br><span class="line">    <span class="comment">// return new Container(fn(this._value))</span></span><br><span class="line">    <span class="keyword">return</span> Container.of(fn(<span class="built_in">this</span>._value)) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const r = new Container(&#x27;one&#x27;)</span></span><br><span class="line"><span class="comment">//             .map(x =&gt; x.toUpperCase())</span></span><br><span class="line"><span class="keyword">const</span> r = Container.of(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">            .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure><h3 id="MayBe函子"><a href="#MayBe函子" class="headerlink" title="MayBe函子"></a>MayBe函子</h3><blockquote><p>处理空值的函子</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MayBe</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个静态方法of用来创建实例对象</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MayBe(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储一个私有的值，只能在函子内部使用</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露一个map方法，该方法接受一个函数作为参数,返回一个处理之后的新的函子</span></span><br><span class="line">  map (fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.isEmpty() ? MayBe.of(<span class="built_in">this</span>._value) :  MayBe.of(fn(<span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断值是否为空</span></span><br><span class="line">  isEmpty () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value === <span class="literal">null</span> || <span class="built_in">this</span>._value === <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r = MayBe.of(<span class="literal">undefined</span>)</span><br><span class="line">            .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line">            </span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure><h3 id="Either函子"><a href="#Either函子" class="headerlink" title="Either函子"></a>Either函子</h3><blockquote><p>处理异常的函子</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Left</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态of</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Left(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储一个私有的值，只能在函子内部使用</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露一个map方法，该方法接受一个函数作为参数,返回本身</span></span><br><span class="line">  map (fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理正确数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Right</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态of</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Right(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储一个私有的值，只能在函子内部使用</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露一个map方法，该方法接受一个函数作为参数,返回</span></span><br><span class="line">  map (fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> Right.of(fn(<span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> left = Left.of(<span class="number">5</span>)</span><br><span class="line">              .map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> right = Right.of(<span class="number">5</span>)</span><br><span class="line">              .map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>)</span><br><span class="line"><span class="comment">// console.log(left, right);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseString</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 返回正确的结果</span></span><br><span class="line">    <span class="keyword">return</span> Right.of(<span class="built_in">JSON</span>.parse(str))</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 处理异常，返回异常信息</span></span><br><span class="line">    <span class="keyword">return</span> Left.of(&#123;  <span class="attr">error</span>: error.message&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(parseString(<span class="string">&#x27;&#123; neme: zs &#125;&#x27;</span>)); <span class="comment">// Left &#123; _value: &#123; error: &#x27;Unexpected token n in JSON at position 2&#x27; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(parseString(<span class="string">&#x27;&#123; &quot;neme&quot;: &quot;zs&quot; &#125;&#x27;</span>)); <span class="comment">// Right &#123; _value: &#123; neme: &#x27;zs&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="IO函子"><a href="#IO函子" class="headerlink" title="IO函子"></a>IO函子</h3><blockquote><p>内部存储一个函数，在需要时调用</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IO</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态of接收一个值，返回一个函数,将来需要时在调用</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function">() =&gt;</span> x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储一个函数</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = fn</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个新的IO，为了将当前的_value和map中传入的函数组合成新的函数作为IO的参数</span></span><br><span class="line">  map (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(fp.flowRight(f, <span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IO </span></span><br><span class="line"><span class="keyword">const</span> r = IO.of(process)</span><br><span class="line">            <span class="comment">// 返回node的执行路径 &#123; _value: [Function] &#125; </span></span><br><span class="line">            .map(<span class="function"><span class="params">x</span> =&gt;</span> x.execPath)</span><br><span class="line"><span class="built_in">console</span>.log(r._value()); <span class="comment">// /usr/local/bin/node</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Task函子"><a href="#Task函子" class="headerlink" title="Task函子"></a>Task函子</h3><blockquote><p>函子可以处理异步</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入folktale的组合函数compose，curry</span></span><br><span class="line"><span class="keyword">const</span> &#123; compose, curry &#125; = <span class="built_in">require</span>(<span class="string">&#x27;folktale/core/lambda&#x27;</span>)</span><br><span class="line"><span class="comment">// folktale的curry</span></span><br><span class="line"><span class="keyword">const</span> f = curry(<span class="number">3</span>, <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> x + y + z)</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入lodash的fp模块的函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; toUpper, first, split, find &#125; = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fn = compose(toUpper, first)</span><br><span class="line"><span class="keyword">const</span> r = fn([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br><span class="line"><span class="comment">// 引入folktale的异函数，返回一个函子</span></span><br><span class="line"><span class="keyword">const</span> &#123; task &#125; = <span class="built_in">require</span>(<span class="string">&#x27;folktale/concurrency/task&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// task传递一个函数，参数是resolver</span></span><br><span class="line">  <span class="keyword">return</span> task(<span class="function"><span class="params">resolver</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 调用文件读取，接受三个参数，文件名，字符编码，回掉，错误优先</span></span><br><span class="line">    fs.readFile(filename, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) resolver.reject(err)</span><br><span class="line">      resolver.resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// readFile调用返回的是Task函子，调用run方法</span></span><br><span class="line">readFile(<span class="string">&#x27;package.json&#x27;</span>)</span><br><span class="line">  .map(split(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">  .map(find(<span class="function"><span class="params">x</span> =&gt;</span> x.includes(<span class="string">&#x27;version&#x27;</span>)))</span><br><span class="line">  .run()</span><br><span class="line">  <span class="comment">// 监听run方法处理的结果</span></span><br><span class="line">  .listen(&#123;</span><br><span class="line">    onRejected: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;,</span><br><span class="line">    onResolved: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="Pointed函子"><a href="#Pointed函子" class="headerlink" title="Pointed函子"></a>Pointed函子</h3><blockquote><p>Pointed 函子是实现了 of 静态方法的函子,避免了重复使用new来构建对象。</p><p>of 方法用来把值放到上下文。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123; </span><br><span class="line"><span class="comment">// Point函子</span></span><br><span class="line"><span class="comment">// 作用是把值放到一个新的函子里面返回，返回的函子就是一个上下文</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Container(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Monad函子"><a href="#Monad函子" class="headerlink" title="Monad函子"></a>Monad函子</h3><blockquote><p>Monad 函子是可以变扁的 Pointed 函子，用来解决IO函子嵌套问题，IO(IO(x))。</p><p>一个函子如果具有 join 和 of 两个方法并遵守一些定律就是一个 Monad。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IO</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态of接收一个值，返回一个函数,将来需要时在调用</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储一个函数</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = fn</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新的IO，为了将当前的_value和map中传入的函数组合成新的函数作为IO的参数</span></span><br><span class="line">  map (fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(fp.flowRight(fn, <span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  join () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同时调用 map join</span></span><br><span class="line">  flatMap (fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.map(fn).join()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回一个IO函子等待调用处理</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFileSync(filename, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印上一步的IO函子</span></span><br><span class="line"><span class="keyword">const</span> print = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = readFile(<span class="string">&#x27;package.json&#x27;</span>)</span><br><span class="line">          .flatMap(print)</span><br><span class="line">          .join()</span><br></pre></td></tr></table></figure><h1 id="JavaScript-异步编程"><a href="#JavaScript-异步编程" class="headerlink" title="JavaScript 异步编程"></a>JavaScript 异步编程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>JavaScript 语言的执行环境是单线程的，一次只能执行一个任务，多任务需要排队等候，这种模式可能会阻塞代码，导致代码执行效率低下。为了避免这个问题，出现了异步编程。一般是通过 callback 回调函数、事件发布/订阅、Promise 等来组织代码，本质都是通过回调函数来实现异步代码的存放与执行。</li></ul><h2 id="EventLoop-事件环和消息队列"><a href="#EventLoop-事件环和消息队列" class="headerlink" title="EventLoop 事件环和消息队列"></a>EventLoop 事件环和消息队列</h2><ul><li><strong>EventLoop</strong> 是一种循环机制 ，不断去轮询一些队列 ，从中找到 需要执行的任务并按顺序执行的一个执行模型。</li><li><strong>消息队列</strong> 是用来存放宏任务的队列， 比如定时器时间到了， 定时间内传入的方法引用会存到该队列， ajax回调之后的执行方法也会存到该队列。</li></ul><p>![image-20210422130003619](/Users/wkxk/Library/Application Support/typora-user-images/image-20210422130003619.png)</p><blockquote><p>一开始整个脚本作为一个宏任务执行。执行过程中同步代码直接执行，宏任务等待时间到达或者成功后，将方法的回调放入宏任务队列中，微任务进入微任务队列。</p><p>当前主线程的宏任务执行完出队，检查并清空微任务队列。接着执行浏览器 UI 线程的渲染工作，检查web worker 任务，有则执行。</p><p>然后再取出一个宏任务执行。以此循环…</p></blockquote><h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h2><ul><li><p><strong>宏任务</strong>可以理解为每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</p><ul><li>浏览器为了让 JS 内部宏任务 与 DOM 操作能够有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始前，对页面进行重新渲染。</li><li>宏任务包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、MessageChannel 等</li></ul></li><li><p><strong>微任务</strong>可以理解是在当前任务执行结束后需要立即执行的任务。也就是说，在当前任务后，在渲染之前，执行清空微任务。</p><p>所以它的响应速度相比宏任务会更快，因为无需等待 UI 渲染。</p><ul><li>微任务包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)等</li></ul></li></ul><h2 id="Promise手写实现"><a href="#Promise手写实现" class="headerlink" title="Promise手写实现"></a>Promise手写实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"><span class="comment">// 完成状态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line"><span class="comment">// 失败状态</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步执行方法封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncExecFun</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> fn(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行promise resolve功能</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise, res, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回同一个promise</span></span><br><span class="line">  <span class="keyword">if</span> (promise === res) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise #&lt;MyPromise&gt;&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// promise结果</span></span><br><span class="line">  <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    res.then(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非promise结果</span></span><br><span class="line">    resolve(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 是个构造函数</span></span><br><span class="line"><span class="comment"> * 2. 传入一个可执行函数 函数的入参第一个为 fullFill函数 第二个为 reject函数；  函数立即执行，  参数函数异步执行</span></span><br><span class="line"><span class="comment"> * 3. 状态一旦更改就不可以变更  只能 pending =&gt; fulfilled 或者  pending =&gt; rejected</span></span><br><span class="line"><span class="comment"> * 4. then 的时候要处理入参的情况 successCallback 和failCallback 均可能为非函数</span></span><br><span class="line"><span class="comment"> *      默认的 failCallback 一定要将异常抛出， 这样下一个promise便可将其捕获 异常冒泡的目的</span></span><br><span class="line"><span class="comment"> * 5. then 中执行回调的时候要捕获异常 将其传给下一个promise</span></span><br><span class="line"><span class="comment"> *    如果promise状态未变更 则将回调方法添加到对应队列中</span></span><br><span class="line"><span class="comment"> *    如果promise状态已经变更 需要异步处理成功或者失败回调</span></span><br><span class="line"><span class="comment"> *    因为可能出现 回调结果和当前then返回的Promise一致 从而导致死循环问题</span></span><br><span class="line"><span class="comment"> * 6. catch只是then的一种特殊的写法 方便理解和使用</span></span><br><span class="line"><span class="comment"> * 7. finally 特点 1. 不过resolve或者reject都会执行</span></span><br><span class="line"><span class="comment"> *                2. 回调没有参数</span></span><br><span class="line"><span class="comment"> *                3. 返回一个Promise 且值可以穿透到下一个then或者catch</span></span><br><span class="line"><span class="comment"> * 8. Promise.resolve, Promise.reject 根据其参数返回对应的值 或者状态的Promise即可</span></span><br><span class="line"><span class="comment"> * 9. Proise.all 特点  1. 返回一个Promise</span></span><br><span class="line"><span class="comment"> *                    2. 入参是数组 resolve的情况下出参也是数组 且结果顺序和调用顺序一致</span></span><br><span class="line"><span class="comment"> *                    3. 所有的值或者promise都完成才能resolve 所有要计数</span></span><br><span class="line"><span class="comment"> *                    4. 只要有一个为reject 返回的Promise便reject</span></span><br><span class="line"><span class="comment"> * 10. Proise.race 特点 1. 返回一个Promise</span></span><br><span class="line"><span class="comment"> *                    2. 入参是数组 那么出参根据第一个成功或者失败的参数来确定</span></span><br><span class="line"><span class="comment"> *                    3. 只要有一个resolve 或者reject 便更改返回Promise的状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  status = PENDING;</span><br><span class="line">  value = <span class="literal">undefined</span>;</span><br><span class="line">  reason = <span class="literal">undefined</span>;</span><br><span class="line">  successCallbacks = [];</span><br><span class="line">  failCallbacks = [];</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">exector</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 立即执行传入参数</span></span><br><span class="line">    <span class="comment">// 参数直接写为 this.resolve  会导致函数内 this指向会发生改变</span></span><br><span class="line">    <span class="comment">// 异步执行状态变更</span></span><br><span class="line">    <span class="comment">// 捕获执行器的异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        exector(</span><br><span class="line">          (value) =&gt; asyncExecFun(<span class="function">() =&gt;</span> <span class="built_in">this</span>.resolve(value)),</span><br><span class="line">          (reason) =&gt; asyncExecFun(<span class="function">() =&gt;</span> <span class="built_in">this</span>.reject(reason))</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">this</span>.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果状态已经变更则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">    <span class="comment">// 执行所有成功回调</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.successCallbacks.length) <span class="built_in">this</span>.successCallbacks.shift()();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果状态已经变更则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.reason = reason;</span><br><span class="line">    <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.failCallbacks.length)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;(in MyPromise)&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行所有失败回调</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.failCallbacks.length) <span class="built_in">this</span>.failCallbacks.shift()();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">successCallback, failCallback</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 成功函数处理 忽略函数之外的其他值</span></span><br><span class="line">    successCallback =</span><br><span class="line">      <span class="keyword">typeof</span> successCallback == <span class="string">&quot;function&quot;</span> ? successCallback : <span class="function">(<span class="params">v</span>) =&gt;</span> v;</span><br><span class="line">    <span class="comment">// 失败函数处理 忽略函数之外的其他值 抛出异常  实现catch冒泡的关键</span></span><br><span class="line">    failCallback =</span><br><span class="line">      <span class="keyword">typeof</span> failCallback == <span class="string">&quot;function&quot;</span></span><br><span class="line">        ? failCallback</span><br><span class="line">        : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 统一异常处理逻辑</span></span><br><span class="line">      <span class="keyword">const</span> execFun = <span class="function">(<span class="params">fn, val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> res = fn(val);</span><br><span class="line">          resolvePromise(promise, res, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 执行成功回调</span></span><br><span class="line">      <span class="keyword">const</span> execSuccessCallback = <span class="function">() =&gt;</span> execFun(successCallback, <span class="built_in">this</span>.value);</span><br><span class="line">      <span class="comment">// 执行失败回调</span></span><br><span class="line">      <span class="keyword">const</span> execFailCallback = <span class="function">() =&gt;</span> execFun(failCallback, <span class="built_in">this</span>.reason);</span><br><span class="line">      <span class="comment">// 同步将对应成功或者失败回调事件加入对应回调队列</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 将成功回调加入队列</span></span><br><span class="line">        <span class="built_in">this</span>.successCallbacks.push(execSuccessCallback);</span><br><span class="line">        <span class="comment">// 讲失败回调加入队列</span></span><br><span class="line">        <span class="built_in">this</span>.failCallbacks.push(execFailCallback);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 延迟执行 可以将函数执行结果和当前then 返回的promise 进行比较</span></span><br><span class="line">      asyncExecFun(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经 fulfilled 可直接调用成功回调方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">          execSuccessCallback();</span><br><span class="line">          <span class="comment">// 如果已经 rejected 可直接调用失败回调方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">          execFailCallback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(failCallback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, failCallback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">finally</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">      <span class="comment">// 穿透正常值</span></span><br><span class="line">      (value) =&gt; MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">      (reason) =&gt;</span><br><span class="line">        MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 穿透异常信息</span></span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 否则返回一个 MyPromise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (reason <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> reason;</span><br><span class="line">    <span class="comment">// 如果是MyPromise 实例 否则返回一个 MyPromise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">array</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 存储结果</span></span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">// 存储数组长度</span></span><br><span class="line">    <span class="keyword">let</span> len = array.length;</span><br><span class="line">    <span class="comment">// 创建返回MyPromise</span></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 定义当前MyPromise的索引</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 添加数据的公用方法</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">addData</span>(<span class="params">key, data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        result[key] = data;</span><br><span class="line">        <span class="comment">// 索引递增</span></span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">// 全部执行完则resolve</span></span><br><span class="line">        <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 按顺序变量数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = array[i];</span><br><span class="line">        <span class="comment">// 如果是MyPromise则 按其规则处理</span></span><br><span class="line">        <span class="keyword">if</span> (curr <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          curr.then(<span class="function">(<span class="params">value</span>) =&gt;</span> addData(i, value), reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 非MyPromise直接赋值</span></span><br><span class="line">          addData(i, curr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 返回新的MyPromise实例</span></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只要有一个成功或者失败就返回</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">array</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = array[i];</span><br><span class="line">        <span class="comment">// MyPromise实例 结果处理</span></span><br><span class="line">        <span class="keyword">if</span> (curr <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          curr.then(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 非MyPromise实例处理</span></span><br><span class="line">          resolve(curr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MyPromise;</span><br></pre></td></tr></table></figure></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>Post title：函数式编程与JS异步编程、手写Promise</li><li>Post author：wkxk</li><li>Create time：2021-04-20 17:35:17</li><li>Post link：http://www.iwkxk.com/2021/04/20/函数式编程与 JS 异步编程、手写 Promise/</li><li>Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.</li></ul></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2021/04/23/ES%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8ETypeScript%E3%80%81JS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">ES新特性与TypeScript、JS性能优化</span> <span class="post-nav-item">Prev posts</span></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;Comments</i></div><div id="gitalk-container"></div><script data-pjax src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script><script data-pjax>function loadGitalk(){let e=decodeURI(location.pathname);e.length>50&&(e=e.substring(0,47)+"...");try{Gitalk&&new Gitalk({clientID:"95ee2e163d7f20d8de19",clientSecret:"ad675c3bdff4af0fa754ab836be591c2e3aeb688",repo:"my-gitalk",owner:"wkxk",admin:["wkxk"],id:e,language:"zh"}).render("gitalk-container")}catch(e){window.Gitalk=null}}{const e=setTimeout(()=>{loadGitalk(),clearTimeout(e)},1e3)}</script></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span>&nbsp;-&nbsp; 2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">wkxk</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">Totalview&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text">高阶函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text">函数作为参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">1.2.</span> <span class="nav-text">函数作为返回值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">纯函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lodash-%E5%B7%A5%E5%85%B7%E5%BA%93"><span class="nav-number">3.</span> <span class="nav-text">lodash 工具库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">4.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="nav-number">5.</span> <span class="nav-text">柯里化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88"><span class="nav-number">6.</span> <span class="nav-text">函数组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E5%AD%90"><span class="nav-number">7.</span> <span class="nav-text">函子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Functor%E5%87%BD%E5%AD%90"><span class="nav-number">7.1.</span> <span class="nav-text">Functor函子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MayBe%E5%87%BD%E5%AD%90"><span class="nav-number">7.2.</span> <span class="nav-text">MayBe函子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Either%E5%87%BD%E5%AD%90"><span class="nav-number">7.3.</span> <span class="nav-text">Either函子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%87%BD%E5%AD%90"><span class="nav-number">7.4.</span> <span class="nav-text">IO函子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Task%E5%87%BD%E5%AD%90"><span class="nav-number">7.5.</span> <span class="nav-text">Task函子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pointed%E5%87%BD%E5%AD%90"><span class="nav-number">7.6.</span> <span class="nav-text">Pointed函子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Monad%E5%87%BD%E5%AD%90"><span class="nav-number">7.7.</span> <span class="nav-text">Monad函子</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number"></span> <span class="nav-text">JavaScript 异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EventLoop-%E4%BA%8B%E4%BB%B6%E7%8E%AF%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">EventLoop 事件环和消息队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.</span> <span class="nav-text">宏任务与微任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.</span> <span class="nav-text">Promise手写实现</span></a></li></ol></li></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/code-copy.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1});document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),e.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>