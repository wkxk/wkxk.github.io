<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="JavaScript,Vue2,Vue3,Vite,Webpack,node"><meta name="description" content="wkxk的个人博客，主要涉及到编程(JavaScript,Vue2,Vue3,Webpack,node),助于个人学习提升，分享学习过程"><meta name="author" content="wkxk"><title>Vue数据管理Vuex | wkxk&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/logo.7kmeykeizco0.svg"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"www.iwkxk.com",root:"/",language:"zh",path:"search.xml"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0,init_open:!0},style:{primary_color:"#0066CC",avatar:"https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/avator.2use3mem6940.svg",favicon:"https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/logo.7kmeykeizco0.svg",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"愿你眼里有光，眼底无霜，心有大海，胸无睚眦。风尘自仆仆，你我当归人。"},scroll:{progress_bar:{enable:!0},percent:{enable:!0}}},local_search:{enable:!0,preload:!0},code_copy:{enable:!0,style:"default"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.2"},KEEP.language_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"}</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-title" href="/">wkxk&#39;s Blog</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">HOME</a></li><li class="menu-item"><a href="/archives">ARCHIVES</a></li><li class="menu-item"><a href="/links">LINKS</a></li><li class="menu-item"><a href="/about">ABOUT</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">HOME</a></li><li class="drawer-menu-item flex-center"><a href="/archives">ARCHIVES</a></li><li class="drawer-menu-item flex-center"><a href="/links">LINKS</a></li><li class="drawer-menu-item flex-center"><a href="/about">ABOUT</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">Vue数据管理Vuex</span></div><div class="article-header"><div class="avatar"><img src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/avator.2use3mem6940.svg"></div><div class="info"><div class="author"><span class="name">wkxk</span> <span class="author-label">前端攻城狮</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp;2021-04-25 14:13:00 </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/Vuex/">Vuex</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Vue/">Vue</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>2.8k Words</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>11 Mins</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h2 id="组件内的状态管理流程"><a href="#组件内的状态管理流程" class="headerlink" title="组件内的状态管理流程"></a><strong>组件内的状态管理流程</strong></h2><p>**Vue 最核心的两个功能:数据驱动和组件化。 **</p><p><strong>组件化开发给我们带来了:</strong></p><ul><li>更快的开发效率</li><li>更好的可维护性</li></ul><p><strong>每个组件都有自己的状态、视图和行为等组成部分</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// state</span></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">&#125; &#125;,</span><br><span class="line"><span class="comment">// view</span></span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="comment">// actions</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment () &#123;</span><br><span class="line">      <span class="built_in">this</span>.count++</span><br><span class="line">&#125; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>状态管理包含以下几部分:</strong></p><ul><li><strong>state</strong>，驱动应用的数据源;</li><li><strong>view</strong>，以声明方式将 <strong>state</strong> 映射到视图;</li><li><strong>actions</strong>，响应在 <strong>view</strong> 上的用户输入导致的状态变化。</li></ul><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/image-20210424115319304.35zi4au5i480.png" alt="image-20210424115319304"></p><h2 id="组件间通信方式回顾"><a href="#组件间通信方式回顾" class="headerlink" title="组件间通信方式回顾"></a>组件间通信方式回顾</h2><p><strong>大多数场景下的组件都并不是独立存在的，而是相互协作共同构成了一个复杂的业务功能。在 Vue 中为不同的组件关系提供了不同的通信规则。</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/Snipaste_2021-04-24_11-58-08.6gle7qmmg600.png"></p><p><strong><a class="link" target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE">父传子:Props Down<i class="fas fa-external-link-alt"></i></a></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post title&#x3D;&quot;My journey with Vue&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line">Vue.component(&#39;blog-post&#39;, &#123;</span><br><span class="line">  props: [&#39;title&#39;],</span><br><span class="line">  template: &#39;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;h3&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components.html#%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6"><strong>子传父:Event Up</strong></a></p><p>在子组件中使用<code>$emit</code>发布一个自定义事件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=<span class="string">&quot;$emit(&#x27;enlargeText&#x27;, 0.1)&quot;</span>&gt;</span><br><span class="line">  Enlarge text</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><p><strong>在使用这个组件的时候，使用 v-on 监听这个自定义事件</strong></p><p><strong>使用事件抛出一个值</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-on:enlargeText</span>=<span class="string">&quot;hFontSize += $event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2"><strong>非父子组件:Event Bus</strong></a></p><p>我们可以使用一个非常简单的 Event Bus 来解决这个问题:</p><p><strong>eventbus.js :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default new Vue()</span><br></pre></td></tr></table></figure><p>然后在需要通信的两端:</p><p>使用 <code>$on</code> 订阅:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 没有参数 </span><br><span class="line">bus.$on(&#39;自定义事件名称&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">	&#x2F;&#x2F; 执行操作 </span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 有参数</span><br><span class="line">bus.$on(&#39;自定义事件名称&#39;, data &#x3D;&gt; &#123;</span><br><span class="line">	&#x2F;&#x2F; 执行操作 </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用<code>$emit</code>发布:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 没有自定义传参 </span><br><span class="line">bus.$emit(&#39;自定义事件名称&#39;);</span><br><span class="line">&#x2F;&#x2F; 有自定义传参 </span><br><span class="line">bus.$emit(&#39;自定义事件名称&#39;, 数据);</span><br></pre></td></tr></table></figure><p><strong>父直接访问子组件:通过</strong> <strong>ref</strong> <strong>获取子组件</strong></p><p><strong>ref</strong> 有两个作用:</p><ul><li>如果你把它作用到普通 HTML 标签上，则获取到的是 DOM</li><li>如果你把它作用到组件标签上，则获取到的是组件实例</li></ul><p><strong>创建 base-input 组件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input ref&#x3D;&quot;input&quot;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">&#x2F;&#x2F; 用来从父级组件聚焦输入框 focus: function () &#123;</span><br><span class="line">        this.$refs.input.focus()</span><br><span class="line">      &#125;</span><br><span class="line">&#125; &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>在使用子组件的时候，添加 ref 属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-input ref&#x3D;&quot;usernameInput&quot;&gt;&lt;&#x2F;base-input&gt;</span><br></pre></td></tr></table></figure><p>然后在父组件等渲染完毕后使用 <code>$refs</code>访问:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">  this.$refs.usernameInput.focus()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组 件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs 。</p></blockquote><h2 id="简易的状态管理方案"><a href="#简易的状态管理方案" class="headerlink" title="简易的状态管理方案"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/state-management.html"><strong>简易的状态管理方案</strong></a></h2><p><strong>如果多个组件之间要共享状态(数据)，使用上面的方式虽然可以实现，但是比较麻烦，而且多个组件之 间互相传值很难跟踪数据的变化，如果出现问题很难定位问题。</strong></p><p><strong>当遇到多个组件需要共享状态的时候，典型的场景:购物车。我们如果使用上述的方案都不合适，我们会遇到以下的问题</strong></p><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li></ul><p><strong>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。</strong><br><strong>对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</strong></p><p><strong>因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢?在这种模式下，我们的 组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为!</strong></p><p><strong>我们可以把多个组件的状态，或者整个程序的状态放到一个集中的位置存储，并且可以检测到数据的更 改。你可能已经想到了 Vuex。</strong></p><p><strong>这里我们先以一种简单的方式来实现</strong></p><ul><li><strong>首先创建一个共享的仓库 store 对象</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  debug: <span class="literal">true</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">    name: <span class="string">&#x27;xiaomao&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    sex: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125;,</span><br><span class="line">  setUserNameAction (name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.debug) &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&#x27;setUserNameAction triggered:&#x27;</span>, name) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.state.user.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>把共享的仓库 store 对象，存储到需要共享状态的组件的 data 中</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">  	<span class="comment">// 点击按钮的时候通过 action 修改状态 </span></span><br><span class="line">    change () &#123;</span><br><span class="line">      store.setUserNameAction(<span class="string">&#x27;componentB&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      privateState: &#123;&#125;,</span><br><span class="line">      sharedState: store.state</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接着我们继续延伸约定，组件不允许直接变更属于 store 对象的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，这样最终的样子跟 Vuex 的结构就类似了。这样约定的好处是，我 们能够记录所有 store 中发生的 state 变更，同时实现能做到记录变更、保存状态快照、历史回滚/时光 旅行的先进的调试工具。</strong></p><h2 id="什么是-Vuex"><a href="#什么是-Vuex" class="headerlink" title="什么是 Vuex"></a><strong>什么是</strong> <strong>Vuex</strong></h2><blockquote><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件 的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调 试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调 试功能。</p></blockquote><ul><li>Vuex 是专门为 Vue.js 设计的状态管理库</li><li>它采用集中式的方式存储需要共享的数据</li><li>从使用角度，它就是一个 JavaScript 库</li><li>它的作用是进行状态管理，解决复杂组件通信，数据共享</li></ul><h2 id="什么情况下使用-Vuex"><a href="#什么情况下使用-Vuex" class="headerlink" title="什么情况下使用 Vuex"></a><strong>什么情况下使用</strong> <strong>Vuex</strong></h2><blockquote><p>官方文档:</p><p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p><p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用 够简单，您最好不要使用 Vuex。一个简单的 store 模式就足够您所需了。但是，如果您需要构建 一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然 的选择。引用 Redux 的作者 Dan Abramov 的话说就是:Flux 架构就像眼镜:您自会知道什么时 候需要它。</p></blockquote><p>当你的应用中具有以下需求场景的时候:</p><ul><li>多个视图依赖于同一状态</li><li>来自不同视图的行为需要变更同一状态</li></ul><p>建议符合这种场景的业务使用 Vuex 来进行数据管理，例如非常典型的场景:购物车。</p><p><strong>注意:Vuex不要滥用，不符合以上需求的业务不要使用，反而会让你的应用变得更麻烦。</strong></p><h2 id="核心概念回顾"><a href="#核心概念回顾" class="headerlink" title="核心概念回顾"></a><strong>核心概念回顾</strong></h2><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/wkxk/blog-images@master/images/111.2gobfdq678nw.png"></p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a><strong>基本结构</strong></h3><ul><li>导入 Vuex</li><li>注册 Vuex</li><li>注入 $store 到 Vue 实例</li></ul><h4 id="State"><a href="#State" class="headerlink" title="State"></a><strong>State</strong></h4><p>Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。</p><p>使用 mapState 简化 State 在视图中的使用，mapState 返回计算属性</p><p>mapState 有两种使用的方式:</p><ul><li>接收数组参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 该方法是 vuex 提供的，所以使用前要先导入 </span><br><span class="line">import &#123; mapState &#125; from &#39;vuex&#39;</span><br><span class="line">&#x2F;&#x2F; mapState 返回名称为 count 和 msg 的计算属性 </span><br><span class="line">&#x2F;&#x2F; 在模板中直接使用 count 和 msg</span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState([&#39;count&#39;, &#39;msg&#39;]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接收对象参数</li></ul><p>如果当前视图中已经有了 count 和 msg，如果使用上述方式的话会有命名冲突，解决的方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 该方法是 vuex 提供的，所以使用前要先导入 </span><br><span class="line">import &#123; mapState &#125; from &#39;vuex&#39;</span><br><span class="line">&#x2F;&#x2F; 通过传入对象，可以重命名返回的计算属性</span><br><span class="line">&#x2F;&#x2F; 在模板中直接使用 num 和 message </span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    num: state &#x3D;&gt; state.count,</span><br><span class="line">    message: state &#x3D;&gt; state.msg</span><br><span class="line">	&#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a><strong>Getter</strong></h4><p>Getter 就是 store 中的计算属性，使用 mapGetter 简化视图中的使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetter &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">computed: &#123; </span><br><span class="line">  ...mapGetter([<span class="string">&#x27;reverseMsg&#x27;</span>]), </span><br><span class="line">  <span class="comment">// 改名，在模板中使用 reverse </span></span><br><span class="line">  ..mapGetter(&#123;</span><br><span class="line">    reverse: <span class="string">&#x27;reverseMsg&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a><strong>Mutation</strong></h4><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件:每 个 mutation 都有一个字符串的 <strong>事件类型</strong> <strong>(type)</strong> 和 一个 <strong>回调函数</strong> **(handler)**。这个回调函数就是我们 实际进行状态更改的地方，并且它会接受 state 作为第一个参数。</p><p>使用 Mutation 改变状态的好处是，集中的一个位置对状态修改，不管在什么地方修改，都可以追踪到 状态的修改。可以实现高级的 time-travel 调试功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">methods: &#123; </span><br><span class="line">  ...mapMutations([<span class="string">&#x27;increate&#x27;</span>]), </span><br><span class="line">  <span class="comment">// 传对象解决重名的问题 </span></span><br><span class="line">  ...mapMutations(&#123;</span><br><span class="line">    increateMut: <span class="string">&#x27;increate&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a><strong>Action</strong></h4><p>Action 类似于 mutation，不同在于:</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">methods: &#123; </span><br><span class="line">  ...mapActions([<span class="string">&#x27;increate&#x27;</span>]), </span><br><span class="line">  <span class="comment">// 传对象解决重名的问题 </span></span><br><span class="line">  ...mapActions(&#123;</span><br><span class="line">    increateAction: <span class="string">&#x27;increate&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a><strong>Module</strong></h4><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对 象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成**模块(<strong><strong>module</strong></strong>)**。每个模块拥有自己的 state、 mutation、action、getter、甚至是嵌套子模块。</p><p>在案例中体会 Module 的使用。</p><h2 id="模拟实现Vuex"><a href="#模拟实现Vuex" class="headerlink" title="模拟实现Vuex"></a>模拟实现Vuex</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a><strong>实现思路</strong></h3><ul><li>实现 install 方法<ul><li>Vuex 是 Vue 的一个插件，所以和模拟 VueRouter 类似，先实现 Vue 插件约定的 install 方法</li></ul></li><li>实现 Store 类<ul><li>实现构造函数，接收 options</li><li>state 的响应化处理</li><li>getter 的实现</li><li>commit、dispatch 方法</li></ul></li></ul><h4 id="install-方法"><a href="#install-方法" class="headerlink" title="install 方法"></a><strong>install</strong> <strong>方法</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  _Vue = Vue</span><br><span class="line">  _Vue.mixin(&#123;</span><br><span class="line">    beforeCreate () &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.$options.store) &#123;</span><br><span class="line">        Vue.prototype.$store = <span class="built_in">this</span>.$options.store</span><br><span class="line">      &#125;</span><br><span class="line">		&#125; </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Store-类"><a href="#Store-类" class="headerlink" title="Store 类"></a><strong>Store</strong> <strong>类</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      state = &#123;&#125;,</span><br><span class="line">      getters = &#123;&#125;,</span><br><span class="line">      mutations = &#123;&#125;,</span><br><span class="line">      actions = &#123;&#125;</span><br><span class="line">    &#125; = options</span><br><span class="line">    <span class="built_in">this</span>.state = _Vue.observable(state)</span><br><span class="line">    <span class="comment">// 此处不直接 this.getters = getters，是因为下面的代码中要方法 getters 中的 key</span></span><br><span class="line">    <span class="comment">// 如果这么写的话，会导致 this.getters 和 getters 指向同一个对象</span></span><br><span class="line">    <span class="comment">// 当访问 getters 的 key 的时候，实际上就是访问 this.getters 的 key 会触发 key 属性 的 getter</span></span><br><span class="line">    <span class="comment">// 会产生死递归</span></span><br><span class="line">    <span class="built_in">this</span>.getters = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">Object</span>.keys(getters).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>.getters, key, &#123;</span><br><span class="line">        get: <span class="function">() =&gt;</span> getters[key](<span class="built_in">this</span>.state)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.mutations = mutations</span><br><span class="line">    <span class="built_in">this</span>.actions = actions</span><br><span class="line">  &#125;</span><br><span class="line">  commit (type, payload) &#123;</span><br><span class="line">    <span class="built_in">this</span>.mutations[type](<span class="built_in">this</span>.state, payload)</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch (type, payload) &#123;</span><br><span class="line">    <span class="built_in">this</span>.actions[type](<span class="built_in">this</span>, payload)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出模块 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>Post title：Vue数据管理Vuex</li><li>Post author：wkxk</li><li>Create time：2021-04-25 14:13:00</li><li>Post link：http://www.iwkxk.com/2021/04/25/Vue数据管理Vuex/</li><li>Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.</li></ul></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2021/04/25/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93ssr/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">服务端渲染ssr</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2021/04/23/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Blog/"><span class="title flex-center"><span class="post-nav-title-item">手把手教你搭建一个属于自己的Blog</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;Comments</i></div><div id="gitalk-container"></div><script data-pjax src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script><script data-pjax>function loadGitalk(){let e=decodeURI(location.pathname);e.length>50&&(e=e.substring(0,47)+"...");try{Gitalk&&new Gitalk({clientID:"95ee2e163d7f20d8de19",clientSecret:"ad675c3bdff4af0fa754ab836be591c2e3aeb688",repo:"my-gitalk",owner:"wkxk",admin:["wkxk"],id:e,language:"zh"}).render("gitalk-container")}catch(e){window.Gitalk=null}}{const e=setTimeout(()=>{loadGitalk(),clearTimeout(e)},1e3)}</script></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span>&nbsp;-&nbsp; 2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">wkxk</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">Totalview&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">组件内的状态管理流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E5%9B%9E%E9%A1%BE"><span class="nav-number">2.</span> <span class="nav-text">组件间通信方式回顾</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E6%98%93%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88"><span class="nav-number">3.</span> <span class="nav-text">简易的状态管理方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Vuex"><span class="nav-number">4.</span> <span class="nav-text">什么是 Vuex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8-Vuex"><span class="nav-number">5.</span> <span class="nav-text">什么情况下使用 Vuex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%9B%9E%E9%A1%BE"><span class="nav-number">6.</span> <span class="nav-text">核心概念回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#State"><span class="nav-number">6.1.1.</span> <span class="nav-text">State</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Getter"><span class="nav-number">6.1.2.</span> <span class="nav-text">Getter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mutation"><span class="nav-number">6.1.3.</span> <span class="nav-text">Mutation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Action"><span class="nav-number">6.1.4.</span> <span class="nav-text">Action</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Module"><span class="nav-number">6.1.5.</span> <span class="nav-text">Module</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0Vuex"><span class="nav-number">7.</span> <span class="nav-text">模拟实现Vuex</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="nav-number">7.1.</span> <span class="nav-text">实现思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#install-%E6%96%B9%E6%B3%95"><span class="nav-number">7.1.1.</span> <span class="nav-text">install 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Store-%E7%B1%BB"><span class="nav-number">7.1.2.</span> <span class="nav-text">Store 类</span></a></li></ol></li></ol></li></ol></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/code-copy.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1});document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),e.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>